<html>
<head>
<title>js测试</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<script type="text/javascript">
/*
jQuery获取Select选择的Text和Value: 

 

1. $("#select_id").change(function(){//code...}); //为Select添加事件，当选择其中一项时触发

2. var checkText=$("#select_id").find("option:selected").text(); //获取Select选择的

3. var checkValue=$("#select_id").val(); //获取Select选择的Value

4. var checkIndex=$("#select_id ").get(0).selectedIndex; //获取Select选择的索引值

5. var maxIndex=$("#select_id option:last").attr("index"); //获取Select最大的索引值

 
//jQuery添加/删除Select的Option项：

1. $("#select_id").append("<option value='Value'>Text</option>"); //为Select追加一个Option(下拉项)

2. $("#select_id").prepend("<option value='0'>请选择</option>"); //为Select插入一个Option(第一个位置)

3. $("#select_id option:last").remove(); //删除Select中索引值最大Option(最后一个)

4. $("#select_id option[index='0']").remove(); //删除Select中索引值为0的Option(第一个)

5. $("#select_id option[value='3']").remove(); //删除Select中Value='3'的Optiona

5. $("#select_id option[text='4']").remove(); //删除Select中Text='4'的Optiona

内容清空：$("#charCity").empty();
*/

//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4
function fn(){}
//the value of implicit [[Prototype]] property of those objects derived from fn will be assigned to fn.prototype
fn.prototype={ attr1:"aaa", attr2:"bbb"};
var obj=new fn();
document.write(obj.attr1 + "<br />"); //result: aaa
document.write(obj.attr2 + "<br />"); //result: bbb
document.write(obj instanceof fn); //result: true
document.write("<br />");
//I change the prototype of fn here, so by the algorithm of Prototype the obj is no longer the instance of fn,
//but this won't affect the obj and its [[Prototype]] property, and the obj still has attr1 and attr2 properties
fn.prototype={};
document.write(obj.attr1 + "<br />"); //result: aaa
document.write(obj.attr2 + "<br />"); //result: bbb
document.write(obj instanceof fn); //result: false


//构造函数
 //使自己的对象多次复制，同时实例根据设置的访问等级可以访问其内部的属性和方法
 //当对象被实例化后，构造函数会立即执行它所包含的任何代码
 function myObject(msg){
     //特权属性(公有属性)
     this.myMsg = msg; //只在被实例化后的实例中可调用
     this.address = '上海';
     
     //私有属性
     var name = '豪情';
     var age = 29;
     var that = this;
     
     //私有方法
     function sayName(){
         alert(that.name);
     }
     //特权方法(公有方法)
     //能被外部公开访问
     //这个方法每次实例化都要重新构造而prototype是原型共享，所有实例化后，都共同引用同一个
     this.sayAge = function(){
         alert(name); //在公有方法中可以访问私有成员
     }
     //私有和特权成员在函数的内部，在构造函数创建的每个实例中都会包含同样的私有和特权成员的副本，
     //因而实例越多占用的内存越多
 }
 //公有方法
 //适用于通过new关键字实例化的该对象的每个实例
 //向prototype中添加成员将会把新方法添加到构造函数的底层中去
 myObject.prototype.sayHello = function(){
     alert('hello everyone!' + this.myMsg);
 }
 //静态属性
 //适用于对象的特殊实例，就是作为Function对象实例的构造函数本身
 myObject.name = 'china';
 //静态方法
 myObject.alertname = function(){
     alert(this.name);
 }
 //实例化
 var m1 = new myObject('111');
 //---- 测试属性 ----//
 console.log(myObject.name); //china
 console.log(m1.myMsg); //111
 console.log(m1.name); //undefined, 静态属性不适用于一般实例
 console.log(m1.constructor.name); //china, 想访问类的静态属性，先访问该实例的构造函数，然后在访问该类静态属性
 console.log(myObject.address); //undefined, myObject中的this指的不是函数本身，而是调用address的对象，而且只能是对象
 console.log(m1.address); //上海 此时this指的是实例化后的m1
 
 //---- 测试方法 ----//
myObject.alertname(); //china,直接调用函数的类方法
 //m1.alertname(); //FF: m1.alertname is not a function, alertname 是myObject类的方法，和实例对象没有直接关系
 m1.constructor.alertname(); //china, 调用该对象构造函数（类函数）的方法（函数）
 m1.sayHello(); //hello everyone, myObject类的prototype原型下的方法将会被实例继承
 myObject.sayHello(); //myObject.sayHello is not a function，sayHello是原型方法，不是类的方法
 
 //---- 测试prototype ----//
 //console.log(m1.prototype); //undefined, 实例对象没有prototype
 //console.log(myObject.prototype); //Object 
 //alert(myObject.prototype.constructor); //console.log返回myObject(msg)，此时alert()更清楚，相当于myObject
 //console.log(myObject.prototype.constructor.name); //china, 相当于myObject.name;
 </script>
 </html>