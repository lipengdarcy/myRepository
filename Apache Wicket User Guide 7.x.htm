<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
    <head>
        <title>Apache Wicket User Guide 7.x</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8" />
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    <script type="text/javascript">
function addJsClass(el) {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
    </head>

    <body class="body" onload="addJsClass();">
        <div id="navigation">
            <ul>
                <li>
                    <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                        <a href="../guide/index.html" class="button">Table of contents</a>
                        <div id="nav-summary-childs" style="display:none;">
                            
                            <div class="toc-item" style="margin-left:0"><a href="#introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#howToSource"><strong>2</strong><span>How to use the example code</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#whyLearn"><strong>3</strong><span>Why should I learn Wicket?</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#helloWorld"><strong>4</strong><span>Wicket says &ldquo;Hello world!&rdquo;</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#layout"><strong>5</strong><span>Wicket as page layout manager</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#keepControl"><strong>6</strong><span>Keeping control over HTML</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#componentLifecycle"><strong>7</strong><span>Components lifecycle</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#versioningCaching"><strong>8</strong><span>Page versioning and caching</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#requestProcessing"><strong>9</strong><span>Under the hood of the request processing</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#urls"><strong>10</strong><span>Wicket Links and URL generation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#modelsforms"><strong>11</strong><span>Wicket models and forms</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#forms2"><strong>12</strong><span>Wicket forms in detail</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#repeaters"><strong>13</strong><span>Displaying multiple items with repeaters</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#componentQueueing"><strong>14</strong><span>Component queueing</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#i18n"><strong>15</strong><span>Internationalization with Wicket</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#resources"><strong>16</strong><span>Resource management with Wicket</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#jsintegration"><strong>17</strong><span>An example of integration with JavaScript</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#advanced"><strong>18</strong><span>Wicket advanced topics</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#ajax"><strong>19</strong><span>Working with AJAX</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#jee"><strong>20</strong><span>Integration with enterprise containers</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#nativewebsockets"><strong>21</strong><span>Native WebSockets</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#security"><strong>22</strong><span>Security with Wicket</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#testing"><strong>23</strong><span>Test Driven Development with Wicket</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#testingspring"><strong>24</strong><span>Test Driven Development with Wicket and Spring</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#bestpractices"><strong>25</strong><span>Wicket Best Practices</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#internals"><strong>26</strong><span>Wicket Internals</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#monitoring"><strong>27</strong><span>Wicket Metrics Monitoring (Experimental)</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#maven"><strong>28</strong><span>Working with Maven (Appendix)</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#wicketstuff"><strong>29</strong><span>Project WicketStuff (Appendix)</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#redirects"><strong>30</strong><span>Lost In Redirection With Apache Wicket (Appendix)</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#contributing"><strong>31</strong><span>Contributing to this guide (Appendix)</span></a></div>
                            
                        </div>
                    </div>
                </li>
                <li class="separator selected">
                    <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
                </li>
            </ul>
        </div>
        <div id="header">
            <div class="images clearfix">
                
                <span id="logo"><a href="http://ci.apache.org/projects/wicket/guide/7.x/" target="_self"><img height="80px" src="http://ci.apache.org/projects/wicket/guide/7.x/img/apache-wicket.png"/></a></span>
                
                
                <span id="sponsor"><a href="http://www.apache.org/" target="_blank"><img style="width:300px;height:100px" src="http://wicket.apache.org/img/asf_logo_url.svg"/></a></span>
                
            </div>
            <p>Free Online Guide for Apache Wicket framework</p>
        </div>


        <table id="colset" border="0" cellpadding="0" cellspacing="0">
            <tr>
                <td id="col1">
                    <div id="main" class="corner-all">

                        <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                        <div class="project">
                            <h1>Apache Wicket User Guide - Reference Documentation</h1>
                            <p><strong>Authors:</strong> Andrea Del Bene, Martin Grigorov, Carsten Hufe, Christian Kroemer, Daniel Bartl, Paul Bor»ô, Tobias Soloschenko, Igor Vaynberg , Joachim Rohde</p>
                            <p><strong>Version:</strong> 7.x</p>
                            
                        </div>

                        
                        <div id="table-of-content">
                            <h2>Table of Contents</h2>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#howToSource"><strong>2</strong><span>How to use the example code</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#whyLearn"><strong>3</strong><span>Why should I learn Wicket?</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#whyLearn_1"><strong>3.1</strong><span>We all like spaghetti :-) ...</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#whyLearn_2"><strong>3.2</strong><span>Component oriented frameworks - an overview</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#whyLearn_3"><strong>3.3</strong><span>Benefits of component oriented frameworks for web development</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#whyLearn_4"><strong>3.4</strong><span>Wicket vs the other component oriented frameworks</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#helloWorld"><strong>4</strong><span>Wicket says &ldquo;Hello world!&rdquo;</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#helloWorld_1"><strong>4.1</strong><span>Wicket distribution and modules</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#helloWorld_2"><strong>4.2</strong><span>Configuration of Wicket applications</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#helloWorld_3"><strong>4.3</strong><span>The HomePage class</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#helloWorld_4"><strong>4.4</strong><span>Wicket Links</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#helloWorld_5"><strong>4.5</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#layout"><strong>5</strong><span>Wicket as page layout manager</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#layout_1"><strong>5.1</strong><span>Header, footer, left menu, content, etc...</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#layout_2"><strong>5.2</strong><span>Here comes the inheritance!</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#layout_3"><strong>5.3</strong><span>Divide et impera!</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#layout_4"><strong>5.4</strong><span>Markup inheritance with the wicket:extend tag</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#layout_5"><strong>5.5</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#keepControl"><strong>6</strong><span>Keeping control over HTML</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_1"><strong>6.1</strong><span>Hiding or disabling a component</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_2"><strong>6.2</strong><span>Modifing tag attributes</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_3"><strong>6.3</strong><span>Generating tag attribute 'id'</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_4"><strong>6.4</strong><span>Creating in-line panels with WebMarkupContainer</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_5"><strong>6.5</strong><span>Working with markup fragments</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_6"><strong>6.6</strong><span>Adding header contents to the final page</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_7"><strong>6.7</strong><span>Using stub markup in our pages/panels</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_8"><strong>6.8</strong><span>How to render component body only</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_9"><strong>6.9</strong><span>Hiding decorating elements with the wicket:enclosure tag</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_10"><strong>6.10</strong><span>Surrounding existing markup with Border</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#keepControl_11"><strong>6.11</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#componentLifecycle"><strong>7</strong><span>Components lifecycle</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentLifecycle_1"><strong>7.1</strong><span>Lifecycle stages of a component</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentLifecycle_2"><strong>7.2</strong><span>Hook methods for component lifecycle</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentLifecycle_3"><strong>7.3</strong><span>Initialization stage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentLifecycle_4"><strong>7.4</strong><span>Rendering stage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentLifecycle_5"><strong>7.5</strong><span>Removing stage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentLifecycle_6"><strong>7.6</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#versioningCaching"><strong>8</strong><span>Page versioning and caching</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#versioningCaching_1"><strong>8.1</strong><span>Stateful pages vs stateless</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#versioningCaching_2"><strong>8.2</strong><span>Stateful pages</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#versioningCaching_3"><strong>8.3</strong><span>Stateless pages</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#versioningCaching_4"><strong>8.4</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#requestProcessing"><strong>9</strong><span>Under the hood of the request processing</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#requestProcessing_1"><strong>9.1</strong><span>Class Application and request processing</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#requestProcessing_2"><strong>9.2</strong><span>Request and Response classes</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#requestProcessing_3"><strong>9.3</strong><span>The &ldquo;director&rdquo; of request processing - RequestCycle</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#requestProcessing_4"><strong>9.4</strong><span>Session Class</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#requestProcessing_5"><strong>9.5</strong><span>Exception handling</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#requestProcessing_6"><strong>9.6</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#urls"><strong>10</strong><span>Wicket Links and URL generation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#urls_1"><strong>10.1</strong><span>PageParameters</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#urls_2"><strong>10.2</strong><span>Bookmarkable links</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#urls_3"><strong>10.3</strong><span>Automatically creating bookmarkable links with tag wicket:link</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#urls_4"><strong>10.4</strong><span>External links</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#urls_5"><strong>10.5</strong><span>Stateless links</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#urls_6"><strong>10.6</strong><span>Generating structured and clear URLs</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#urls_7"><strong>10.7</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#modelsforms"><strong>11</strong><span>Wicket models and forms</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#modelsforms_1"><strong>11.1</strong><span>What is a model?</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#modelsforms_2"><strong>11.2</strong><span>Models and JavaBeans</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#modelsforms_3"><strong>11.3</strong><span>Wicket forms</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#modelsforms_4"><strong>11.4</strong><span>Component DropDownChoice</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#modelsforms_5"><strong>11.5</strong><span>Model chaining</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#modelsforms_6"><strong>11.6</strong><span>Detachable models</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#modelsforms_7"><strong>11.7</strong><span>Using more than one model in a component</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#modelsforms_8"><strong>11.8</strong><span>Use models!</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#modelsforms_9"><strong>11.9</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#forms2"><strong>12</strong><span>Wicket forms in detail</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_1"><strong>12.1</strong><span>Default form processing</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_2"><strong>12.2</strong><span>Form validation and feedback messages</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_3"><strong>12.3</strong><span>Input value conversion</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_4"><strong>12.4</strong><span>Validation with JSR 303</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_5"><strong>12.5</strong><span>Submit form with an IFormSubmittingComponent</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_6"><strong>12.6</strong><span>Nested forms</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_7"><strong>12.7</strong><span>Multi-line text input</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_8"><strong>12.8</strong><span>File upload</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_9"><strong>12.9</strong><span>Creating complex form components with FormComponentPanel</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_10"><strong>12.10</strong><span>Stateless form</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_11"><strong>12.11</strong><span>Working with radio buttons and checkboxes</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_12"><strong>12.12</strong><span>Selecting multiple values with ListMultipleChoices and Palette</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#forms2_13"><strong>12.13</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#repeaters"><strong>13</strong><span>Displaying multiple items with repeaters</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#repeaters_1"><strong>13.1</strong><span>The RepeatingView Component</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#repeaters_2"><strong>13.2</strong><span>The ListView Component</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#repeaters_3"><strong>13.3</strong><span>The RefreshingView Component</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#repeaters_4"><strong>13.4</strong><span>Pageable repeaters</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#repeaters_5"><strong>13.5</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#componentQueueing"><strong>14</strong><span>Component queueing</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentQueueing_1"><strong>14.1</strong><span>Markup hierarchy and code</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentQueueing_2"><strong>14.2</strong><span>Improved auto components</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentQueueing_3"><strong>14.3</strong><span>When are components dequeued?</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentQueueing_4"><strong>14.4</strong><span>Restrictions of queueing</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#componentQueueing_5"><strong>14.5</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#i18n"><strong>15</strong><span>Internationalization with Wicket</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#i18n_1"><strong>15.1</strong><span>Localization</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#i18n_2"><strong>15.2</strong><span>Localization in Wicket</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#i18n_3"><strong>15.3</strong><span>Bundles lookup algorithm</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#i18n_4"><strong>15.4</strong><span>Localization of component's choices</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#i18n_5"><strong>15.5</strong><span>Internationalization and Models</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#i18n_6"><strong>15.6</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#resources"><strong>16</strong><span>Resource management with Wicket</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_1"><strong>16.1</strong><span>Static vs dynamic resources</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_2"><strong>16.2</strong><span>Resource references</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_3"><strong>16.3</strong><span>Package resources</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_4"><strong>16.4</strong><span>Adding resources to page header section</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_5"><strong>16.5</strong><span>Context-relative resources</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_6"><strong>16.6</strong><span>Resource dependencies</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_7"><strong>16.7</strong><span>Aggregate multiple resources with resource bundles</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_8"><strong>16.8</strong><span>Put JavaScript inside page body</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_9"><strong>16.9</strong><span>Header contributors positioning</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_10"><strong>16.10</strong><span>Custom resources</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_11"><strong>16.11</strong><span>Mounting resources</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_12"><strong>16.12</strong><span>Shared resources</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_13"><strong>16.13</strong><span>Customizing resource loading</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_14"><strong>16.14</strong><span>CssHeaderItem and JavaScriptHeaderItem compression</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_15"><strong>16.15</strong><span>NIO resources</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_16"><strong>16.16</strong><span>Resourcen derived through models</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#resources_17"><strong>16.17</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#jsintegration"><strong>17</strong><span>An example of integration with JavaScript</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#jsintegration_1"><strong>17.1</strong><span>What we want to do...</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#jsintegration_2"><strong>17.2</strong><span>...and how we will do it</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#jsintegration_3"><strong>17.3</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#advanced"><strong>18</strong><span>Wicket advanced topics</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#advanced_1"><strong>18.1</strong><span>Enriching components with behaviors</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#advanced_2"><strong>18.2</strong><span>Generating callback URLs with IRequestListener</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#advanced_3"><strong>18.3</strong><span>Initializers</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#advanced_4"><strong>18.4</strong><span>Using JMX with Wicket</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#advanced_5"><strong>18.5</strong><span>Generating HTML markup from code</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#advanced_6"><strong>18.6</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#ajax"><strong>19</strong><span>Working with AJAX</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#ajax_1"><strong>19.1</strong><span>How to use AJAX components and behaviors</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#ajax_2"><strong>19.2</strong><span>Build-in AJAX components</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#ajax_3"><strong>19.3</strong><span>Built-in AJAX behaviors</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#ajax_4"><strong>19.4</strong><span>Using an activity indicator</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#ajax_5"><strong>19.5</strong><span>AJAX request attributes and call listeners</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#ajax_6"><strong>19.6</strong><span>Creating custom AJAX call listener</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#ajax_7"><strong>19.7</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#jee"><strong>20</strong><span>Integration with enterprise containers</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#jee_1"><strong>20.1</strong><span>Integrating Wicket with EJB</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#jee_2"><strong>20.2</strong><span>Integrating Wicket with Spring</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#jee_3"><strong>20.3</strong><span>JSR-330 annotations</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#jee_4"><strong>20.4</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#nativewebsockets"><strong>21</strong><span>Native WebSockets</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#nativewebsockets_1"><strong>21.1</strong><span>How does it work ?</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#nativewebsockets_2"><strong>21.2</strong><span>How to use</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#nativewebsockets_3"><strong>21.3</strong><span>Client-side APIs</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#nativewebsockets_4"><strong>21.4</strong><span>Testing</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#nativewebsockets_5"><strong>21.5</strong><span>Differences with Wicket-Atmosphere module.</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#nativewebsockets_6"><strong>21.6</strong><span>FAQ</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#security"><strong>22</strong><span>Security with Wicket</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#security_1"><strong>22.1</strong><span>Authentication</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#security_2"><strong>22.2</strong><span>Authorizations</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#security_3"><strong>22.3</strong><span>Using HTTPS protocol</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#security_4"><strong>22.4</strong><span>URLs encryption in detail</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#security_5"><strong>22.5</strong><span>Package Resource Guard</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#security_6"><strong>22.6</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#testing"><strong>23</strong><span>Test Driven Development with Wicket</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#testing_1"><strong>23.1</strong><span>Utility class WicketTester</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#testing_2"><strong>23.2</strong><span>Testing Wicket forms</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#testing_3"><strong>23.3</strong><span>Testing markup with TagTester</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#testing_4"><strong>23.4</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#testingspring"><strong>24</strong><span>Test Driven Development with Wicket and Spring</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#testingspring_1"><strong>24.1</strong><span>Configuration of the runtime environment</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#testingspring_2"><strong>24.2</strong><span>Configuration of the JUnit based integration test environment</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#testingspring_3"><strong>24.3</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#bestpractices"><strong>25</strong><span>Wicket Best Practices</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_1"><strong>25.1</strong><span>Encapsulate components correctly</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_2"><strong>25.2</strong><span>Put models and page data in fields</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_3"><strong>25.3</strong><span>Correct naming for Wicket IDs</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_4"><strong>25.4</strong><span>Avoid changes at the component tree</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_5"><strong>25.5</strong><span>Implement visibilities of components correctly</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_6"><strong>25.6</strong><span>Always use models</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_7"><strong>25.7</strong><span>Do not unwrap models within the constructor hierarchy</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_8"><strong>25.8</strong><span>Pass models extended components</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_9"><strong>25.9</strong><span>Validators must not change any data or models</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_10"><strong>25.10</strong><span>Do not pass components to constructors</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_11"><strong>25.11</strong><span>Use the Wicket session only for global data</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_12"><strong>25.12</strong><span>Do not use factories for components</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_13"><strong>25.13</strong><span>Every page and component must be tested</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_14"><strong>25.14</strong><span>Avoid interactions with other servlet filters</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_15"><strong>25.15</strong><span>Cut small classes and methods</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_16"><strong>25.16</strong><span>The argument &quot;Bad documentation&quot;</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#bestpractices_17"><strong>25.17</strong><span>Summary</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#internals"><strong>26</strong><span>Wicket Internals</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#pagestoring"><strong>26.1</strong><span>Page storing</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#autocomponents"><strong>26.2</strong><span>Markup parsing and Autocomponents</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#monitoring"><strong>27</strong><span>Wicket Metrics Monitoring (Experimental)</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#monitoring_1"><strong>27.1</strong><span>Example setup</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#monitoring_2"><strong>27.2</strong><span>Visualization with Graphite</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#monitoring_3"><strong>27.3</strong><span>Measured data</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#monitoring_4"><strong>27.4</strong><span>Write own measurements</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#maven"><strong>28</strong><span>Working with Maven (Appendix)</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#maven_1"><strong>28.1</strong><span>Switching Wicket to DEPLOYMENT mode</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#maven_2"><strong>28.2</strong><span>Creating a Wicket project from scratch and importing it into our favourite IDE</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#wicketstuff"><strong>29</strong><span>Project WicketStuff (Appendix)</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#wicketstuff_1"><strong>29.1</strong><span>What is project WicketStuff</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#wicketstuff_2"><strong>29.2</strong><span>Module tinymce</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#wicketstuff_3"><strong>29.3</strong><span>Module wicketstuff-gmap3</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#wicketstuff_4"><strong>29.4</strong><span>Module wicketstuff-googlecharts</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#wicketstuff_5"><strong>29.5</strong><span>Module wicketstuff-inmethod-grid</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#wicketstuff_6"><strong>29.6</strong><span>Module wicketstuff-rest-annotations</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#wicketstuff_7"><strong>29.7</strong><span>Module stateless</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#redirects"><strong>30</strong><span>Lost In Redirection With Apache Wicket (Appendix)</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#contributing"><strong>31</strong><span>Contributing to this guide (Appendix)</span></a></div>
                            
                            <div style="clear:both" ></div>
                        </div>
                        
                        

<h1 id="introduction">1 Introduction</h1>
Wicket has been around since 2004 and it has been an Apache project since 2007. During these years it has proved to be a solid and valuable solution for building enterprise web applications.<p class="paragraph"/>Wicket core developers have done a wonderful job with this framework and they continue to improve it release after release.
However Wicket never provided a freely available documentation and even if you can find on Internet many live examples and many technical articles on it (most of them at <a href="http://www.wicket-library.com/" target="blank">Wicket Library</a> and at <a href="http://wicketinaction.com" target="blank">Wicket in Action</a> ), the lack of an organized and freely available documentation has always been a sore point for this framework.<p class="paragraph"/>That's quite an issue because many other popular frameworks (like Spring, Hibernate or Struts) offer a vast and very good documentation which substantially contributed to their success.<p class="paragraph"/>This document is not intended to be a complete reference for Wicket but it simply aims to be a straightforward introduction to the framework that should significantly reduce its learning curve. What you will find here reflects my experience with Wicket and it's strictly focused on the framework.
The various Wicket-related topics are gradually introduced using pragmatic examples of code that you can find in <a href="https://github.com/bitstorm/Wicket-tutorial-examples" target="blank">the according repository on Github.</a><p class="paragraph"/>However remember that Wicket is a vast and powerful tool, so you should feel confident with the topics exposed in this document before starting to code your real applications!<p class="paragraph"/>For those who need further documentation on Wicket, there are <a href="http://wicket.apache.org/learn/books/" target="blank">many good books</a> available for this framework.<p class="paragraph"/>Hope you'll find this guide helpful. Have fun with Wicket!<p class="paragraph"/><strong class="bold">Andrea Del Bene, adelbene@apache.org</strong><p class="paragraph"/><strong class="bold">PS</strong>: this guide is based on Wicket 6. However if you are using an older version you should find this guide useful as well, but it's likely that the code and the snippets won't work with your version.<p class="paragraph"/><strong class="bold">PPS</strong>: although I've tried to do my best working on this tutorial, this document is a work in progress and may contain errors and/or omissions. That's why any feedback of any kind is REALLY appreciated!<p class="paragraph"/>Project started by <a href="http://comsysto.com/" target="blank"><img border="0" class="center" src="../img/comsysto-logo.png"></img></a><p class="paragraph"/>


<h1 id="howToSource">2 How to use the example code</h1>
Most of the code you will find in this document is available as a <a href="https://github.com/bitstorm/Wicket-tutorial-examples" target="blank">Git repository</a> and is licensed under the ASF 2.0. To get a local copy of the repository you can run the clone command from shell:<p class="paragraph"/><div class="code"><pre>git clone https://github.com/bitstorm/Wicket&#45;tutorial&#45;examples.git</pre></div><p class="paragraph"/>If you aren't used to Git, you can simply download the whole source as a zip archive:<p class="paragraph"/><img border="0" class="center" src="../img/gitRepo.png"></img><p class="paragraph"/>The repository contains a multi-module Maven project. Every subproject is contained in the relative folder of the repository:<p class="paragraph"/><img border="0" class="center" src="../img/gitMavenPrj.png"></img><p class="paragraph"/>When the example code is used in the document, you will find the name of the subproject it belongs to. If you don't have any experience with Maven, you can read Appendix A where you can learn the basic commands needed to work with the example projects and to import them into your favourite IDE (NetBeans, IDEA or Eclipse).


<h1 id="whyLearn">3 Why should I learn Wicket?</h1>
Software development is a challenging activity and developers must keep their skills up-to-date with new technologies.<p class="paragraph"/>But before starting to learn the last ‚Äúcoolest‚Äù framework we should always ask ourself if it is the right tool for us and how it can improve our everyday job.
Java's ecosystem is already full of many well-known web frameworks, so why should we spend our time learning Wicket?<p class="paragraph"/>This chapter will show you how Wicket is different from other web frameworks you may know and it will explain also how it can improve your life as web developer.


<h2 id="whyLearn_1">3.1 We all like spaghetti :-) ...</h2>
...but we all hate spaghetti code! That's why in the first half of the 2000s we have seen the birth of so many web frameworks. Their mission was to separate our business code from presentation layer (like JSP pages).<p class="paragraph"/>Some of theme (like Struts, Spring MVC, Velocity, etc...) have become widely adopted and they made the MVC pattern very popular among developers.
However, none of these frameworks offers a real object-oriented (OO) abstraction for web pages and we still have to take care of web-related tasks such as HTTP request/response handling, URLs mapping, storing data into user session and so on.<p class="paragraph"/>The biggest limit of MVC frameworks is that they don't do much to overcome the impedance mismatch between the stateless nature of HTTP protocol and the need of our web applications of handling a (very complex) state.<p class="paragraph"/>To overcome these limits developers have started to adopt a new generation of component oriented web frameworks designed to provide a completely different approach to web development.<p class="paragraph"/>


<h2 id="whyLearn_2">3.2 Component oriented frameworks - an overview</h2>
Component oriented frameworks differ from classic web frameworks in that they build a model of requested page on the server side and the HTML sent back to the client is generated according to this model. You can think of the model as if it was an ‚Äúinverse‚Äù JavaScript DOM, meaning that:
<ol>
<li>is built on server-side</li>
<li>is built before HTML is sent to client</li>
<li>HTML code is generated using this model and not vice versa.</li>
</ol><p class="paragraph"/>  <img border="0" class="center" src="../img/requesthandling-general.png"></img><p class="paragraph"/>   <em class="italic">General schema of page request handling for a component oriented framework</em> <p class="paragraph"/>With this kind of framework our web pages and their HTML components (forms, input controls, links, etc...), are pure class instances.
Since pages are class instances they live inside the JVM heap and we can handle them as we do with any other Java class.
This approach is very similar to what GUI frameworks (like Swing or SWT) do with desktop windows and their components. Wicket and the other component oriented frameworks bring to web development the same kind of abstraction that GUI frameworks offer when we build a desktop application. Most of those kind of frameworks hide the details of the HTTP protocol and naturally solve the problem of its stateless nature.<p class="paragraph"/>


<h2 id="whyLearn_3">3.3 Benefits of component oriented frameworks for web development</h2>
At this point some people may still wonder why OOP is so important also for web development and what benefits it can bring to developers.
Let's quickly review the main advantages that this paradigm can offer us:
<ul class="star">
<li><strong class="bold">Web pages are objects</strong>: web pages are not just text files sent back to the client. They are object instances and we can harness OOP to design web pages and their components. With Wicket we can also apply inheritance to HTML markup in order to build a consistent graphic layout for our applications (we will see markup inheritance in <a href="../guide/single.html#layout_2" class="guide">chapter 4.2</a>).</li>
<li><strong class="bold">We don't have to worry about application's state</strong>: pages and components can be considered stateful entities. They are Java objects and they can keep a state inside them and reference other objects. We can stop worrying about keeping track of user data stored inside the <code>HttpSession</code> and we can start managing them in a natural and transparent way.</li>
<li><strong class="bold">Testing web applications is much easier</strong>: since pages and components are pure objects, you can use JUnit to test their behavior and to ensure that they render as expected. Wicket has a set of utility classes for unit testing that simulate user interaction with web pages, hence we can write acceptance tests using just JUnit without any other test framework (unit testing is covered in <a href="../guide/single.html#testing" class="guide">chapter 23</a>).</li>
</ul><p class="paragraph"/>


<h2 id="whyLearn_4">3.4 Wicket vs the other component oriented frameworks</h2>
Wicket is not the only component oriented framework available in the Java ecosystem. Among its competitors we can find GWT (from Google), JSF (from Oracle), Vaadin (from Vaadin Ltd.), etc&#8230; Even if Wicket and all those other frameworks have their pros and cons, there are good reasons to prefer Wicket over them:
<ul class="star">
<li><strong class="bold">Wicket is 100% open source</strong>: Wicket is a top Apache project and it doesn't depend on any private company. You don't have to worry about future licensing changes, Wicket will always be released under Apache license 2.0 and freely available.</li>
<li><strong class="bold">Wicket is a community driven project</strong>: The Wicket team supports and promotes the dialogue with the framework's users through two mailing lists <a href="http://wicket.apache.org/help/email.html" target="blank">(one for users and another one for framework developers)</a> and an <a href="https://issues.apache.org/jira/browse/WICKET" target="blank">Apache JIRA</a> (the issue tracking system). Moreover, as any other Apache project, Wicket is developed paying great attention to user feedbacks and to suggested features.</li>
<li><strong class="bold">Wicket is just about Java and good old HTML</strong>: almost all web frameworks force users to adopt special tags or to use server side code inside HTML markup. This is clearly in contrast with the concept of separation between presentation and business logic and it leads to a more confusing code in our pages. In Wicket we don't have to take care of generating HTML inside the page itself, and we won't need to use any tag other than standard HTML tags. All we have to do is to attach our components (Java instances) to the HTML tags using a simple tag attribute called <code>wicket:id</code> (we will shortly see how to use it).</li>
<li><strong class="bold">With Wicket we can easily use JavaBeans and <a href="http://en.wikipedia.org/wiki/Plain_Old_Java_Object" target="blank">POJO</a> in our web tier</strong>: one of the most annoying and error-prone task in web development is collecting user input through a form and keeping form fields updated with previously inserted values. This usually requires a huge amount of code to extract input from request parameters (which are strings), parse them to Java types and store them into some kind of variable. And this is just half of the work we have to do as we must implement the inverse path (load data from Java to the web form).Moreover, most of the times our forms will use a JavaBean or a POJO as backing object, meaning that we must manually map form fields with the corresponding object fields and vice versa. Wicket comes with an intuitive and flexible mechanism that does this mapping for us without any configuration overhead (using a convention over configuration approach) and in a transparent way. <a href="../guide/single.html#modelsforms" class="guide">Chapter 10</a> will introduce the concept of Wicket model and we will learn how to harness this entity with forms.</li>
<li><strong class="bold">No complex XML needed</strong>: Wicket was designed to minimize the amount of configuration files needed to run our applications. No XML file is required except for the standard deployment descriptor web.xml (unless you are using Servlet 3 or a later version. See <a href="../guide/single.html#whyLearn_2" class="guide">Chapter 4</a> for more details).</li>
</ul><p class="paragraph"/>


<h1 id="helloWorld">4 Wicket says ‚ÄúHello world!‚Äù</h1>
Wicket allows us to design our web pages in terms of components and containers, just like AWT does with desktop windows. 
Both frameworks share the same component-based architecture: in AWT we have a <code>Windows</code> instance which represents the physical windows containing GUI components (like text fields, radio buttons, drawing areas, etc...), in Wicket we have a <code>WebPage</code> instance which represents the physical web page containing HTML components (pictures, buttons, forms, etc&#8230; ) .<p class="paragraph"/><img border="0" class="center" src="../img/uml-component.png"></img><p class="paragraph"/>In both frameworks we find a base class for GUI components called <code>Component</code>. Wicket pages can be composed (and usually are) by many components, just like AWT windows are composed by Swing/AWT components. Both frameworks promote the reuse of presentation code and GUI elements building custom components. Even if Wicket already comes with a rich set of ready-to-use components, building custom components is a common practice when working with this framework. We'll learn more about custom components in the next chapters.



<h2 id="helloWorld_1">4.1 Wicket distribution and modules</h2>
Wicket is available as a binary package on the main site <a href="http://wicket.apache.org" target="blank">http://wicket.apache.org</a> . Inside this archive we can find the distribution jars of the framework. Each jar corresponds to a sub-module of the framework. The following table reports these modules along with a short description of their purpose and with the related dependencies:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Module'sname</strong></th><th><strong class="bold">Description</strong></th><th><strong class="bold">Dependencies</strong></th></tr><tr class="table-odd"><td>wicket-core</td><td>Contains the main classes of the framework, like class <code>Component</code> and <code>Application</code>.</td><td>wicket-request, wicket-util</td></tr><tr class="table-even"><td>wicket-request</td><td>This module contains the classes involved into web request processing.</td><td>wicket-util</td></tr><tr class="table-odd"><td>wicket-util</td><td>Contains general-purpose utility classes for functional areas such as I/O, lang, string manipulation, security, etc...</td><td>None</td></tr><tr class="table-even"><td>wicket-datetime</td><td>Contains special purpose components designed to work with date and time.</td><td>wicket-core</td></tr><tr class="table-odd"><td>wicket-bean-validation</td><td>Provides support for JSR 303 standard validation.</td><td>wicket-core</td></tr><tr class="table-even"><td>wicket-devutils</td><td>Contains utility classes and components to help developers with tasks such as debugging, class inspection and so on.</td><td>wicket-core, wicket-extensions</td></tr><tr class="table-odd"><td>wicket-extensions</td><td>Contains a vast set of built-in components to build a rich UI for our web application (Ajax support is part of this module).</td><td>wicket-core</td></tr><tr class="table-even"><td>wicket-auth-roles</td><td>Provides support for role-based authorization.</td><td>wicket-core</td></tr><tr class="table-odd"><td>wicket-ioc</td><td>This module provides common classes to support Inversion Of Control. It's used by both Spring and Guice integration module.</td><td>wicket-core</td></tr><tr class="table-even"><td>wicket-guice</td><td>This module provides integration with the dependency injection framework developed by Google.</td><td>wicket-core, wicket-ioc</td></tr><tr class="table-odd"><td>wicket-spring</td><td>This module provides integration with Spring framework.</td><td>wicket-core, wicket-ioc</td></tr><tr class="table-even"><td>wicket-velocity</td><td>This module provides panels and utility class to integrate Wicket with Velocity template engine.</td><td>wicket-core</td></tr><tr class="table-odd"><td>wicket-jmx</td><td>This module provides panels and utility class to integrate Wicket with Java Management Extensions.</td><td>wicket-core</td></tr><tr class="table-even"><td>wicket-objectsizeof-agent</td><td>Provides integration with Java agent libraries and instrumentation tools.</td><td>wicket-core</td></tr></table><p class="paragraph"/>Please note that the core module depends on the utility and request modules, hence it cannot be used without them.



<h2 id="helloWorld_2">4.2 Configuration of Wicket applications</h2>
In this chapter we will see a classic Hello World! example implemented using a Wicket page with a built-in component called <code>Label</code> (the code is from project the HelloWorldExample). Since this is the first example of the guide, before looking at Java code we will go through the common artifacts needed to build a Wicket application from scratch.<p class="paragraph"/><blockquote class="note">
All the example projects presented in this document have been generated using Maven and the utility page at <a href="http://wicket.apache.org/start/quickstart.html" target="blank">http://wicket.apache.org/start/quickstart.html</a> . <strong class="bold">Appendix A</strong> contains the instructions needed to use these projects and build a quickstart application using Apache Maven. All the artifacts used in the next example (files web.xml, HomePage.class and HomePage.html) are automatically generated by Maven.
</blockquote><p class="paragraph"/><h3>Wicket application structure</h3><p class="paragraph"/>A Wicket application is a standard Java EE web application, hence it is deployed through a web.xml file placed inside folder WEB-INF:<p class="paragraph"/><img border="0" class="center" src="../img/webinf.png"></img><p class="paragraph"/> <em class="italic">Illustration : The standard directory structure of a Wicket application</em> <p class="paragraph"/>The content of web.xml declares a servlet filter (class <code>org.apache.wicket.Protocol.http.WicketFilter</code>) which dispatches web requests to our Wicket application:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;?xml version=<span class="xml&#45;quote">"1.0"</span> encoding=<span class="xml&#45;quote">"UTF&#45;8"</span>?&#62;</span>
<span class="xml&#45;tag">&#60;web&#45;app&#62;</span>
    <span class="xml&#45;tag">&#60;display&#45;name&#62;</span>Wicket Test<span class="xml&#45;tag">&#60;/display&#45;name&#62;</span>
    <span class="xml&#45;tag">&#60;filter&#62;</span>
        <span class="xml&#45;tag">&#60;filter&#45;name&#62;</span>TestApplication<span class="xml&#45;tag">&#60;/filter&#45;name&#62;</span>
        <span class="xml&#45;tag">&#60;filter&#45;class&#62;</span>org.apache.wicket.protocol.http.WicketFilter<span class="xml&#45;tag">&#60;/filter&#45;class&#62;</span>
        <span class="xml&#45;tag">&#60;init&#45;param&#62;</span>
          <span class="xml&#45;tag">&#60;param&#45;name&#62;</span>applicationClassName<span class="xml&#45;tag">&#60;/param&#45;name&#62;</span>
          <span class="xml&#45;tag">&#60;param&#45;value&#62;</span>org.wicketTutorial.WicketApplication<span class="xml&#45;tag">&#60;/param&#45;value&#62;</span>
        <span class="xml&#45;tag">&#60;/init&#45;param&#62;</span>
    <span class="xml&#45;tag">&#60;/filter&#62;</span>
    <span class="xml&#45;tag">&#60;filter&#45;mapping&#62;</span>
        <span class="xml&#45;tag">&#60;filter&#45;name&#62;</span>TestApplication<span class="xml&#45;tag">&#60;/filter&#45;name&#62;</span>
        <span class="xml&#45;tag">&#60;url&#45;pattern&#62;</span>/&#42;<span class="xml&#45;tag">&#60;/url&#45;pattern&#62;</span>
    <span class="xml&#45;tag">&#60;/filter&#45;mapping&#62;</span>
<span class="xml&#45;tag">&#60;/web&#45;app&#62;</span></pre></div><p class="paragraph"/>Since this is a standard servlet filter we must map it to a specific set of URLs through the <code>&#60;filter-mapping&#62;</code> tag). In the xml above we have mapped every URL to our Wicket filter.<p class="paragraph"/>If we are using Servlet 3 or a later version, we can of course use a class in place of web.xml to configure our application. The following example uses annotation @WebFilter.<p class="paragraph"/><div class="code"><pre>@WebFilter(value = <span class="java&#45;quote">"/&#42;"</span>, initParams = &#123; @WebInitParam(name = <span class="java&#45;quote">"applicationClassName"</span>, value = <span class="java&#45;quote">"com.mycompany.WicketApplication"</span>), 
				@WebInitParam(name=<span class="java&#45;quote">"filterMappingUrlPattern"</span>, value=<span class="java&#45;quote">"/&#42;"</span>) &#125;)
<span class="java&#45;keyword">public</span> class ProjectFilter <span class="java&#45;keyword">extends</span> WicketFilter &#123;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><p class="paragraph"/><blockquote class="note">
Wicket can be started in two modes named respectively DEVELOPMENT and DEPLOYMENT. The first mode activates some extra features which help application development, like resources monitoring and reloading, full stack trace rendering of exceptions, an AJAX debugger window, etc&#8230; The DEPLOYMENT mode turns off all these features optimizing performances and resource consumption. In our example projects we will use the default mode which is DEVELOPMENT. <a href="../guide/single.html#maven_1" class="guide">Chapter 24.1</a> contains the chapter ‚ÄúSwitching Wicket to DEPLOYMENT mode‚Äú where we can find further details about these two modes as well as the possible ways we have to set the desired one. In any case, DO NOT deploy your applications in a production environment without switching to DEPLOYMENT mode!
</blockquote><p class="paragraph"/><h3>The application class</h3><p class="paragraph"/>If we look back at web.xml we can see that we have provided the Wicket filter with a parameter called  <code>applicationClassName</code>. This value must be the fully qualified class name of a subclass of <code>org.apache.wicket.Application</code>. This subclass represents our web application built upon Wicket and it's responsible for configuring it when the server is starting up. Most of the times our custom application class won't inherit directly from class <code>Application</code>, but rather from class <code>org.apache.wicket.protocol.http.WebApplication</code> which provides a closer integration with servlet infrastructure. 
Class <code>Application</code> comes with a set of configuration methods that we can override to customize our application's settings. One of these methods is <code>getHomePage()</code> that must be overridden as it is declared abstract:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">abstract</span> <span class="java&#45;object">Class</span>&#60;? <span class="java&#45;keyword">extends</span> Page&#62; getHomePage()</pre></div><p class="paragraph"/>As you may guess from its name, this method specifies which page to use as homepage for our application. 
Another important method is <code>init()</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">protected</span> void init()</pre></div><p class="paragraph"/>This method is called when our application is loaded by the web server (Tomcat, Jetty, etc...) and is the ideal place to put our configuration code. The <code>Application</code> class exposes its settings grouping them into interfaces (you can find them in package <code>org.apache.wicket.settings</code>). We can access these interfaces through getter methods that will be gradually introduced in the next chapters when we will cover the related settings.<p class="paragraph"/>The current application's instance can be retrieved at any time calling static method <code>Application.get()</code> in our code. We will give more details about this method in <a href="../guide/single.html#requestProcessing_3" class="guide">chapter 9.3</a>. The content of the application class from project HelloWorldExample is the following:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class WicketApplication <span class="java&#45;keyword">extends</span> WebApplication
&#123;    	
	@Override
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">Class</span>&#60;? <span class="java&#45;keyword">extends</span> WebPage&#62; getHomePage()
	&#123;
		<span class="java&#45;keyword">return</span> HomePage.class;
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> void init()
	&#123;
		<span class="java&#45;keyword">super</span>.init();
		// add your configuration here
	&#125;
&#125;</pre></div><p class="paragraph"/>Since this is a very basic example of a Wicket application, we don't need to specify anything inside the <code>init</code> method. The home page of the application is the <code>HomePage</code> class. In the next paragraph we will see how this page is implemented and which conventions we have to follow to create a page in Wicket.<p class="paragraph"/><blockquote class="note">
Declaring a <code>WicketFilter</code> inside web.xml descriptor is not the only way we have to kickstart our application.
If we prefer to use a servlet instead of a filter, we can use class <code>org.apache.wicket.protocol.http.WicketServlet</code>. See the JavaDoc for further details.
</blockquote>


<h2 id="helloWorld_3">4.3 The HomePage class</h2>
<p class="paragraph"/>To complete our first Wicket application we must explore the home page class that is returned by the <code>Application</code>'s method <code>getHomePage()</code> seen above. 
In Wicket a web page is a subclass of <code>org.apache.wicket.WebPage</code>. This subclass must have a corresponding HTML file which will be used by the framework as template to generate its HTML markup. This file is a regular plain HTML file (its extension must be html).<p class="paragraph"/>By default this HTML file must have the same name of the related page class and must be in the same package:<p class="paragraph"/><img border="0" class="center" src="../img/samepackage.png"></img><p class="paragraph"/> <em class="italic">Illustration :Page class and its related HTML file</em> <p class="paragraph"/>If you don't like to put class and html side by side (let's say you want all your HTML files in a separated folder) you can use Wicket settings to specify where HTML files can be found. We will cover this topic later in <a href="../guide/single.html#resources_9" class="guide">chapter 16.9</a>.<p class="paragraph"/>The Java code for the <code>HomePage</code> class is the following:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.wicketTutorial;<p class="paragraph"/><span class="java&#45;keyword">import</span> org.apache.wicket.request.mapper.parameter.PageParameters;
<span class="java&#45;keyword">import</span> org.apache.wicket.markup.html.basic.Label;
<span class="java&#45;keyword">import</span> org.apache.wicket.markup.html.WebPage;<p class="paragraph"/><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;	
    <span class="java&#45;keyword">public</span> HomePage() &#123;
	add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"helloMessage"</span>, <span class="java&#45;quote">"Hello WicketWorld!"</span>));
    &#125;
&#125;</pre></div><p class="paragraph"/>Apart from subclassing <code>WebPage</code>, <code>HomePage</code> defines a constructor that adds a <code>Label</code> component to  itself. 
Method <code>add(Component component)</code> is inherited from ancestor class <code>org.apache.wicket.MarkupContainer</code> and is used to add children components to a web page. We'll see more about <code>MarkupContainer</code> later in <a href="../guide/single.html#layout_2" class="guide">chapter 5.2</a>.
Class <code>org.apache.wicket.markup.html.basic.Label</code> is the simplest component shipped with Wicket. It just inserts a string (the second argument of its constructor) inside the corresponding HTML tag.
Just like any other Wicket component, <code>Label</code> needs a textual id (<code>'helloMessage'</code> in our example) to be instantiated. At runtime Wicket will use this value to find the HTML tag we want to bind to the component. This tag must have a special attribute called <code>wicket:id</code> and its value must be identical to the component id (comparison is case-sensitive!).<p class="paragraph"/>Here is the HTML markup for <code>HomePage</code> (file HomePage.html):<p class="paragraph"/><div class="code"><pre>&#60;!DOCTYPE html&#62;
&#60;html&#62;
	&#60;head&#62;
		&#60;meta charset=<span class="java&#45;quote">"utf&#45;8"</span> /&#62;
		&#60;title&#62;Apache Wicket HelloWorld&#60;/title&#62;
	&#60;/head&#62;
	&#60;body&#62;<p class="paragraph"/>		&#60;div wicket:id=<span class="java&#45;quote">"helloMessage"</span>&#62;
		&#91;Label's message goes here&#93;
		&#60;/div&#62;
	&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>We can see that the <code>wicket:id</code> attribute is set according to the value of the component id. If we run this example we will see the text <code>Hello WicketWorld!</code> Inside a <code>&#60;div&#62;</code> tag.<p class="paragraph"/><blockquote class="note">
<code>Label</code> replaces the original content of its tag (in our example <code>Label's message goes here</code>) with the string passed as value (<code>Hello WicketWorld!</code> in our example).
</blockquote><p class="paragraph"/><blockquote class="warning">
If we specify a <code>wicket:id</code> attribute for a tag without adding the corresponding component in our Java code, Wicket will throw a <code>ComponentNotFound</code> Exception.  On the contrary if we add a component in our Java code without specifying a corresponding <code>wicket:id</code> attribute in our markup, Wicket will throw a <code>WicketRuntimeException</code>.
</blockquote>



<h2 id="helloWorld_4">4.4 Wicket Links</h2>
The basic form of interaction offered by web applications is to navigate through pages using links. In HTML a link is basically a pointer to another resource that most of the time is another page. Wicket implements links with component <code>org.apache.wicket.markup.html.link.Link</code>, but due to the component-oriented nature of the framework, this component is quite different from classic HTML links.  
Following the analogy with GUI frameworks, we can consider Wicket link as a ‚Äúclick‚Äù event handler: its purpose is to perform some actions (on server side!) when the user clicks on it.<p class="paragraph"/>That said, you shouldn't be surprised to find an abstract method called <code>onClick()</code> inside the <code>Link</code> class. In the following example we have a page with a <code>Link</code> containing an empty implementation of <code>onClick</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
	<span class="java&#45;keyword">public</span> HomePage()&#123;
		add(<span class="java&#45;keyword">new</span> Link(<span class="java&#45;quote">"id"</span>)&#123;
			@Override
			<span class="java&#45;keyword">public</span> void onClick() &#123;
				//link code goes here
		    &#125;			
		&#125;);
	&#125;
&#125;</pre></div><p class="paragraph"/>By default after <code>onClick</code> has been executed, Wicket will send back to the current page to the client web browser. If we want to navigate to another page we must use method <code>setResponsePage</code> of class <code>Component</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
	<span class="java&#45;keyword">public</span> HomePage()&#123;
		add(<span class="java&#45;keyword">new</span> Link(<span class="java&#45;quote">"id"</span>)&#123;
			@Override
			<span class="java&#45;keyword">public</span> void onClick() &#123;			   
                         //we redirect browser to another page.
                         setResponsePage(AnotherPage.class);
			&#125;			
		&#125;);
	&#125;
&#125;</pre></div><p class="paragraph"/>In the example above we used a version of <code>setResponsePage</code> which takes as input the class of the target page. In this way a new instance of <code>AnotherPage</code> will be created each time we click on the link. The other version of <code>setResponsePage</code> takes in input a page instance instead of a page class:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void onClick() &#123;			   
	//we redirect browser to another page.
	AnotherPage anotherPage = <span class="java&#45;keyword">new</span> AnotherPage();
	setResponsePage(anotherPage);
&#125;</pre></div><p class="paragraph"/>The difference between using the first version of <code>setResponsePage</code> rather than the second one will be illustrated in <a href="../guide/single.html#versioningCaching" class="guide">chapter 8</a>, when we will introduce the topic of stateful and stateless pages. For now, we can consider them as equivalent.<p class="paragraph"/>Wicket comes with a rich set of link components suited for every need (links to static URL, Ajax-enhanced links, links to a file to download, links to external pages and so on). We will see them in <a href="../guide/single.html#urls" class="guide">chapter 10</a>.<p class="paragraph"/><blockquote class="note">
We can specify the content of a link (i.e. the text of the picture inside it) with its method <code>setBody</code>. This method takes in input a generic Wicket model, which will be the topic of <a href="../guide/single.html#modelsforms" class="guide">chapter 11</a>.
</blockquote>



<h2 id="helloWorld_5">4.5 Summary</h2>
In this chapter we have seen the basic elements that compose a Wicket application. We have started preparing the configuration artifacts needed for our applications. As promised in <a href="../guide/single.html#helloWorld_4" class="guide">chapter 2.4</a>, we needed to put in place just a minimal amount of XML with an application class and a home page. 
Then we have continued our ‚Äúfirst contact‚Äù with Wicket learning how to build a simple page with a label component as child. This example page has shown us how Wicket maps components to HTML tags and how it uses both of them to generate the final HTML markup. 
In the last paragraph we had a first taste of Wicket links and we have seen how they can be considered as a ‚Äúclick‚Äù event listener and how they can be used to navigate from a page to another.


<h1 id="layout">5 Wicket as page layout manager</h1>
Before going ahead with more advanced topics, we will see how to maintain a consistent layout across our site using Wicket and its component-oriented features. Probably this is not the most interesting use we can get out of Wicket, but it is surely the simplest one so it's the best way to get our hands dirty with some code.



<h2 id="layout_1">5.1 Header, footer, left menu, content, etc...</h2>
There was a time in the 90s when Internet was just a buzzword and watching a plain HTML page being rendered by a browser was a new and amazing experience. In those days we used to organize our page layout using the <code>&#60;frame&#62;</code> HTML tag. Over the years this tag has almost disappeared from our code and it survives only in few specific domains. For example is still being used by JavaDoc.<p class="paragraph"/>With the adoption of server side technologies like JSP, ASP or PHP the tag <code>&#60;frame&#62;</code> has been replaced by a template-based approach where we divide our page layout into some common areas that will be present in each page of our web application. Then, we manually insert these areas in every page including the appropriate markup fragments.<p class="paragraph"/>In this chapter we will see how to use Wicket to build a site layout. The sample layout we will use is a typical page layout consisting of the following areas:
<ul class="star">
<li><strong class="bold">a header</strong> which could contain site title, some logos, a navigation bar, etc...</li>
<li><strong class="bold">a left</strong> menu with a bunch of links to different areas/functionalities of the site.</li>
<li><strong class="bold">a footer</strong> with generic informations like web master's email, the company address, etc...</li>
<li><strong class="bold">a content</strong> area which usually contains the functional part of the page.</li>
</ul><p class="paragraph"/>The following picture summarises the layout structure:<p class="paragraph"/><img border="0" class="center" src="../img/layout.png"></img><p class="paragraph"/>Once we have chosen a page layout, our web designer can start building up the site theme. The result is a beautiful mock of our future web pages. Over this mock we can map the original layout areas:<p class="paragraph"/><img border="0" class="center" src="../img/layout-mock.png"></img><p class="paragraph"/>Now in order to have a consistent layout across all the site, we must ensure that each page will include the layout areas seen above. With an old template-based approach we must manually put them inside every page. If we were using JSP we would probably end up using <code>include</code> directive to add layout areas in our pages. We would have one <code>include</code> for each of the areas (except for the content):<p class="paragraph"/><img border="0" class="center" src="../img/layout-include.png"></img><p class="paragraph"/><blockquote class="note">
For the sake of simplicity we can consider each included area as a static HTML fragment.
</blockquote><p class="paragraph"/>Now let's see how we can handle the layout of our web application using Wicket.


<h2 id="layout_2">5.2 Here comes the inheritance!</h2>
The need of ensuring a consistent layout across our pages unveiled a serious limit of the HTML: the inability to apply inheritance to web pages and their markup. Wouldn't be great if we could write our layout once in a page and then inherit it in the other pages of our application? 
One of the goals of Wicket is to overcome this kind of limit.<p class="paragraph"/><h3>Markup inheritance</h3><p class="paragraph"/>As we have seen in the previous chapter, Wicket pages are pure Java classes, so we can easily write a page which is a subclass of another parent page. But in Wicket inheritance is not limited to the classic object-oriented code inheritance. When a class subclasses a <code>WebPage</code> it also inherits the HTML file of the parent class. This type of inheritance is called markup inheritance.
To better illustrate this concept let's consider the following example where we have a page class called <code>GenericSitePage</code> with the corresponding HTML file GenericSitePage.html. Now let's create a specific page called <code>OrderCheckOutPage</code> where users can check out their orders on our web site. This class extends <code>GenericSitePage</code> but we don't provide it with any corresponding HTML file.
In this scenario <code>OrderCheckOutPage</code> will use GenericSitePage.html as markup file:<p class="paragraph"/><img border="0" class="center" src="../img/markup-inheritance.png"></img><p class="paragraph"/>Markup inheritance comes in handy for page layout management as it helps us avoid the burden of checking that each page conforms to the site layout. However to fully take advantage of markup inheritance we must first learn how to use another important component of the framework that supports this feature: the panel.<p class="paragraph"/><blockquote class="warning">
If no markup is found (nor directly assigned to the class, neither inherited from an ancestor) a <code>MarkupNotFoundException</code> is thrown.
</blockquote><p class="paragraph"/><h3>Panel class</h3><p class="paragraph"/>Class <code>org.apache.wicket.markup.html.panel.Panel</code> is a special component which lets us reuse GUI code and HTML markup across different pages and different web applications. It shares a common ancestor class with WebPage class, which is <code>org.apache.wicket.MarkupContainer</code>:<p class="paragraph"/><img border="0" class="center" src="../img/page-panel-hierarchy.png"></img><p class="paragraph"/> <em class="italic">Illustration: Hierarchy of WebPage and Panel classes</em> <p class="paragraph"/>Subclasses of <code>MarkupContainer</code> can contain children components that can be added with method <code>add(Component...)</code> (seen in <a href="../guide/single.html#whyLearn_3" class="guide">chapter 3.3</a>). <code>MarkupContainer</code> implements a full set of methods to manage children components. The basic operations we can do on them are:
<ul class="star">
<li>add one or more children components (with method <code>add</code>).</li>
<li>remove a specific child component (with method <code>remove</code>).</li>
<li>retrieve a specific child component with method <code>get(String)</code>. The string parameter is the id of the component or its relative path if the component is nested inside other <code>MarkupContainer</code>s. This path is a colon-separated string containing also the ids of the intermediate containers traversed to get to the child component. To illustrate an example of component path, let's consider the code of the following page:</li>
</ul><p class="paragraph"/><div class="code"><pre>MyPanel myPanel = <span class="java&#45;keyword">new</span> MyPanel (<span class="java&#45;quote">"innerContainer"</span>);
add(myPanel);</pre></div><p class="paragraph"/>Component <code>MyPanel</code> is a custom panel containing only a label having <code>"name"</code> as id. Under those conditions we could retrieve this label from the container page using the following path expression:<p class="paragraph"/><div class="code"><pre>Label name = (Label)get(<span class="java&#45;quote">"innerContainer:name"</span>);</pre></div>
<ul class="star">
<li>replace a specific child component with a new component having the same id (with method <code>replace</code>).</li>
<li>iterate thought children components with the iterator returned by method <code>iterator</code> or using visitor pattern1 with methods <code>visitChildren</code>.</li>
</ul><p class="paragraph"/>Both <code>Panel</code> and <code>WebPage</code> have their own associated markup file which is used to render the corresponding component. If such file is not provided, Wicket will apply markup inheritance looking for a markup file through their ancestor classes. When a panel is attached to a container, the content of its markup file is inserted into its related tag.<p class="paragraph"/>While panels and pages have much in common, there are some notable differences between these two components that we should keep in mind. The main difference between them is that pages can be rendered as standalone entities while panels must be placed inside a page to be rendered. Another important difference is the content of their markup file: for both <code>WebPage</code> and <code>Panel</code> this is a standard HTML file, but <code>Panel</code> uses a special tag to indicate which part of the whole file will be considered as markup source. This tag is <code>&#60;wicket:panel&#62;</code>. A markup file for a panel will typically look like this:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
&#60;meta http&#45;equiv=<span class="java&#45;quote">"Content&#45;Type"</span> content=<span class="java&#45;quote">"text/html; charset=UTF&#45;8"</span>&#62;
&#8230;
&#60;/head&#62;
&#60;body&#62;
   &#60;wicket:panel&#62;
      &#60;!&#45;&#45; Your markup goes here &#45;&#45;&#62;
       &#60;/wicket:panel&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The HTML outside tag <code>&#60;wicket:panel&#62;</code> will be removed during rendering phase. The space outside this tag can be used by both web developers and web designers to place some mock HTML to show how the final panel should look like.



<h2 id="layout_3">5.3 Divide et impera!</h2>
Let's go back to our layout example. In <a href="../guide/single.html#layout_1" class="guide">chapter 5.1</a> we have divided our layout in common areas that must be part of every page. Now we will build a reusable template page for our web application combining pages and panels. The code examples are from project MarkupInheritanceExample.<p class="paragraph"/><h3>Panels and layout areas</h3><p class="paragraph"/>First, let's build a custom panel for each layout area (except for 'content' area). For example given the  header area<p class="paragraph"/><img border="0" class="center" src="../img/header-area.png"></img><p class="paragraph"/>we can build a panel called <code>HeaderPanel</code> with a related markup file called HeaderPanel.html containing the HTML for this area:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
&#60;meta http&#45;equiv=<span class="java&#45;quote">"Content&#45;Type"</span> content=<span class="java&#45;quote">"text/html; charset=UTF&#45;8"</span>&#62;
&#8230;
&#60;/head&#62;
&#60;body&#62;
   &#60;wicket:panel&#62;
      &#60;table width=<span class="java&#45;quote">"100%"</span> style=<span class="java&#45;quote">"border: 0px none;"</span>&#62;
      &#60;tbody&#62;
    &#60;tr&#62;
    &#60;td&#62;
       &#60;img alt=<span class="java&#45;quote">"Jug4Tenda"</span> src=<span class="java&#45;quote">"wicketLayout_files/logo_jug4tenda.gif"</span>&#62;
     &#60;/td&#62;
      &#60;td&#62;
    &#60;h1&#62;Gestione Anagrafica&#60;/h1&#62;
   &#60;/td&#62;   
      &#60;/tr&#62;
      &#60;/tbody&#62;
      &#60;/table&#62;   
   &#60;/wicket:panel&#62;
&#60;/body&#62;
&#60;html&#62;</pre></div><p class="paragraph"/>The class for this panel simply extends base class <code>Panel</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> helloWorld.layoutTenda;<p class="paragraph"/><span class="java&#45;keyword">import</span> org.apache.wicket.markup.html.panel.Panel;<p class="paragraph"/><span class="java&#45;keyword">public</span> class HeaderPanel <span class="java&#45;keyword">extends</span> Panel &#123;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> HeaderPanel(<span class="java&#45;object">String</span> id) &#123;
		<span class="java&#45;keyword">super</span>(id);		
	&#125;
&#125;</pre></div><p class="paragraph"/>For each layout area we will build a panel like the one above that holds the appropriate HTML markup. In the end we will have the following set of panels:
<ul class="star">
<li>HeaderPanel</li>
<li>FooterPanel</li>
<li>MenuPanel</li>
</ul><p class="paragraph"/>Content area will change from page to page, so we don't need a reusable panel for it.<p class="paragraph"/><h3>Template page</h3><p class="paragraph"/>Now we can build a generic template page using our brand new panels. Its markup is quite straightforward :<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
&#60;meta http&#45;equiv=<span class="java&#45;quote">"Content&#45;Type"</span> content=<span class="java&#45;quote">"text/html; charset=UTF&#45;8"</span>&#62; 
&#8230;
&#60;!&#45;&#45;Include CSS&#45;&#45;&#62;
&#8230;
&#60;/head&#62;
&#60;body&#62;
&#60;div id=<span class="java&#45;quote">"header"</span> wicket:id=<span class="java&#45;quote">"headerPanel"</span>&#62;header&#60;/div&#62;
&#60;div id=<span class="java&#45;quote">"body"</span>&#62;
	&#60;div id=<span class="java&#45;quote">"menu"</span> wicket:id=<span class="java&#45;quote">"menuPanel"</span>&#62;menu&#60;/div&#62;
	&#60;div id=<span class="java&#45;quote">"content"</span> wicket:id=<span class="java&#45;quote">"contentComponent"</span>&#62;content&#60;/div&#62;
&#60;/div&#62;
&#60;div id=<span class="java&#45;quote">"footer"</span> wicket:id=<span class="java&#45;quote">"footerPanel"</span>&#62;footer&#60;/div&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The HTML code for this page implements the generic left-menu layout of our site. You can note the 4 <code>&#60;div&#62;</code> tags used as containers for the corresponding areas.
The page class contains the code to physically assemble the page and panels:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> helloWorld.layoutTenda;<p class="paragraph"/><span class="java&#45;keyword">import</span> org.apache.wicket.markup.html.WebPage;
<span class="java&#45;keyword">import</span> org.apache.wicket.Component;
<span class="java&#45;keyword">import</span> org.apache.wicket.markup.html.basic.Label;<p class="paragraph"/><span class="java&#45;keyword">public</span> class JugTemplate <span class="java&#45;keyword">extends</span> WebPage &#123;
	<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> <span class="java&#45;keyword">final</span> <span class="java&#45;object">String</span> CONTENT_ID = <span class="java&#45;quote">"contentComponent"</span>;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> Component headerPanel;
	<span class="java&#45;keyword">private</span> Component menuPanel;
	<span class="java&#45;keyword">private</span> Component footerPanel;<p class="paragraph"/>              <span class="java&#45;keyword">public</span> JugTemplate()&#123;
		add(headerPanel = <span class="java&#45;keyword">new</span> HeaderPanel(<span class="java&#45;quote">"headerPanel"</span>));
		add(menuPanel = <span class="java&#45;keyword">new</span> MenuPanel(<span class="java&#45;quote">"menuPanel"</span>));
		add(footerPanel = <span class="java&#45;keyword">new</span> FooterPanel(<span class="java&#45;quote">"footerPanel"</span>));
		add(<span class="java&#45;keyword">new</span> Label(CONTENT_ID, <span class="java&#45;quote">"Put your content here"</span>));
	&#125;<p class="paragraph"/>             //getters <span class="java&#45;keyword">for</span> layout areas
       //&#8230; 
&#125;</pre></div><p class="paragraph"/>Done! Our template page is ready to be used. Now all the pages of our site will be subclasses of this parent page and they will inherit the layout and the HTML markup. They will only substitute the <code>Label</code> inserted as content area with their custom content.<p class="paragraph"/><h3>Final example</h3><p class="paragraph"/>As final example we will build the login page for our site. We will call it <code>SimpleLoginPage</code>. First, we need a panel containing the login form. This will be the content area of our page. We will call it <code>LoginPanel</code> and the markup is the following:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
&#60;/head&#62;
&#60;body&#62;
   &#60;wicket:panel&#62;
    &#60;div style=<span class="java&#45;quote">"margin: auto; width: 40%;"</span>&#62;
       &#60;form  id=<span class="java&#45;quote">"loginForm"</span> method=<span class="java&#45;quote">"get"</span>&#62;
         &#60;fieldset id=<span class="java&#45;quote">"login"</span> class=<span class="java&#45;quote">"center"</span>&#62;
            &#60;legend &#62;Login&#60;/legend&#62;               
            &#60;span &#62;Username: &#60;/span&#62;&#60;input type=<span class="java&#45;quote">"text"</span> id=<span class="java&#45;quote">"username"</span>/&#62;&#60;br/&#62;                                                                  
            &#60;span &#62;Password: &#60;/span&#62;&#60;input type=<span class="java&#45;quote">"password"</span> id=<span class="java&#45;quote">"password"</span> /&#62;
            &#60;p&#62;
               &#60;input type=<span class="java&#45;quote">"submit"</span> name=<span class="java&#45;quote">"login"</span> value=<span class="java&#45;quote">"login"</span>/&#62;
            &#60;/p&#62;
         &#60;/fieldset&#62;
      &#60;/form&#62;
    &#60;/div&#62;   
   &#60;/wicket:panel&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The class for this panel just extends <code>Panel</code> class so we won't see the relative code. The form of this panel is for illustrative purpose only. We will see how to work with Wicket forms in chapters <a href="../guide/single.html#modelsforms" class="guide">11</a> and <a href="../guide/single.html#forms2" class="guide">12</a>. Since this is a login page we don't want it to display the left menu area. That's not a big deal as <code>Component</code> class exposes a method called <code>setVisible</code> which sets whether the component and its children should be displayed.<p class="paragraph"/>The resulting Java code for the login page is the following:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> helloWorld.layoutTenda;
<span class="java&#45;keyword">import</span> helloWorld.LoginPanel;
<span class="java&#45;keyword">import</span> org.apache.wicket.event.Broadcast;
<span class="java&#45;keyword">import</span> org.apache.wicket.event.IEventSink;<p class="paragraph"/><span class="java&#45;keyword">public</span> class SimpleLoginPage <span class="java&#45;keyword">extends</span> JugTemplate &#123;
	<span class="java&#45;keyword">public</span> SimpleLoginPage()&#123;
		<span class="java&#45;keyword">super</span>();		
		replace(<span class="java&#45;keyword">new</span> LoginPanel(CONTENT_ID));
		getMenuPanel().setVisible(<span class="java&#45;keyword">false</span>);
	&#125;
&#125;</pre></div><p class="paragraph"/>Obviously this page doesn't come with a related markup file. You can see the final page in the following picture:<p class="paragraph"/><img border="0" class="center" src="../img/final-login-page.png"></img><p class="paragraph"/>


<h2 id="layout_4">5.4 Markup inheritance with the wicket:extend tag</h2>
With Wicket we can apply markup inheritance using another approach based on the tag <code>&#60;wicket:child&#62;</code>. This tag is used inside the parent's markup to define where the children pages/panels can ‚Äúinject‚Äù their custom markup extending the markup inherited from the parent component. 
An example of a parent page using the tag <code>&#60;wicket:child&#62;</code> is the following:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
	&#60;meta http&#45;equiv=<span class="java&#45;quote">"Content&#45;Type"</span> content=<span class="java&#45;quote">"text/html; charset=UTF&#45;8"</span>&#62; 
&#60;/head&#62;
&#60;body&#62;
	This is parent body!
	&#60;wicket:child/&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The markup of a child page/panel must be placed inside the tag <code>&#60;wicket:extend&#62;</code>. Only the markup inside <code>&#60;wicket:extend&#62;</code> will be included in final markup. Here is an example of child page markup:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
&#60;meta http&#45;equiv=<span class="java&#45;quote">"Content&#45;Type"</span> content=<span class="java&#45;quote">"text/html; charset=UTF&#45;8"</span>&#62; 
&#60;/head&#62;
&#60;body&#62;
    &#60;wicket:extend&#62;
          This is child body!
	&#60;/wicket:extend&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>Considering the two pages seen above, the final markup generated for child page will be the following:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
	&#60;meta http&#45;equiv=<span class="java&#45;quote">"Content&#45;Type"</span> content=<span class="java&#45;quote">"text/html; charset=UTF&#45;8"</span>&#62;
&#60;/head&#62;
&#60;body&#62;
	This is parent body!
	&#60;wicket:child&#62;
       &#60;wicket:extend&#62;
           This is child body!
	   &#60;/wicket:extend&#62;
    &#60;/wicket:child&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><h3>Our example revisited</h3><p class="paragraph"/>Applying <code>&#60;wicket:child&#62;</code> tag to our layout example, we obtain the following markup for the main template page:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
	&#60;meta http&#45;equiv=<span class="java&#45;quote">"Content&#45;Type"</span> content=<span class="java&#45;quote">"text/html; charset=UTF&#45;8"</span>&#62; 
&#60;/head&#62;
&#60;body&#62;
&#60;div id=<span class="java&#45;quote">"header"</span> wicket:id=<span class="java&#45;quote">"headerPanel"</span>&#62;header&#60;/div&#62;
&#60;div id=<span class="java&#45;quote">"body"</span>&#62;
	&#60;div id=<span class="java&#45;quote">"menu"</span> wicket:id=<span class="java&#45;quote">"menuPanel"</span>&#62;menu&#60;/div&#62;
	&#60;wicket:child/&#62;
&#60;/div&#62;
&#60;div id=<span class="java&#45;quote">"footer"</span> wicket:id=<span class="java&#45;quote">"footerPanel"</span>&#62;footer&#60;/div&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>We have replaced the <code>&#60;div&#62;</code> tag of the content area with the tag <code>&#60;wicket:child&#62;</code>. Going forward with our example we can build a login page creating class <code>SimpleLoginPage</code> which extends the <code>JugTemplate</code> page, but with a related markup file like this:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
&#60;/head&#62;
&#60;body&#62;
   &#60;wicket:extend&#62;
    &#60;div style=<span class="java&#45;quote">"margin: auto; width: 40%;"</span>&#62;
       &#60;form  id=<span class="java&#45;quote">"loginForm"</span> method=<span class="java&#45;quote">"get"</span>&#62;
         &#60;fieldset id=<span class="java&#45;quote">"login"</span> class=<span class="java&#45;quote">"center"</span>&#62;
            &#60;legend &#62;Login&#60;/legend&#62;               
            &#60;span &#62;Username: &#60;/span&#62;&#60;input type=<span class="java&#45;quote">"text"</span> id=<span class="java&#45;quote">"username"</span>/&#62;&#60;br/&#62;                                                                  
            &#60;span &#62;Password: &#60;/span&#62;&#60;input type=<span class="java&#45;quote">"password"</span> id=<span class="java&#45;quote">"password"</span> /&#62;
            &#60;p&#62;
               &#60;input type=<span class="java&#45;quote">"submit"</span> name=<span class="java&#45;quote">"login"</span> value=<span class="java&#45;quote">"login"</span>/&#62;
            &#60;/p&#62;
         &#60;/fieldset&#62;
      &#60;/form&#62;
    &#60;/div&#62;   
   &#60;/wicket:extend&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>As we can see this approach doesn't require to create custom panels to use as content area and it can be useful if we don't have to handle a GUI with a high degree of complexity.


<h2 id="layout_5">5.5 Summary</h2>

Wicket applies inheritance also to HTML markup making layout management much easier and less error-prone. Defining a master template page to use as base class for the other pages is a great way to build a consistent layout and use it across all the pages on the web site. During the chapter we have also introduced the <code>Panel</code> component, a very important Wicket class that is primarily designed to let us divide our pages in smaller and reusable UI components.


<h1 id="keepControl">6 Keeping control over HTML</h1>
Many Wicket newbies are initially scared by its approach to web development because they have the impression that the component-oriented nature of the framework prevents them from having direct control over the generated markup. This is due to the fact that many developers come from other server-side technologies like JSP where we physically implement the logic that controls how the final HTML is generated.<p class="paragraph"/>This chapter will prevent you from having any initial misleading feeling about Wicket showing you how to control and manipulate the generated HTML with the built-in tools shipped with the framework.


<h2 id="keepControl_1">6.1 Hiding or disabling a component</h2>
At the end of the previous chapter we have seen how to hide a component calling its method <code>setVisible</code>. In a similar fashion, we can also decide to disable a component using method <code>setEnabled</code>. When a component is disabled all the links inside it will be in turn disabled (they will be rendered as <code>&#60;span&#62;</code>) and it can not fire JavaScript events.<p class="paragraph"/>Class <code>Component</code> provides two getter methods to determinate if a component is visible or enabled: <code>isVisible</code> and <code>isEnabled</code>.<p class="paragraph"/>Even if nothing prevents us from overriding these two methods to implement a custom logic to determinate the state of a component, we should keep in mind that methods <code>isVisible</code> and <code>isEnabled</code> are called multiple times before a component is fully rendered. Hence, if we place non-trivial code inside these two methods, we can sensibly deteriorate the responsiveness of our pages.<p class="paragraph"/>As we will see in the next chapter, class <code>Component</code> provides method <code>onConfigure</code> which is more suited to contain code that contributes to determinate component states because it is called just once during rendering phase.


<h2 id="keepControl_2">6.2 Modifing tag attributes</h2>
To modify tag attributes we can use class <code>org.apache.wicket.AttributeModifier</code>. This class extends <code>org.apache.wicket.behavior.Behavior</code> and can be added to any component via the <code>Component</code>'s <code>add</code> method. Class <code>Behavior</code> is used to expand component functionalities and it can also modify component markup. We will see this class in detail later in <a href="../guide/single.html#advanced_1" class="guide">chapter 19.1</a>.<p class="paragraph"/>As first example of attribute manipulation let's consider a <code>Label</code> component bound to the following markup:<p class="paragraph"/><div class="code"><pre>&#60;span wicket:id=<span class="java&#45;quote">"simpleLabel"</span>&#62;&#60;/span&#62;</pre></div><p class="paragraph"/>Suppose we want to add some style to label content making it red and bolded. We can add to the label an <code>AttributeModifier</code> which creates the tag attribute <code>style</code> with value <code>"color:red;font-weight:bold"</code>:<p class="paragraph"/><div class="code"><pre>label.add(<span class="java&#45;keyword">new</span> AttributeModifier(<span class="java&#45;quote">"style"</span>, <span class="java&#45;quote">"color:red;font&#45;weight:bold"</span>));</pre></div><p class="paragraph"/>If attribute <code>style</code> already exists in the original markup, it will be replaced with the value specified by <code>AttributeModifier</code>. If we don't want to overwrite the existing value of an attribute we can use subclass <code>AttributeAppender</code> which will append its value to the existing one:<p class="paragraph"/><div class="code"><pre>label.add(<span class="java&#45;keyword">new</span> AttributeAppender(<span class="java&#45;quote">"style"</span>, <span class="java&#45;quote">"color:red;font&#45;weight:bold"</span>));</pre></div><p class="paragraph"/>We can also create attribute modifiers using factory methods provided by class <code>AttributeModifier</code> and it's also possible to prepend a given value to an existing attribute:<p class="paragraph"/><div class="code"><pre>//replaces existing value with the given one
label.add(AttributeModifier.replace(<span class="java&#45;quote">"style"</span>, <span class="java&#45;quote">"color:red;font&#45;weight:bold"</span>));<p class="paragraph"/>//appends the given value to the existing one
label.add(AttributeModifier.append(<span class="java&#45;quote">"style"</span>, <span class="java&#45;quote">"color:red;font&#45;weight:bold"</span>));<p class="paragraph"/>//prepends the given value to the existing one
label.add(AttributeModifier.prepend(<span class="java&#45;quote">"style"</span>, <span class="java&#45;quote">"color:red;font&#45;weight:bold"</span>));</pre></div>


<h2 id="keepControl_3">6.3 Generating tag attribute 'id'</h2>
Tag attribute <code>id</code> plays a crucial role in web development as it allows JavaScript to identify a DOM element. That's why class <code>Component</code> provides two dedicated methods to set this attribute. With method <code>setOutputMarkupId(boolean output)</code> we can decide if the <code>id</code> attribute will be rendered or not in the final markup (by default is not rendered). The value of this attribute will be automatically generated by Wicket and it will be unique for the entire page. 
If we need to specify this value by hand, we can use method <code>setMarkupId(String id)</code>. The value of the id can be retrieved with method <code>getMarkupId()</code>.<p class="paragraph"/>Wicket generates markup ids using an instance of interface <code>org.apache.wicket.IMarkupIdGenerator</code>. The default implementation is <code>org.apache.wicket.DefaultMarkupIdGenerator</code> and it uses a session-scoped counter to generate the final id. A different generator can be set with the markup settings class <code>org.apache.wicket.settings.MarkupSettings</code> available in the application class:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	//wrap disabled links with &#60;b&#62; tag
	getMarkupSettings().setMarkupIdGenerator(myGenerator);		
&#125;</pre></div>



<h2 id="keepControl_4">6.4 Creating in-line panels with WebMarkupContainer</h2>
Create custom panels is a great way to handle complex user interfaces. However, sometimes we may need to create a panel which is used only by a specific page and only for a specific task.<p class="paragraph"/>In situations like these component <code>org.apache.wicket.markup.html.WebMarkupContainer</code> is better suited than custom panels because it can be directly attached to a tag in the parent markup without needing a corresponding html file (hence it is less reusable). Let's consider for example the main page of a mail service where users can see a list of received mails. Suppose that this page shows a notification box where user can see if new messages have arrived. This box must be hidden if there are no messages to display and it would be nice if we could handle it as if it was a Wicket component.<p class="paragraph"/>Suppose also that this information box is a <code>&#60;div&#62;</code> tag like this inside the page:<p class="paragraph"/><div class="code"><pre>&#60;div wicket:id=<span class="java&#45;quote">"informationBox"</span>&#62;
   //here's the body
   You've got &#60;span wicket:id=<span class="java&#45;quote">"messagesNumber"</span>&#62;&#60;/span&#62; <span class="java&#45;keyword">new</span> messages.
&#60;/div&#62;</pre></div><p class="paragraph"/>Under those conditions we can consider using a <code>WebMarkupContainer</code> component rather than implementing a new panel. The code needed to handle the information box inside the page could be the following:<p class="paragraph"/><div class="code"><pre>//Page initialization code
WebMarkupContainer informationBox = <span class="java&#45;keyword">new</span> WebMarkupContainer (<span class="java&#45;quote">"informationBox"</span>);
informationBox.add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"messagesNumber"</span>, messagesNumber));
add(informationBox);<p class="paragraph"/>//If there are no <span class="java&#45;keyword">new</span> messages, hide informationBox
informationBox.setVisible(<span class="java&#45;keyword">false</span>);</pre></div><p class="paragraph"/>As you can see in the snippet above we can handle our information box from Java code as we do with any other Wicket component.


<h2 id="keepControl_5">6.5 Working with markup fragments</h2>
Another circumstance in which we may prefer to avoid the creation of custom panels is when we want to conditionally display in a page small fragments of markup. In this case if we decided to use panels, we would end up having a huge number of small panel classes with their related markup file.<p class="paragraph"/>To better cope with situations like this, Wicket defines component <code>Fragment</code> in package <code>org.apache.wicket.markup.html.panel</code>. Just like its parent component <code>WebMarkupContainer</code>, Fragment doesn't have its own markup file but it uses a markup fragment defined in the markup file of its parent container, which can be a page or a panel. The fragment must be delimited with tag <code>&#60;wicket:fragment&#62;</code> and must be identified by a <code>wicket:id</code> attribute. In addition to the component id, <code>Fragment</code>'s constructor takes as input also the id of the fragment and a reference to its container.<p class="paragraph"/>In the following  example we have defined a fragment in a page and we used it as content area:<p class="paragraph"/><strong class="bold">Page markup:</strong><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
  &#8230;
&#60;body&#62;
&#8230;
	&#60;div wicket:id=<span class="java&#45;quote">"contentArea"</span>&#62;&#60;/div&#62;
	&#60;wicket:fragment wicket:id=<span class="java&#45;quote">"fragmentId"</span>&#62;
	   &#60;!&#45;&#45; Fragment markup goes here &#45;&#45;&#62;
	&#60;/wicket:fragment&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre>Fragment fragment = <span class="java&#45;keyword">new</span>  Fragment (<span class="java&#45;quote">"contentArea"</span>, <span class="java&#45;quote">"fragmentId"</span>, <span class="java&#45;keyword">this</span>);
add(fragment);</pre></div><p class="paragraph"/>Fragments can be very helpful with complex pages or components. For example let's say that we  have a page where users can register to our forum. This page should first display a form where user must insert his/her personal data (name, username, password, email and so on), then, once the user has submitted the form, the page should display a message like ‚ÄúYour registration is complete! Please check your mail to activate your user profile.‚Äù.<p class="paragraph"/>Instead of displaying this message with a new component or in a new page, we can define two fragments: one for the initial form and one to display the confirmation message. The second fragment will replace the first one after the form has been submitted:<p class="paragraph"/><strong class="bold">Page markup:</strong><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;body&#62;
	&#60;div wicket:id=<span class="java&#45;quote">"contentArea"</span>&#62;&#60;/div&#62;
	&#60;wicket:fragment wicket:id=<span class="java&#45;quote">"formFrag"</span>&#62;
	   &#60;!&#45;&#45; Form markup goes here &#45;&#45;&#62;
	&#60;/wicket:fragment&#62;
	&#60;wicket:fragment wicket:id=<span class="java&#45;quote">"messageFrag"</span>&#62;
	   &#60;!&#45;&#45; Message markup goes here &#45;&#45;&#62;
	&#60;/wicket:fragment&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre>Fragment fragment = <span class="java&#45;keyword">new</span>  Fragment (<span class="java&#45;quote">"contentArea"</span>, <span class="java&#45;quote">"formFrag"</span>, <span class="java&#45;keyword">this</span>);
add(fragment);<p class="paragraph"/>//form has been submitted
Fragment fragment = <span class="java&#45;keyword">new</span>  Fragment (<span class="java&#45;quote">"contentArea"</span>, <span class="java&#45;quote">"messageFrag"</span>, <span class="java&#45;keyword">this</span>);
replace(fragment);</pre></div>


<h2 id="keepControl_6">6.6 Adding header contents to the final page</h2>
Panel's markup can also contain HTML tags which must go inside header section of the final page, like tags <code>&#60;script&#62;</code> or <code>&#60;style&#62;</code>. To tell Wicket to put these tags inside page <code>&#60;head&#62;</code>, we must surround them with the <code>&#60;wicket:head&#62;</code> tag.<p class="paragraph"/>Considering the markup of a generic panel, we can use <code>&#60;wicket:head&#62;</code> tag in this way:<p class="paragraph"/><div class="code"><pre>&#60;wicket:head&#62;
	&#60;script type=<span class="java&#45;quote">"text/javascript"</span>&#62;
	  	function myPanelFunction()&#123;
	  	&#125;
	  &#60;/script&#62;<p class="paragraph"/>	&#60;style&#62;
        .myPanelClass&#123;
	  	font&#45;weight: bold;
	  	color: red;
	  &#125;	 
       &#60;/style&#62;
&#60;/wicket:head&#62;
&#60;body&#62;
	&#60;wicket:panel&#62;<p class="paragraph"/>	&#60;/wicket:panel&#62;
&#60;/body&#62;</pre></div><p class="paragraph"/>Wicket will take care of placing the content of <code>&#60;wicket:head&#62;</code> inside the <code>&#60;head&#62;</code> tag of the final page.<p class="paragraph"/><blockquote class="note">
The <code>&#60;wicket:head&#62;</code> tag can also be used with children pages/panels which extend parent markup using tag <code>&#60;wicket:extend&#62;</code>.
</blockquote><p class="paragraph"/><blockquote class="note">
The content of the <code>&#60;wicket:head&#62;</code> tag is added to the header section once per component class. In other words, if we add multiple instances of the same panel to a page, the <code>&#60;head&#62;</code> tag will be populated just once with the content of <code>&#60;wicket:head&#62;</code>.
</blockquote><p class="paragraph"/><blockquote class="warning">
The <code>&#60;wicket:head&#62;</code> tag is ideal if we want to define small in-line blocks of CSS or JavaScript. However Wicket provides also a more sophisticated technique to let components contribute to header section with in-line blocks and resource files like CSS or JavaScript files. We will see this technique later in <a href="../guide/single.html#resources" class="guide">chapter 16</a>.
</blockquote>



<h2 id="keepControl_7">6.7 Using stub markup in our pages/panels</h2>
Wicket's <code>&#60;wicket:remove&#62;</code> tag can be very useful when our web designer needs to show us how a page or a panel should look like. The markup inside this tag will be stripped out in the final page, so it's the ideal place for web designers to put their stub markup:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;<p class="paragraph"/>&#60;/head&#62;
&#60;body&#62;
	&#60;wicket:remove&#62;
	   &#60;!&#45;&#45; Stub markup goes here &#45;&#45;&#62;
	&#60;/wicket:remove&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div>


<h2 id="keepControl_8">6.8 How to render component body only</h2>
When we bind a component to its corresponding tag we can choose to get rid of this outer tag in the final markup. If we call method <code>setRenderBodyOnly(true)</code> on a component Wicket will remove the surrounding tag.<p class="paragraph"/>For example given the following markup and code:<p class="paragraph"/><strong class="bold">HTML markup:</strong><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
  &#60;title&#62;Hello world page&#60;/title&#62;
&#60;/head&#62;
&#60;body&#62;
&#60;div wicket:id=<span class="java&#45;quote">"helloWorld"</span>&#62;&#91;helloWorld&#93;&#60;/div&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"helloWorld"</span>, ‚ÄúHello World!‚Äù);
label.setRenderBodyOnly(<span class="java&#45;keyword">true</span>);
add(label);</pre></div><p class="paragraph"/>the output will be:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
  &#60;title&#62;Hello world page&#60;/title&#62;
&#60;/head&#62;
&#60;body&#62;
 Hello World!
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>As you can see the <code>&#60;div&#62;</code> tag used for component <code>Label</code> is not present in the final markup.


<h2 id="keepControl_9">6.9 Hiding decorating elements with the wicket:enclosure tag</h2>
Our data are rarely displayed alone without a caption or other graphic elements that make clear the meaning of their value. For example:<p class="paragraph"/><div class="code"><pre>&#60;label&#62;Total amount: &#60;/label&#62;&#60;span wicket:id=<span class="java&#45;quote">"totalAmount"</span>&#62;&#60;/span&#62;</pre></div><p class="paragraph"/>Wicket comes with a nice utility tag called <code>&#60;wicket:enclosure&#62;</code> that automatically hides those decorating elements if the related data value is not visible. All we have to do is to put the involved markup inside this tag. Applying <code>&#60;wicket:enclosure&#62;</code> to the previous example we get the following markup:<p class="paragraph"/><div class="code"><pre>&#60;wicket:enclosure&#62; 
    &#60;label&#62;Total amount: &#60;/label&#62;&#60;span wicket:id=<span class="java&#45;quote">"totalAmount"</span>&#62;&#60;/span&#62;
&#60;/wicket:enclosure&#62;</pre></div><p class="paragraph"/>Now if component <code>totalAmount</code> is not visible, its description (<code>Total amount:</code>) will be automatically hidden. If we have more than a Wicket component inside <code>&#60;wicket:enclosure&#62;</code> we can use <code>child</code> attribute to specify which component will control the overall visibility:<p class="paragraph"/><div class="code"><pre>&#60;wicket:enclosure child=<span class="java&#45;quote">"totalAmount"</span>&#62; 
    &#60;label&#62;Total amount: &#60;/label&#62;&#60;span wicket:id=<span class="java&#45;quote">"totalAmount"</span>&#62;&#60;/span&#62;&#60;br/&#62;
	&#60;label&#62;Expected delivery date: &#60;/label&#62;&#60;span wicket:id=<span class="java&#45;quote">"delivDate"</span>&#62;&#60;/span&#62;
&#60;/wicket:enclosure&#62;</pre></div><p class="paragraph"/><code>child</code> attribute supports also nested components with a colon-separated path:<p class="paragraph"/><div class="code"><pre>&#60;wicket:enclosure child=<span class="java&#45;quote">"totalAmountContainer:totalAmount"</span>&#62; 
    &#60;div wicket:id=<span class="java&#45;quote">"totalAmountContainer"</span>&#62;
		&#60;label&#62;Total amount: &#60;/label&#62;&#60;span wicket:id=<span class="java&#45;quote">"totalAmount"</span>&#62;&#60;/span&#62;
    &#60;/div&#62;
    &#60;label&#62;Expected delivery date: &#60;/label&#62;&#60;span wicket:id=<span class="java&#45;quote">"delivDate"</span>&#62;&#60;/span&#62;
&#60;/wicket:enclosure&#62;</pre></div>


<h2 id="keepControl_10">6.10 Surrounding existing markup with Border</h2>
Component <code>org.apache.wicket.markup.html.border.Border</code> is a special purpose container created to enclose its tag body with its related markup. Just like panels and pages, borders also have their own markup file which is defined following the same rules seen for panels and pages. In this file <code>&#60;wicket:border&#62;</code> tag is used to indicate which part of the content is to be considered as border markup:<p class="paragraph"/><div class="code"><pre>&#60;?xml version=<span class="java&#45;quote">"1.0"</span> encoding=<span class="java&#45;quote">"UTF&#45;8"</span>?&#62;
&#60;html xmlns=<span class="java&#45;quote">"http://www.w3.org/1999/xhtml"</span> xmlns:wicket=<span class="java&#45;quote">"http://wicket.apache.org"</span>&#62;
&#60;head&#62;&#60;/head&#62;
&#60;body&#62;
    &#60;!&#45;&#45;  everything above &#60;wicket:border&#62; tag will be discarded...&#45;&#45;&#62;
    &#60;wicket:border&#62;
	 &#60;div&#62;
	    foo&#60;br /&#62;
    &#60;wicket:body/&#62;&#60;br /&#62;
           buz &#60;br /&#62;<p class="paragraph"/>  &#60;/div&#62;
    &#60;/wicket:border&#62;
    &#60;!&#45;&#45;  everything below &#60;/wicket:border&#62; tag will be discarded...&#45;&#45;&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The <code>&#60;wicket:body/&#62;</code> tag used in the example above is used to indicate where the body of the tag will be placed inside border markup. Now if we attached this border to the following tag<p class="paragraph"/><div class="code"><pre>&#60;span wicket:id=<span class="java&#45;quote">"myBorder"</span>&#62;
  bar
&#60;/span&#62;</pre></div><p class="paragraph"/>we would obtain the following resulting HTML:<p class="paragraph"/><div class="code"><pre>&#60;span wicket:id=<span class="java&#45;quote">"myBorder"</span>&#62;
	&#60;div&#62;
  		foo&#60;br /&#62;
  		bar&#60;br /&#62;
  		buz &#60;br /&#62;
	&#60;/div&#62;
&#60;/span&#62;</pre></div><p class="paragraph"/><code>Border</code> can also contain children components which can be placed either inside its markup file or inside its corresponding HTML tag. In the first case children must be added to the border component with method <code>addToBorder(Component...)</code>, while in the second case we must use the <code>add(Component...)</code> method.<p class="paragraph"/>The following example illustrates both use cases:<p class="paragraph"/>Border class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class MyBorder <span class="java&#45;keyword">extends</span> Border &#123;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> MyBorder(<span class="java&#45;object">String</span> id) &#123;
		<span class="java&#45;keyword">super</span>(id);		
	&#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Border Markup:<p class="paragraph"/><div class="code"><pre>&#60;?xml version=<span class="java&#45;quote">"1.0"</span> encoding=<span class="java&#45;quote">"UTF&#45;8"</span>?&#62;
&#60;html xmlns=<span class="java&#45;quote">"http://www.w3.org/1999/xhtml"</span> xmlns:wicket=<span class="java&#45;quote">"http://wicket.apache.org"</span>&#62;
&#60;head&#62;&#60;/head&#62;
&#60;body&#62;
    &#60;wicket:border&#62;
	 &#60;div&#62;
	    &#60;div wicket:id=<span class="java&#45;quote">"childMarkup"</span>&#62;&#60;/div&#62;
    &#60;wicket:body/&#62;&#60;br /&#62;
         &#60;/div&#62;
    &#60;/wicket:border&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>Border tag:<p class="paragraph"/><div class="code"><pre>&#60;div wicket:id=<span class="java&#45;quote">"myBorder"</span>&#62;
  &#60;span wicket:id=<span class="java&#45;quote">"childTag"</span>&#62;&#60;/span&#62;
&#60;/div&#62;</pre></div><p class="paragraph"/>Initialization code for border:<p class="paragraph"/><div class="code"><pre>MyBorder myBorder = <span class="java&#45;keyword">new</span> MyBorder(<span class="java&#45;quote">"myBorder"</span>);<p class="paragraph"/>myBorder.addToBorder(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"childMarkup"</span>, <span class="java&#45;quote">"Child inside markup."</span>));
myBorder.add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"childTag"</span>, <span class="java&#45;quote">"Child inside tag."</span>));<p class="paragraph"/>add(myBorder);</pre></div>


<h2 id="keepControl_11">6.11 Summary</h2>
<p class="paragraph"/>In this chapter we have seen the tools provided by Wicket to gain complete control over the generated HTML. However we didn't see yet how we can repeat a portion of HTML with Wicket. With classic server-side technologies like PHP or JSP we use loops (like <code>while</code> or <code>for</code>) inside our pages to achieve this result. 
To perform this task Wicket provides a special-purpose family of components called repeaters and designed to repeat their markup body to display a set of items.<p class="paragraph"/>But to fully understand how these components work, we must first learn more of Wicket's basics. That's why repeaters will be introduced later in <a href="../guide/single.html#repeaters" class="guide">chapter 13</a>.


<h1 id="componentLifecycle">7 Components lifecycle</h1>
Just like applets and servlets, also Wicket components follow a lifecycle during their existence. In this chapter we will analyze each stage of this cycle and we will learn how to make the most of the hook methods that are triggered when a component moves from one stage to another.


<h2 id="componentLifecycle_1">7.1 Lifecycle stages of a component</h2>
<p class="paragraph"/>During its life a Wicket component goes through three basic stages:
<ol>
<li><strong class="bold">Initialization:</strong> a component is instantiated by Wicket and prepared for the rendering phase.</li>
<li><strong class="bold">Rendering:</strong> in this stage Wicket generates component markup. If a component contains children (i.e. is a subclass of <code>MarkupContainer</code>) it must first wait for them to be rendered before starting its own rendering.</li>
<li><strong class="bold">Removing:</strong> this stage is triggered when a component is explicitly removed from its component hierarchy, i.e. when its parent invokes <code>remove(component)</code> on it. This stage is facultative and is never triggered for pages.</li>
</ol><p class="paragraph"/>The following picture shows the state diagram of component lifecycle:<p class="paragraph"/><img border="0" class="center" src="../img/component-lifecycle.png"></img><p class="paragraph"/>Once a component has been removed it can be added again to a container, but the initialization stage won't be executed again.<p class="paragraph"/><blockquote class="note">
If you read the JavaDoc of class <code>Component</code> you will find a more detailed description of component lifecycle.
However this description introduces some advanced topics we didn't covered yet hence, to avoid confusion, in this chapter some details have been omitted and they will be covered later in the next chapters.<p class="paragraph"/>For now you can consider just the simplified version of the lifecycle described above.
</blockquote>


<h2 id="componentLifecycle_2">7.2 Hook methods for component lifecycle</h2>
<p class="paragraph"/>Class <code>Component</code> comes with a number of hook methods that can be overridden in order to customize component behavior during its lifecycle.
In the following table these methods are grouped according to the stage in which they are invoked (and they are sorted by execution order):<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Cycle stage</strong></th><th><strong class="bold">Involved methods</strong></th></tr><tr class="table-odd"><td>Initialization</td><td>onInitialize</td></tr><tr class="table-even"><td>Rendering</td><td>onConfigure, onBeforeRender, onRender, onComponentTag, onComponentTagBody, onAfterRenderChildren, onAfterRender</td></tr><tr class="table-odd"><td>Removing</td><td>onRemove</td></tr></table><p class="paragraph"/>Now let's take a closer look at each stage and to at hook methods.


<h2 id="componentLifecycle_3">7.3 Initialization stage</h2>
<p class="paragraph"/>This stage is performed at the beginning of the component lifecycle. During initialization, the component has already been inserted into its component hierarchy so we can safely access to its parent container or to its page with methods <code>getParent()</code> or <code>getPage()</code>. The only method triggered during this stage is <code>onInitialize()</code>. This method is a sort of ‚Äúspecial‚Äù constructor where we can execute a custom initialization of our component.<p class="paragraph"/>Since <code>onInitialize</code> is similar to a regular constructor, when we override this method we have to call <code>super.onInitialize</code> inside its body, usually as first instruction.


<h2 id="componentLifecycle_4">7.4 Rendering stage</h2>
This stage is triggered each time a component is rendered by Wicket, typically when its page is requested or when it is refreshed via AJAX.<p class="paragraph"/><h3>Method onConfigure</h3><p class="paragraph"/>Method <code>onConfigure()</code> has been introduced in order to provide a good point to manage the component states such as its visibility or enabled state. This method is called before the render phase starts. As stated in <a href="../guide/single.html#keepControl_1" class="guide">chapter 6.1</a>, <code>isVisible</code> and <code>isEnabled</code> are called multiple times when a page or a component is rendered, so it's highly recommended not to directly override these method, but rather to use <code>onConfigure</code> to change component states. On the contrary method <code>onBeforeRender</code> (see the next paragraph) is not indicated for this task because it will not be invoked if component visibility is set to false.<p class="paragraph"/><h3>Method onBeforeRender</h3><p class="paragraph"/>The most important hook method of this stage is probably <code>onBeforeRender()</code>. This method is called before a component starts its rendering phase and it is our last chance to change its children hierarchy.<p class="paragraph"/>If we want add/remove children components this is the right place to do it. In the next example (project LifeCycleStages) we will create a page which alternately displays two different labels, swapping between them each time it is rendered:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage
&#123;
	<span class="java&#45;keyword">private</span> Label firstLabel;
	<span class="java&#45;keyword">private</span> Label secondLabel;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> HomePage()&#123;
		firstLabel = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"label"</span>, <span class="java&#45;quote">"First label"</span>);
		secondLabel = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"label"</span>, <span class="java&#45;quote">"Second label"</span>);<p class="paragraph"/>		add(firstLabel);
		add(<span class="java&#45;keyword">new</span> Link(<span class="java&#45;quote">"reload"</span>)&#123;
			@Override
			<span class="java&#45;keyword">public</span> void onClick() &#123;
			&#125;
		&#125;);
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> void onBeforeRender() &#123;
		<span class="java&#45;keyword">if</span>(contains(firstLabel, <span class="java&#45;keyword">true</span>))
			replace(secondLabel);
		<span class="java&#45;keyword">else</span>
			replace(firstLabel);<p class="paragraph"/>		<span class="java&#45;keyword">super</span>.onBeforeRender();
	&#125;
&#125;</pre></div><p class="paragraph"/>The code inside <code>onBeforeRender()</code> is quite trivial as it just checks which label among <code>firstLabel</code> and <code>secondLabel</code> is currently inserted into the component hierarchy and it replaces the inserted label with the other one.<p class="paragraph"/>This method is also responsible for invoking children <code>onBeforeRender()</code> so if we decide to override it we have to call <code>super.onBeforeRender()</code>. However, unlike <code>onInitialize()</code>, the call to superclass method should be placed at the end of method's body in order to affect children's rendering with our custom code.<p class="paragraph"/>Please note that in the example above we can trigger the rendering stage pressing F5 key or clicking on link ‚Äúreload‚Äù.<p class="paragraph"/><blockquote class="warning">
If we forget to call superclass version of methods <code>onInitialize()</code> or <code>onBeforeRender()</code>, Wicket will throw an <code>IllegalStateException</code> with the following message:<p class="paragraph"/><code>java.lang.IllegalStateException: </code>org.apache.wicket.Component<code> has not been properly initialized. Something in the hierarchy of &#60;page class name&#62; has not called super.onInitialize()/onBeforeRender() in the override of onInitialize()/ onBeforeRender() method</code><p class="paragraph"/></blockquote><p class="paragraph"/><h3>Method onComponentTag</h3><p class="paragraph"/>Method <code>onComponentTag(ComponentTag)</code> is called to process component tag, which can be freely manipulated through its argument of type <code>org.apache.wicket.markup.ComponentTag</code>. For example we can add/remove tag attributes with methods <code>put(String key, String value)</code> and <code>remove(String key)</code>, or we can even decide to change the tag or rename it with method <code>setName(String)</code> (the following code is taken from project OnComponentTagExample):<p class="paragraph"/><strong class="bold">Markup code:</strong><p class="paragraph"/><div class="code"><pre>&#60;head&#62;
  &#60;meta charset=<span class="java&#45;quote">"utf&#45;8"</span> /&#62;
  &#60;title&#62;&#60;/title&#62;
&#60;/head&#62;
&#60;body&#62;		
  &#60;h1 wicket:id=<span class="java&#45;quote">"helloMessage"</span>&#62;&#60;/h1&#62;		
&#60;/body&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
   <span class="java&#45;keyword">public</span> HomePage() &#123;
      add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"helloMessage"</span>, <span class="java&#45;quote">"Hello World"</span>)&#123;
         @Override
         <span class="java&#45;keyword">protected</span> void onComponentTag(ComponentTag tag) &#123;            
            <span class="java&#45;keyword">super</span>.onComponentTag(tag);
            //Turn the h1 tag to a span
            tag.setName(<span class="java&#45;quote">"span"</span>);
            //Add formatting style
            tag.put(<span class="java&#45;quote">"style"</span>, <span class="java&#45;quote">"font&#45;weight:bold"</span>);
         &#125;
      &#125;);
    &#125;
&#125;</pre></div><p class="paragraph"/><strong class="bold">Generated markup:</strong><p class="paragraph"/><div class="code"><pre>&#60;head&#62;
  &#60;meta charset=<span class="java&#45;quote">"utf&#45;8"</span> /&#62;
  &#60;title&#62;&#60;/title&#62;
&#60;/head&#62;
&#60;body&#62;		
  &#60;span wicket:id=<span class="java&#45;quote">"helloMessage"</span> style=<span class="java&#45;quote">"font&#45;weight:bold"</span>&#62;Hello World&#60;/span&#62;		
&#60;/body&#62;</pre></div><p class="paragraph"/>Just like we do with <code>onInitialize</code>, if we decide to override <code>onComponentTag</code> we must remember to call the same method of the super class because also this class may also customize the tag. Overriding <code>onComponentTag</code> is perfectly fine if we have to customize the tag of a specific component, but if we wanted to reuse the code across different components we should consider to use a behavior in place of this hook method.<p class="paragraph"/>We have already seen in <a href="../guide/single.html#keepControl_2" class="guide">chapter 6.2</a> how to use behavior <code>AttributeModifier</code> to manipulate the tag's attribute. In <a href="../guide/single.html#advanced_1" class="guide">chapter 19.1</a> we will see that base class <code>Behavior</code> offers also a callback method named <code>onComponentTag(ComponentTag, Component)</code> that can be used in place of the hook method <code>onComponentTag(ComponentTag)</code>.<p class="paragraph"/><h3>Methods onComponentTagBody</h3><p class="paragraph"/>Method <code>onComponentTagBody(MarkupStream, ComponentTag)</code> is called to process the component tag's body. Just like <code>onComponentTag</code> it takes as input a <code>ComponentTag</code> parameter representing the component tag. In addition, we also find a <code>MarkupStream</code> parameter which represents the page markup stream that will be sent back to the client as response.<p class="paragraph"/><code>onComponentTagBody</code> can be used in combination with the <code>Component</code>'s method <code>replaceComponentTagBody</code> to render a custom body under specific conditions. For example (taken from project OnComponentTagExample) we can display a brief description instead of the body if the label component is disabled:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
   <span class="java&#45;keyword">public</span> HomePage() &#123;<p class="paragraph"/>      add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"helloMessage"</span>, <span class="java&#45;quote">"Hello World"</span>)&#123;
         @Override
         <span class="java&#45;keyword">protected</span> void onComponentTagBody(MarkupStream markupStream, ComponentTag tag) &#123;<p class="paragraph"/>           <span class="java&#45;keyword">if</span>(!isEnabled())
               replaceComponentTagBody(markupStream, tag, <span class="java&#45;quote">"(the component is disabled)"</span>); 
          <span class="java&#45;keyword">else</span>    
               <span class="java&#45;keyword">super</span>.onComponentTagBody(markupStream, tag);
         &#125;
      &#125;);   
    &#125;
&#125;</pre></div><p class="paragraph"/>Note that the original version of <code>onComponentTagBody</code> is invoked only when we want to preserve the standard rendering mechanism for the tag's body (in our example this happens when the component is enabled).


<h2 id="componentLifecycle_5">7.5 Removing stage</h2>
<p class="paragraph"/>This stage is triggered when a component is removed from its container hierarchy. The only hook method for this phase is <code>onRemove()</code>. If our component still holds some resources needed during rendering phase, we can override this method to release them.<p class="paragraph"/>Once a component has been removed we are free to add it again to the same container or to a different one. Starting from version 6.18.0 Wicket added a further hook method called <code>onReAdd()</code> which is triggered every time a previously removed component is re-added to a cointainer.
Please note that while <code>onInitialize</code> is called only the very first time a component is added, <code>onReAdd</code> is called every time it is re-added after having been removed.



<h2 id="componentLifecycle_6">7.6 Summary</h2>
<p class="paragraph"/>In this chapter we have seen which stages compose the lifecycle of Wicket components and which hook methods they provide. Overriding these methods we can dynamically modify the component hierarchy and we can enrich the behavior of our custom components.



<h1 id="versioningCaching">8 Page versioning and caching</h1>
This chapter explains how Wicket manages page instances, underlining the difference between stateful and stateless pages. The chapter also introduces some advanced topics like Java Serialization and multi-level cache. However, to understand what you will read you are not required to be familiar with these concepts.


<h2 id="versioningCaching_1">8.1 Stateful pages vs stateless</h2>
<p class="paragraph"/>Wicket pages can be divided into two categories: stateful and stateless pages. Stateful pages are those which rely on user session to store their internal state and to keep track of user interaction.
On the contrary stateless pages are those which don't change their internal state during their lifecycle and they don't need to occupy space into user session.<p class="paragraph"/>From Wicket's point of view the biggest difference between these two types of page is that stateful pages are versioned, meaning that they will be saved into user session every time their internal state has changed. Wicket automatically assigns a session to the user the first time a stateful page is requested. Page versions are stored into user session using Java Serialization mechanism. 
Stateless pages are never versioned and that's why they don't require a valid user session. If we want to know whether a page is stateless or not, we can call the isPageStateless() method of class Page.<p class="paragraph"/>In order to build a stateless page we must comply with some rules to ensure that the page won't need to use user session. These rules are illustrated in paragraph 8.3 but before talking about stateless pages we must first understand how stateful pages are handled and why they are versioned.


<h2 id="versioningCaching_2">8.2 Stateful pages</h2>
<p class="paragraph"/>Stateful pages are versioned in order to support browser's back button: when this button is pressed Wicket must respond by rendering the same page instance previously used.<p class="paragraph"/>A new page version is created when a stateful page is requested for the first time or when an existing instance is modified (for example changing its component hierarchy). To identify each page version Wicket uses a session-relative identifier called page id. This is a unique number and it is increased every time a new page version is created.<p class="paragraph"/>In the final example of the previous chapter (project LifeCycleStages), you may have noticed the number appended at the end of URL. This number is the page id we are talking about:<p class="paragraph"/><img border="0" class="center" src="../img/page-id.png"></img><p class="paragraph"/>In this chapter we will use a revised version of this example project where the component hierarchy is modified inside the Link's onClick()method. This is necessary because Wicket creates a new page version only if the page is modified before its method onBeforeRender() is invoked. The code of the new home page is the following:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage
&#123;
	<span class="java&#45;keyword">private</span> <span class="java&#45;keyword">static</span> <span class="java&#45;keyword">final</span> <span class="java&#45;object">long</span> serialVersionUID = 1L;
	<span class="java&#45;keyword">private</span> Label firstLabel;
	<span class="java&#45;keyword">private</span> Label secondLabel;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> HomePage()&#123;
		firstLabel = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"label"</span>, <span class="java&#45;quote">"First label"</span>);
		secondLabel = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"label"</span>, <span class="java&#45;quote">"Second label"</span>);<p class="paragraph"/>		add(firstLabel);<p class="paragraph"/>		add(<span class="java&#45;keyword">new</span> Link(<span class="java&#45;quote">"reload"</span>)&#123;
			@Override
			<span class="java&#45;keyword">public</span> void onClick() &#123;				
				<span class="java&#45;keyword">if</span>(getPage().contains(firstLabel, <span class="java&#45;keyword">true</span>))
					getPage().replace(secondLabel);
				<span class="java&#45;keyword">else</span>
					getPage().replace(firstLabel);		
			&#125;
		&#125;);<p class="paragraph"/>	&#125;	
&#125;</pre></div><p class="paragraph"/>Now if we run the new example (project LifeCycleStagesRevisited) and we click on the ‚ÄúReload‚Äù button, a new page version is created and the page id is increased by one:<p class="paragraph"/><img border="0" class="center" src="../img/reload-page.png"></img><p class="paragraph"/>If we press the back button the page version previously rendered (and serialized) will be retrieved (i.e. deserialized) and it will be used again to respond to our request (and page id is decremented):<p class="paragraph"/><img border="0" class="center" src="../img/browser-back.png"></img><p class="paragraph"/><blockquote class="note">
For more details about page storing you can take a look at paragraph "Page storing" from chapter "Wicket Internals". The content of this paragraph is from wiki page https://cwiki.apache.org/confluence/display/WICKET/Page+Storage. 
</blockquote><p class="paragraph"/>As we have stated at the beginning of this chapter, page versions are stored using Java serialization, therefore every object referenced inside a page must be serializable. In <a href="../guide/single.html#modelsforms_6" class="guide">paragraph 11.6</a> we will see how to overcome this limit and work with non-serializable objects in our components using detachable Wicket models.<p class="paragraph"/><h3>Using a specific page version with PageReference</h3><p class="paragraph"/>To retrieve a specific page version in our code we can use class <code>org.apache.wicket.PageReference</code> by providing its constructor with the corresponding page id:<p class="paragraph"/><div class="code"><pre>//load page version with page id = 3
PageReference pageReference = <span class="java&#45;keyword">new</span> PageReference(3);
//load the related page instance
Page page = pageReference.getPage();</pre></div><p class="paragraph"/>To get the related page instance we must use the method getPage.<p class="paragraph"/><h3>Turning off page versioning</h3><p class="paragraph"/>If for any reason we need to switch off versioning for a given page, we can call its method setVersioned(false).<p class="paragraph"/><h3>Pluggable serialization</h3><p class="paragraph"/>Starting from version 1.5 it is possible to choose which implementation of Java serialization will be used by Wicket to store page versions. Wicket serializes pages using an implementation of interface <code>org.apache.wicket.serialize.ISerializer</code>. The default implementation is <code>org.apache.wicket.serialize.java.JavaSerializer</code> and it uses the standard Java serialization mechanism based on classes ObjectOutputStream and ObjectInputStream. However on Internet we can find other interesting serialization libraries like <a href="https://github.com/EsotericSoftware/kryo" target="blank">Kryo</a> or <a href="http://ruedigermoeller.github.io/fast-serialization/" target="blank">Fast</a> which perform faster then the standard implementation. The serializer in use can be customized with the setSerializer(ISerializer) method defined by setting class <code>org.apache.wicket.settings.FrameworkSettings</code>.<p class="paragraph"/>We can access this class inside the method <code>init</code> of the class Application using the getFrameworkSettings() method :<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getFrameworkSettings().setSerializer(yourSerializer);
&#125;</pre></div><p class="paragraph"/>A serializer based on Kryo library and another one based on Fast are provided by the WicketStuff project. You can find more information on this project, as well as the instructions to use its modules, in Appendix B.<p class="paragraph"/><h3>Page caching</h3><p class="paragraph"/>By default Wicket persists versions of pages into a session-relative file on disk, but it uses a two-levels cache to speed up this process. The first level of the cache uses a http session attribute called ‚Äúwicket:persistentPageManagerData-&#60;APPLICATION_NAME&#62;‚Äù to store pages. The second level cache stores pages into application-scoped variables which are identified by a session id and a page id.<p class="paragraph"/>The following picture is an overview of these two caching levels:<p class="paragraph"/><img border="0" class="center" src="../img/wicket-cache.png"></img><p class="paragraph"/>The session-scoped cache is faster then the other memory levels but it contains only the pages used to serve the last request. Wicket allows us to set the maximum amount of memory allowed for the application-scoped cache and for the page store file. Both parameters can be configured via setting class <code>org.apache.wicket.settings.StoreSettings</code>.<p class="paragraph"/>This interface provides the setMaxSizePerSession(Bytes bytes) method to set the size for page store file. The Bytes parameter is the maximum size allowed for this file:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getStoreSettings().setMaxSizePerSession(Bytes.kilobytes(500));
&#125;</pre></div><p class="paragraph"/>Class <code>org.apache.wicket.util.lang.Bytes</code> is an utility class provided by Wicket to express size in bytes (for further details refer to the JavaDoc).
For the second level cache we can use the setInmemoryCacheSize(int inmemoryCacheSize) method. The integer parameter is the maximum number of page instances that will be saved into application-scoped cache:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getStoreSettings().setInmemoryCacheSize(50);
&#125;</pre></div><p class="paragraph"/><h3>Page expiration</h3><p class="paragraph"/>Page instances are not kept in the user session forever. They can be discarded when the limit set with the setMaxSizePerSession method is reached or (more often) when user session expires. When we ask Wicket for a page id corresponding to a page instance removed from the session, we bump into a  PageExpiredException and we get the following default error page:<p class="paragraph"/><img border="0" class="center" src="../img/page-expired.png"></img><p class="paragraph"/>This error page can be customized with the <code>setPageExpiredErrorPage</code> method of class <code>org.apache.wicket.settings.ApplicationSettings</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getApplicationSettings().setPageExpiredErrorPage(
				CustomExpiredErrorPage.class);
&#125;</pre></div><p class="paragraph"/>The page class provided as custom error page must have a public constructor with no argument or a constructor that takes as input a single PageParameters argument (the page must be bookmarkable as described in <a href="../guide/single.html#urls_1" class="guide">paragraph 10.1.1</a>).



<h2 id="versioningCaching_3">8.3 Stateless pages</h2>
<p class="paragraph"/>Wicket makes it very easy to build stateful pages, but sometimes we might want to use an ‚Äúold school‚Äù stateless page that doesn't keep memory of its state in the user session. For example consider the public area of a site or a login page: in those cases a stateful page would be a waste of resources or even a security threat, as we will see in paragraph <a href="../guide/single.html#forms2_10" class="guide">paragraph 12.10</a>.<p class="paragraph"/>In Wicket a page can be stateless only if it satisfies the following requirements:
<ol>
<li>it has been instantiated by Wicket (i.e. we don't create it with operator new) using a constructor with no argument or a constructor that takes as input a single PageParameters argument (class PageParameters will be covered in <a href="../guide/single.html#urls_1" class="guide">chapter 10.1</a>).</li>
<li>All its children components (and behaviors) are in turn stateless, which means that their method isStateless must return true.</li>
</ol><p class="paragraph"/>The first requirement implies that, rather than creating a page by hand, we should rely on Wicket's capability of resolving page instances, like we do when we use method setResponsePage(Class page).<p class="paragraph"/>In order to comply with the second requirement it could be helpful to check if all children components of a page are stateless. To do this we can leverage method visitChildren and the visitor pattern to iterate over components and test if their method isStateless actually returns true:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> void onInitialize() &#123;
		<span class="java&#45;keyword">super</span>.onInitialize();<p class="paragraph"/>		visitChildren(<span class="java&#45;keyword">new</span> IVisitor&#60;Component, <span class="java&#45;object">Void</span>&#62;() &#123;
			@Override
			<span class="java&#45;keyword">public</span> void component(Component component, IVisit&#60;<span class="java&#45;object">Void</span>&#62; arg1) &#123;
				<span class="java&#45;keyword">if</span>(!component.isStateless())
		  			<span class="java&#45;object">System</span>.out.println(<span class="java&#45;quote">"Component "</span> + component.getId() + <span class="java&#45;quote">" is not stateless"</span>);
			&#125;
		&#125;);
	&#125;</pre></div><p class="paragraph"/>Alternatively, we could use the <code>StatelessComponent</code> utility annotation along with the <code>StatelessChecker</code> class (they are both in package <code>org.apache.wicket.devutils.stateless</code>). <code>StatelessChecker</code> will throw an <code>IllegalArgumentException</code> if a component annotated with <code>StatelessComponent</code> doesn't respect the requirements for being stateless. To use <code>StatelessComponent</code> annotation we must first add the <code>StatelessChecker</code> to our application as a component render listener:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getComponentPostOnBeforeRenderListeners().add(<span class="java&#45;keyword">new</span> StatelessChecker());
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Most of the Wicket's built-in components are stateful, hence they can not be used with a stateless page. However some of them have also a stateless version which can be adopted when we need to keep a page stateless. In the rest of the guide we will point out when a built-in component comes also with a stateless version.
</blockquote><p class="paragraph"/>A page can be also explicitly declared as stateless setting the appropriate flag to true with the setStatelessHint(true) method. This method will not prevent us from violating the requirements for a stateless page, but if we do so we will get the following warning log message:<p class="paragraph"/><blockquote class="warning">
Page '&#60;page class&#62;' is not stateless because of component with path '&#60;component path&#62;'
</blockquote>



<h2 id="versioningCaching_4">8.4 Summary</h2>
<p class="paragraph"/>In this chapter we have seen how page instances are managed by Wicket. We have learnt that pages can be divided into two families: stateless and stateful pages. Knowing the difference between the two types of pages is important to build the right page for a given task.<p class="paragraph"/>However, to complete the discussion about stateless pages we still have to deal with two topics we have just outlined in this chapter: class PageParameters and bookmarkable pages. The first part of <a href="../guide/single.html#urls" class="guide">chapter 10</a> will cover these missing topics.



<h1 id="requestProcessing">9 Under the hood of the request processing</h1>
Although Wicket was born to provide a reliable and comprehensive object oriented abstraction for web development, sometimes we might need to work directly with ‚Äúraw‚Äù web entities such as user session, web request, query parameters, and so on. For example this is necessary if we want to store an arbitrary parameter in the user session.<p class="paragraph"/>Wicket provides wrapper classes that allow us to easily access to web entities without the burden of using the low-level APIs of Java Servlet Specification. However it will always be possible to access standard classes (like HttpSession, HttpServletRequest, etc...) that lay under our Wicket application.
This chapter will introduce these wrapper classes and it will explain how Wicket uses them to handle the web requests initiated by the user's browser.


<h2 id="requestProcessing_1">9.1 Class Application and request processing</h2>
<p class="paragraph"/>Beside configuring and initializing our application, the Application class is responsible for creating the internal entities used by Wicket to process a request. These entities are instances of the following classes: RequestCycle, Request, Response and Session.<p class="paragraph"/>The next paragraphs will illustrate each of these classes, explaining how they are involved into request processing.


<h2 id="requestProcessing_2">9.2 Request and Response classes</h2>
<p class="paragraph"/>The <code>Request</code> and <code>Response</code> classes are located in package <code>org.apache.wicket.request</code> and they provide an abstraction of the concrete request and response used by our web application.<p class="paragraph"/>Both classes are declared as abstract but if our application class inherits from <code>WebApplication</code> it will use their sub classes <code>ServletWebRequest</code> and <code>ServletWebResponse</code>, both of them located inside the package <code>org.apache.wicket.protocol.http.servlet.ServletWebRequest</code> and <code>ServletWebResponse</code> wrap respectively a <code>HttpServletRequest</code> and a <code>HttpServletResponse</code> object. If we need to access to these low-level objects we can call <code>Request</code>'s method <code>getContainerRequest()</code> and <code>Response</code>'s method <code>getContainerResponse()</code>.


<h2 id="requestProcessing_3">9.3 The ‚Äúdirector‚Äù of request processing - RequestCycle</h2>
<p class="paragraph"/>Class <code>org.apache.wicket.request.cycle.RequestCycle</code> is the entity in charge of serving a web request. Our application class creates a new <code>RequestCycle</code> on every request with its method <code>createRequestCycle(request, response)</code>.<p class="paragraph"/>Method <code>createRequestCycle</code> is declared as final, so we can't override it to return a custom subclass of <code>RequestCycle</code>. Instead, we must build a request cycle provider implementing interface <code>org.apache.wicket.IRequestCycleProvider</code>, and then we must tell our application class to use it via the <code>setRequestCycleProvider</code> method.<p class="paragraph"/>The current running request cycle can be retrieved at any time by calling its static method <code>RequestCycle.get()</code>. Strictly speaking this method returns the request cycle associated with the current (or local) thread, which is the thread that is serving the current request. A similar <code>get()</code> method is also implemented in classes <code>org.apache.wicket.Application</code> (as we have seen in <a href="../guide/single.html#helloWorld_2" class="guide">paragraph 4.2.2</a>) and <code>org.apache.wicket.Session</code> in order to get the application and the session in use by the current thread.<p class="paragraph"/><blockquote class="note">
The implementation of the get method takes advantage of the standard class <code>java.lang.ThreadLocal</code>. See its JavaDoc for an introduction to local-thread variables.
</blockquote><p class="paragraph"/>Class <code>org.apache.wicket.Component</code> provides the <code>getRequestCycle()</code> method which is a convenience method that internally invokes <code>RequestCycle.get()</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">final</span> RequestCycle getRequestCycle() &#123;
	<span class="java&#45;keyword">return</span> RequestCycle.get();
&#125;</pre></div><p class="paragraph"/><h3>RequestCycle and request processing</h3><p class="paragraph"/><blockquote class="note">
This paragraph will provide just the basic informations about what happens behind the scenes of request processing. When you work with Wicket it's unlikely to have a need for customizing this process, so we won't cover this topic in detail.
</blockquote><p class="paragraph"/>In order to process a request, <code>RequestCycle</code> delegates the task to another entity which implements interface <code>org.apache.wicket.request.IRequestHandler</code>. There are different implementations of this interface, each suited for a particular type of requested resource (a page to render, an AJAX request, an URL to an external page, etc.).<p class="paragraph"/>To resolve the right handler for a given HTTP request, the <code>RequestCycle</code> uses a set of objects implementing the <code>org.apache.wicket.request.IRequestMapper</code> interface. The mapping interface defines the <code>getCompatibilityScore(Request request)</code> method which returns a score indicating how compatible the request mapper is for the current request. <code>RequestCycle</code> will choose the mapper with the highest score and it will call its <code>mapRequest(Request request)</code> method to get the proper handler for the given request. Once <code>RequestCycle</code> has resolved a request handler, it invokes its method <code>respond(IRequestCycle requestCycle)</code> to start request processing.<p class="paragraph"/>The following sequence diagram recaps how a request handler is resolved by the <code>RequestCycle</code>:<p class="paragraph"/><img border="0" class="center" src="../img/request-cycle-handler.png"></img><p class="paragraph"/>Developers can create additional implementations of IRequestMapper and add them to their application via the mount(IRequestMapper mapper) method of the WebApplication class. In paragraph 10.6 we will see how Wicket uses this method to add built-in mappers for mounted pages.<p class="paragraph"/><h3>Generating URL with the urlFor and mapUrlFor methods</h3><p class="paragraph"/>The RequestCycle is also responsible for generating the URL value (as CharSequence) for the following entities:
<ul class="star">
<li>a page class, via the <code>urlFor(Class&#60;C&#62; pageClass, PageParameters parameters)</code> method</li>
<li>an IRequestHandler via the <code>urlFor(IRequestHandler handler)</code> method</li>
<li>a ResourceReference via the <code>urlFor(ResourceReference reference, PageParameters params)</code> method (resource entities will be introduced in <a href="../guide/single.html#resources" class="guide">chapter 19</a>).</li>
</ul><p class="paragraph"/>The overloaded <code>urlFor</code> method from above also has a corresponding version that returns an instance of <code>org.apache.wicket.request.Url</code> instead of a <code>CharSequence</code>. This version has the prefix 'map' in its name (i.e. it has <code>mapUrlFor</code> as full name).<p class="paragraph"/><h3>Method setResponsePage</h3><p class="paragraph"/>The <code>RequestCycle</code> class contains the implementation of the <code>setResponsePage</code> method we use to redirect a user to a specific page (see <a href="../guide/single.html#helloWorld_4" class="guide">paragraph 4.4</a>). The namesake method of class <code>org.apache.wicket.Component</code> is just a convenience method that internally invokes the actual implementation on current request cycle:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">final</span> void setResponsePage(<span class="java&#45;keyword">final</span> Page page) &#123;
	getRequestCycle().setResponsePage(page);
&#125;</pre></div><p class="paragraph"/><h3>RequestCycle's hook methods and listeners</h3><p class="paragraph"/>The RequestCycle comes with some hook methods which can be overridden to perform custom actions when request handling reaches a specific stage. These methods are:
<ul class="star">
<li><strong class="bold">onBeginRequest():</strong> called when the RequestCycle is about to start handling the request.</li>
<li><strong class="bold">onEndRequest():</strong> called when the RequestCycle has finished to handle the request</li>
<li><strong class="bold">onDetach():</strong> called after the request handling has completed and the RequestCycle is about to be detached from its thread. The default implementation of this method invokes detach() on the current session (the Session class will be shortly discussed in paragraph 9.4).</li>
</ul><p class="paragraph"/>Methods onBeforeRequest and onEndRequest can be used if we need to execute custom actions before and after business code is executed, such as opening a Hibernate/JPA session and closing it when code has terminated.<p class="paragraph"/>A more flexible way to interact with the request processing is to use the listener interface <code>org.apache.wicket.request.cycle.IRequestCycleListener</code>. In addition to the three methods already seen for RequestCycle, this interface offers further hooks into request processing:
<ul class="star">
<li><strong class="bold">onBeginRequest(RequestCycle cycle):</strong> (see the description above)</li>
<li><strong class="bold">onEndRequest(RequestCycle cycle):</strong> (see the description above)</li>
<li><strong class="bold">onDetach(RequestCycle cycle):</strong> (see the description above)</li>
<li><strong class="bold">onRequestHandlerResolved(RequestCycle cycle, IRequestHandler handler):</strong> called when an IRequestHandler has been resolved.</li>
<li><strong class="bold">onRequestHandlerScheduled(RequestCycle cycle, IRequestHandler handler):</strong> called when an IRequestHandler has been scheduled for execution.</li>
<li><strong class="bold">onRequestHandlerExecuted(RequestCycle cycle, IRequestHandler handler):</strong> called when an IRequestHandler has been executed.</li>
<li><strong class="bold">onException(RequestCycle cycle, Exception ex):</strong> called when an exception has been thrown during request processing.</li>
<li><strong class="bold">onExceptionRequestHandlerResolved(RequestCycle rc, IRequestHandler rh, Exception ex):</strong> called when an IRequestHandler has been resolved and will be used to handle an exception.</li>
<li><strong class="bold">onUrlMapped(RequestCycle cycle, IRequestHandler handler, Url url):</strong> called when an URL has been generated for an IRequestHandler object.</li>
</ul><p class="paragraph"/>To use the request cycle listeners we must add them to our application which in turn will pass them to the new <code>RequestCycle</code>'s instances created with <code>createRequestCycle</code> method:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init() &#123;<p class="paragraph"/>	<span class="java&#45;keyword">super</span>.init();<p class="paragraph"/>	IRequestCycleListener myListener;
	//listener initialization&#8230;
	getRequestCycleListeners().add(myListener)		
&#125;</pre></div><p class="paragraph"/>The <code>getRequestCycleListeners</code> method returns an instance of class <code>org.apache.wicket.request.cycle.RequestCycleListenerCollection</code>. This class is a sort of typed collection for <code>IRequestCycleListener</code> and it also implements the <a href="http://en.wikipedia.org/wiki/Composite_pattern" target="blank">Composite pattern</a> .<p class="paragraph"/>


<h2 id="requestProcessing_4">9.4 Session Class</h2>
<p class="paragraph"/>In Wicket we use class <code>org.apache.wicket.Session</code> to handle session-relative informations such as client informations, session attributes, session-level cache (seen in paragraph 8.2), etc...<p class="paragraph"/>In addition, we know from paragraph 8.1 that Wicket creates a user session to store versions of stateful pages. Similarly to what happens with RequestCycle, the new Session's instances are generated by the <code>Application</code> class with the <code>newSession(Request request, Response response)</code> method. This method is not declared as final, hence it can be overridden if we need to use a custom implementation of the Session class.<p class="paragraph"/>By default if our custom application class is a subclass of WebApplication, method newSession will return an instance of class <code>org.apache.wicket.protocol.http.WebSession</code>. As we have mentioned talking about <code>RequestCycle</code>, also class Session provides a static <code>get()</code> method which returns the session associated to the current thread.<p class="paragraph"/><h3>Session and listeners</h3><p class="paragraph"/>Similar to the <code>RequestCycle</code>, class <code>org.apache.wicket.Session</code> also offers support for listener entities. With Session these entities must implement the callback interface <code>org.apache.wicket.ISessionListener</code> which exposes only the <code>onCreated(Session session)</code> method. As you might guess from its name, this method is called when a new session is created. Session listeners must be added to our application using a typed collection, just like we have done before with request cycle listeners:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()&#123;<p class="paragraph"/>	<span class="java&#45;keyword">super</span>.init();<p class="paragraph"/>	//listener initialization&#8230;
	ISessionListener myListener;
	//add a custom session listener
	getSessionListeners().add(myListener)<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><h3>Handling session attributes</h3><p class="paragraph"/>The Session class handles session attributes in much the same way as the standard interface javax.servlet.http.HttpSession. The following methods are provided to create, read and remove session attributes:
<ul class="star">
<li><strong class="bold">setAttribute(String name, Serializable value):</strong> creates an attribute identified by the given name. If the session already contains an attribute with the same name, the new value will replace the existing one. The value must be a serializable object.</li>
<li><strong class="bold">getAttribute(String name):</strong> returns the value of the attribute identified by the given name, or null if the name does not correspond to any attribute.</li>
<li><strong class="bold">removeAttribute(String name):</strong> removes the attribute identified by the given name.</li>
</ul><p class="paragraph"/>By default class WebSession will use the underlying HTTP session to store attributes. Wicket will automatically add a prefix to the name of the attributes. This prefix is returned by the WebApplication's method getSessionAttributePrefix().<p class="paragraph"/><h3>Accessing to the HTTP session</h3><p class="paragraph"/>If for any reason we need to directly access to the underlying HttpSession object, we can retrieve it from the current request with the following code:<p class="paragraph"/><div class="code"><pre>HttpSession session = ((ServletWebRequest)RequestCycle.get()
		.getRequest()).getContainerRequest().getSession();</pre></div><p class="paragraph"/>Using the raw session object might be necessary if we have to set a session attribute with a particular name without the prefix added by Wicket. Let's say for example that we are working with Tomcat as web server. One of the administrative tools provided by Tomcat is a page listing all the active user sessions of a given web application:<p class="paragraph"/><img border="0" class="center" src="../img/tomcat-admin-sessions.png"></img><p class="paragraph"/>Tomcat allows us to set the values that will be displayed in columns ‚ÄúGuessed locale‚Äù and ‚ÄúGuessed User name‚Äù. One possible way to do this is to use session attributes named ‚ÄúLocale‚Äù and ‚ÄúuserName‚Äù but we can't create them via Wicket's Session class because they would not have exactly the name required by Tomcat. Instead, we must use the raw HttpSession and set our attributes on it:<p class="paragraph"/><div class="code"><pre>HttpSession session = ((ServletWebRequest)RequestCycle.get().
		getRequest()).getContainerRequest().getSession();<p class="paragraph"/>session.setAttribute(<span class="java&#45;quote">"Locale"</span>, <span class="java&#45;quote">"ENGLISH"</span>);
session.setAttribute(<span class="java&#45;quote">"userName"</span>, <span class="java&#45;quote">"Mr BadGuy"</span>);</pre></div><p class="paragraph"/><h3>Temporary and permanent sessions</h3><p class="paragraph"/>Wicket doesn't need to store data into user session as long as the user visits only stateless pages. Nonetheless, even under these conditions, a temporary session object is created to process each request but it is discarded at the end of the current request. To know if the current session is temporary, we can use the isTemporary() method:<p class="paragraph"/><div class="code"><pre>Session.get().isTemporary();</pre></div><p class="paragraph"/>If a session is not temporary (i.e. it is permanent), it's identified by an unique id which can be read calling the getId() method. This value will be null if the session is temporary.<p class="paragraph"/>Although Wicket is able to automatically recognize when it needs to replace a temporary session with a permanent one, sometimes we may need to manually control this process to make our initially temporary session permanent.<p class="paragraph"/>To illustrate this possible scenario let's consider project BindSessionExample where we have a stateless home page which sets a session attribute inside its constructor and then it redirects the user to another page which displays with a label the session attribute previously created. The code of the two pages is as follows:<p class="paragraph"/>Home page:
<div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
    <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
    	Session.get().setAttribute(<span class="java&#45;quote">"username"</span>, <span class="java&#45;quote">"tommy"</span>);
	Session.get().bind();<p class="paragraph"/>	setResponsePage(DisplaySessionParameter.class);
    &#125;   
&#125;</pre></div><p class="paragraph"/>Target page:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class DisplaySessionParameter <span class="java&#45;keyword">extends</span> WebPage &#123;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> DisplaySessionParameter() &#123;
	   <span class="java&#45;keyword">super</span>();
	   add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"username"</span>, (<span class="java&#45;object">String</span>) Session.get().getAttribute(<span class="java&#45;quote">"username"</span>)));
	&#125;
&#125;</pre></div><p class="paragraph"/>Again, we kept page logic very simple to not over-bloat the example with unnecessary code. In the snippet above we have also bolded Session's bind() method which converts temporary session into a permanent one. If the home page has not invoked this method, the session with its attribute would have been discarded at the end of the request and the page DisplaySessionParameter would have displayed an empty value in its label.<p class="paragraph"/><h3>Discarding session data</h3><p class="paragraph"/>Once a user has finished using our web application, she must be able to log out and clean any session data. To be sure that a permanent session will be discarded at the end of the current request, class Session provides the invalidate() method. If we want to immediately invalidate a given session without waiting for the current request to complete, we can invoke the invalidateNow() method.<p class="paragraph"/><blockquote class="warning">
Remember that invalidateNow() will immediately remove any instance of components (and pages) from the session, meaning that once we have called this method we won't be able to work with them for the rest of the request process.
</blockquote><p class="paragraph"/><h3>Storing arbitrary objects with metadata</h3><p class="paragraph"/>JavaServer Pages Specification1 defines 4 scopes in which a page can create and access a variable. These scopes are:
<ul class="star">
<li><strong class="bold">request:</strong> variables declared in this scope can be seen only by pages processing the same request. The lifespan of these variables is (at most) equal to the one of the related request. They are discarded when the full response has been generated or when the request is forwarded somewhere else.</li>
<li><strong class="bold">page:</strong> variables declared in this scope can be seen only by the page that has created them.</li>
<li><strong class="bold">session:</strong> variables in session scope can be created and accessed by every page used in the same session where they are defined.</li>
<li><strong class="bold">application:</strong> this is the widest scope. Variables declared in this scope can be used by any page of a given web application.</li>
</ul><p class="paragraph"/>Although Wicket doesn't implement the JSP Specification (it is rather an alternative to it), it offers a feature called metadata which resembles scoped variables but is much more powerful. Metadata is quite similar to a Java Map in that it stores pairs of key-value objects where the key must be unique. In Wicket each of the following classes has its own metadata store: RequestCycle, Session, Application and Component.<p class="paragraph"/>The key used for metadata is an instance of class <code>org.apache.wicket.MetaDataKey&#60;T&#62;</code>. To put an arbitrary object into metadata we must use the setMetaData method which takes two parameters as input: the key used to store the value and the value itself. If we are using metadata with classes Session or Component, data object must be serializable because Wicket serializes both session and component instances. This constraint is not applied to metadata of classes Application and RequestCycle which can contain a generic object. In any case, the type of data object must be compatible with the type parameter T specified by the key.<p class="paragraph"/>To retrieve a previously inserted object we must use the <code>getMetaData(MetaDataKey&#60;T&#62; key)</code> method. In the following example we set a <code>java.sql.Connection</code> object in the application's metadata so it can be used by any page of the application:<p class="paragraph"/>Application class code:
<div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> MetaDataApp <span class="java&#45;keyword">extends</span> WebApplication&#123;
	//Do some stuff&#8230;
	/&#42;&#42;
	&#42; Metadata key definition
	&#42;/
	<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> MetaDataKey&#60;Connection&#62; connectionKey = <span class="java&#45;keyword">new</span> MetaDataKey&#60;Connection&#62; ()&#123;&#125;;<p class="paragraph"/>	/&#42;&#42;
	 &#42; Application's initialization
	 &#42;/
	@Override
	<span class="java&#45;keyword">public</span> void init()&#123;<p class="paragraph"/>		<span class="java&#45;keyword">super</span>.init();
		Connection connection;
		//connection initialization&#8230;
		setMetaData(connectionKey, connection);
		//Do some other stuff..<p class="paragraph"/>	&#125;
&#125;</pre></div><p class="paragraph"/>Code to get the object from the metadata:<p class="paragraph"/><div class="code"><pre>Connection connection = Application.get().getMetaData(MetaDataApp.connectionKey);</pre></div><p class="paragraph"/>Since MetaDataKey&#60;T&#62; class is declared as abstract, we must implement it with a subclass or with an anonymous class (like we did in the example above).



<h2 id="requestProcessing_5">9.5 Exception handling</h2>
Wicket uses a number of custom exceptions during the regular running of an application. We have already seen <code>PageExpiredException</code> raised when a page version is expired. Other examples of such exceptions are <code>AuthorizationException</code> and <code>RestartResponseException</code>. We will see them later in the next chapters.
All the other exceptions raised during rendering phase are handled by an implementation of <code>org.apache.wicket.request.IExceptionMapper</code> which by default is class <code>org.apache.wicket.DefaultExceptionMapper</code>. If we are working in DEVELOPMENT mode this mapper will redirect us to a page that shows the exception stacktrace (page <code>ExceptionErrorPage</code>). On the contrary, if application is running in DEPLOYMENT mode <code>DefaultExceptionMapper</code> will display an internal error page which by default is <code>org.apache.wicket.markup.html.pages.InternalErrorPage</code>.
To use a custom internal error page we can change application settings like this:<p class="paragraph"/><div class="code"><pre>getApplicationSettings().setInternalErrorPage(MyInternalErrorPage.class);</pre></div><p class="paragraph"/>We can also manually set if Wicket should display the exception with <code>ExceptionErrorPage</code> or if we want to use the internal error page or if we don't want to display anything at all when an unexpected exception is thrown:<p class="paragraph"/><div class="code"><pre>//show <span class="java&#45;keyword">default</span> developer page
getExceptionSettings().setUnexpectedExceptionDisplay( ExceptionSettings.SHOW_EXCEPTION_PAGE );
//show internal error page
getExceptionSettings().setUnexpectedExceptionDisplay( ExceptionSettings.SHOW_INTERNAL_ERROR_PAGE );
//show no exception page when an unexpected exception is thrown
getExceptionSettings().setUnexpectedExceptionDisplay( ExceptionSettings.SHOW_NO_EXCEPTION_PAGE );</pre></div><p class="paragraph"/>Developers can also decide to use a custom exception mapper instead of <code>DefaultExceptionMapper</code>. To do this we must override <code>Application</code>'s method <code>getExceptionMapperProvider</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> IProvider&#60;IExceptionMapper&#62; getExceptionMapperProvider()
&#123;
    //&#8230;
&#125;</pre></div><p class="paragraph"/>The method returns an instance of <code>org.apache.wicket.util.IProvider</code> that should return our custom exception mapper.<p class="paragraph"/><h3>Ajax requests</h3><p class="paragraph"/>To control the behavior in Ajax requests the application may use <code>org.apache.wicket.settings.ExceptionSettings#  setAjaxErrorHandlingStrategy(ExceptionSettings.AjaxErrorStrategy)</code>. By default if an error occurs during the 
processing of an Ajax request Wicket will render the configured error page. By configuring <code>org.apache.wicket.settings.ExceptionSettings.  AjaxErrorStrategy#INVOKE_FAILURE_HANDLER</code> as the default strategy the application will call the JavaScript <code>onFailure</code> callback(s) instead.



<h2 id="requestProcessing_6">9.6 Summary</h2>
<p class="paragraph"/>In this chapter we had a look at how Wicket internally handles a web request. Even if most of the time  we won't need to customize this internal process, knowing how it works is essential to use the framework at 100%.<p class="paragraph"/>Entities like Application and Session will come in handy again when we will tackle the topic of security in <a href="../guide/single.html#security" class="guide">chapter 23</a>.



<h1 id="urls">10 Wicket Links and URL generation</h1>
Up to now we used component Link to move from a page to another and we have seen that it is quiet similar to a ‚Äúclick‚Äù event handler (see <a href="../guide/single.html#helloWorld_4" class="guide">paragraph 4.4</a>).<p class="paragraph"/>However this component alone is not enough to build all possible kinds of links we may need in our pages. Therefore, Wicket offers other link components suited for those tasks which can not be accomplished with a basic Link.<p class="paragraph"/>Besides learning new link components, in this chapter we will also see how to customize the page URL generated by Wicket using the encoding facility provided by the framework and the page parameters that can be passed to a target page.



<h2 id="urls_1">10.1 PageParameters</h2>
<p class="paragraph"/>A common practice in web development is to pass data to a page using query string parameters (like ?paramName1=paramValu1&#38;paramName2=paramValue2...). Wicket offers a more flexible and object oriented way to do this with models (we will see them in the next chapter). However, even if we are using Wicket, we still need to use query string parameters to exchange data with other Internet-based services. Consider for example a classic confirmation page which is linked inside an email to let users confirm important actions like password changing or the subscription to a mailing list. This kind of page usually expects to receive a query string parameter containing the id of the action to confirm.<p class="paragraph"/>Query string parameters can also be referred to as named parameters. In Wicket they are handled with class <code>org.apache.wicket.request.mapper.parameter.PageParameters</code>. Since named parameters are basically name-value pairs, PageParameters works in much the same way as Java Map providing two methods to create/modify a parameter (add(String name, Object value) and set(String name, Object value)),  one method to remove an existing parameter (remove(String name)) and one to retrieve the value of a given parameter (get(String name)) . Here is a snippet to illustrate the usage of PageParameters:<p class="paragraph"/><div class="code"><pre>PageParameters pageParameters = <span class="java&#45;keyword">new</span> PageParameters(); 
//add a couple of parameters
pageParameters.add(<span class="java&#45;quote">"name"</span>, <span class="java&#45;quote">"John"</span>);
pageParameters.add(<span class="java&#45;quote">"age"</span>, 28);
//retrieve the value of 'age' parameter
pageParameters.get(<span class="java&#45;quote">"age"</span>);</pre></div><p class="paragraph"/>Now that we have seen how to work with page parameters, let's see how to use them with our pages.<p class="paragraph"/><h3>PageParameters and bookmarkable pages</h3><p class="paragraph"/>Base class Page comes with a constructor which takes as input a PageParameters instance. If we use this superclass constructor in our page, PageParameters will be used to build the page URL and it can be retrieved at a later time with the Page's getPageParameters() method.<p class="paragraph"/>In the following example taken from the PageParametersExample project we have a home page with a link to a second page that uses a version of setResponsePage method that takes as input also a PageParameters to build the target page (named PageWithParameters). The code for the link and for the target page is the following:<p class="paragraph"/>Link code:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> Link(<span class="java&#45;quote">"pageWithIndexParam"</span>) &#123;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> void onClick() &#123;<p class="paragraph"/>		PageParameters pageParameters = <span class="java&#45;keyword">new</span> PageParameters();
		pageParameters.add(<span class="java&#45;quote">"foo"</span>, <span class="java&#45;quote">"foo"</span>);
		pageParameters.add(<span class="java&#45;quote">"bar"</span>, <span class="java&#45;quote">"bar"</span>);<p class="paragraph"/>		setResponsePage(PageWithParameters.class, pageParameters);
	&#125;<p class="paragraph"/>&#125;);</pre></div><p class="paragraph"/>Target page code:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class PageWithParameters <span class="java&#45;keyword">extends</span> WebPage &#123;
	//Override superclass constructor
	<span class="java&#45;keyword">public</span> PageWithParameters(PageParameters parameters) &#123;
		<span class="java&#45;keyword">super</span>(parameters);
	&#125;
 &#125;</pre></div><p class="paragraph"/>The code is quite straightforward and it‚Äôs more interesting to look at the URL generated for the target page:<p class="paragraph"/><div class="code"><pre>&#60;app root&#62;/PageParametersExample/wicket/bookmarkable/
		org.wicketTutorial.PageWithParameters?foo=foo&#38;bar=bar</pre></div><p class="paragraph"/>At first glance the URL above could seem a little weird, except for the last part which contains the two named parameters used to build the target page.<p class="paragraph"/>The reason for this ‚Äústrange‚Äù URL is that, as we explained in paragraph 8.3, when a page is instantiated using a constructor with no argument or using a constructor that accepts only a PageParameters, Wicket will try to generate a static URL for it, with no session-relative informations. This kind of URL is called bookmarkable because it can be saved by the users as a bookmark and accessed at a later time.<p class="paragraph"/>A bookmarkable URL is composed by a fixed prefix (which by default is bookmarkable) and the qualified name of the page class (org.wicketTutorial.PageWithParameters in our example). Segment wicket is another fixed prefix added by default during URL generation. In paragraph 10.6 we will see how to customize fixed prefixes with a custom implementation of IMapperContext interface.<p class="paragraph"/><h3>Indexed parameters</h3><p class="paragraph"/>Besides named parameters, Wicket also supports indexed parameters. These kinds of parameters are rendered as URL segments placed before named parameters. Let's consider for example the following URL:<p class="paragraph"/><div class="code"><pre>&#60;application path&#62;/foo/bar?1&#38;baz=baz</pre></div><p class="paragraph"/>The URL above contains two indexed parameters (foo and bar) and a query string consisting of the page id and a named parameter (baz). Just like named parameters also indexed parameters are handled by the PageParameters class. The methods provided by PageParameters for indexed parameters are set(int index, Object object) (to add/modify a parameter), remove(int index)(to remove a parameter) and get(int index) (to read a parameter).<p class="paragraph"/>As their name suggests, indexed parameters are identified by a numeric index and they are rendered following the order in which they have been added to the PageParameters. The following is an example of indexed parameters:<p class="paragraph"/><div class="code"><pre>PageParameters pageParameters = <span class="java&#45;keyword">new</span> PageParameters(); 
//add a couple of parameters
pageParameters.set(0, <span class="java&#45;quote">"foo"</span>);
pageParameters.set(1, <span class="java&#45;quote">"bar"</span>);
//retrieve the value of the second parameter (<span class="java&#45;quote">"bar"</span>)
pageParameters.get(1);</pre></div><p class="paragraph"/>Project PageParametersExample comes also with a link to a page with both indexed parameters and a named parameter:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> Link(<span class="java&#45;quote">"pageWithNamedIndexParam"</span>) &#123;<p class="paragraph"/>	@Override
 	<span class="java&#45;keyword">public</span> void onClick() &#123;<p class="paragraph"/>		PageParameters pageParameters = <span class="java&#45;keyword">new</span> PageParameters();
		pageParameters.set(0, <span class="java&#45;quote">"foo"</span>);
		pageParameters.set(1, <span class="java&#45;quote">"bar"</span>);
		pageParameters.add(<span class="java&#45;quote">"baz"</span>, <span class="java&#45;quote">"baz"</span>);<p class="paragraph"/>		setResponsePage(PageWithParameters.class, pageParameters);
	&#125;<p class="paragraph"/>&#125;);</pre></div><p class="paragraph"/>The URL generated for the linked page (PageWithParameters) is the one seen at the beginning of the paragraph.



<h2 id="urls_2">10.2 Bookmarkable links</h2>
<p class="paragraph"/>A link to a bookmarkable page can be built with the link component <code>org.apache.wicket.markup.html.link.BookmarkablePageLink</code>:<p class="paragraph"/><div class="code"><pre>BookmarkablePageLink bpl=<span class="java&#45;keyword">new</span> BookmarkablePageLink(PageWithParameters.class, pageParameters);</pre></div><p class="paragraph"/>The specific purpose of this component is to provide an anchor to a bookmarkable page, hence we don't have to implement any abstract method like we do with Link component.


<h2 id="urls_3">10.3 Automatically creating bookmarkable links with tag wicket:link</h2>
<p class="paragraph"/>Bookmarkable pages can be linked directly inside markup files without writing any Java code. Using &#60;wicket:link&#62; tag we ask Wicket to automatically add bookmarkable links for the anchors wrapped inside it. Here is an example of usage of &#60;wicket:link&#62; tag taken from the home page of the project BookmarkablePageAutoLink:<p class="paragraph"/><div class="code"><pre>&#60;!DOCTYPE html&#62;
&#60;html xmlns:wicket=<span class="java&#45;quote">"http://wicket.apache.org"</span>&#62;
	&#60;head&#62;
		&#60;meta charset=<span class="java&#45;quote">"utf&#45;8"</span> /&#62;
		&#60;title&#62;Apache Wicket Quickstart&#60;/title&#62;
	&#60;/head&#62;
	&#60;body&#62;		
	   &#60;div id=<span class="java&#45;quote">"bd"</span>&#62;
	      &#60;wicket:link&#62;
			&#60;a href=<span class="java&#45;quote">"HomePage.html"</span>&#62;HomePage&#60;/a&#62;&#60;br/&#62;
			&#60;a href=<span class="java&#45;quote">"anotherPackage/SubPackagePage.html"</span>&#62;SubPackagePage&#60;/a&#62;	
	      &#60;/wicket:link&#62;
	   &#60;/div&#62;		
	&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The key part of the markup above is the href attribute which must contain the package-relative path to a page. The home page is inside package org.wicketTutorial which in turns contains the sub package anotherPackage. This package hierarchy is reflected by the href attributes: in the first anchor we have a link to the home page itself while the second anchor points to page SubPackagePage which is placed into sub package anotherPackage. Absolute paths are supported as well and we can use them if we want to specify the full package of a given page. For example the link to SubPackagePage could have been written in the following (more verbose) way:<p class="paragraph"/><div class="code"><pre>&#60;a href=<span class="java&#45;quote">"/org/wicketTutorial/anotherPackage/SubPackagePage.html"</span>&#62; SubPackagePage&#60;/a&#62;</pre></div><p class="paragraph"/>If we take a look also at the markup of SubPackagePage we can see that it contains a link to the home page which uses the parent directory selector (relative path):<p class="paragraph"/><div class="code"><pre>&#60;!DOCTYPE html&#62;
&#60;html xmlns:wicket=<span class="java&#45;quote">"http://wicket.apache.org"</span>&#62;
	&#60;head&#62;
		&#60;meta charset=<span class="java&#45;quote">"utf&#45;8"</span> /&#62;
		&#60;title&#62;Apache Wicket Quickstart&#60;/title&#62;
	&#60;/head&#62;
	&#60;body&#62;		
		&#60;div id=<span class="java&#45;quote">"bd"</span>&#62;
			&#60;wicket:link&#62;
				&#60;a href=<span class="java&#45;quote">"../HomePage.html"</span>&#62;HomePage&#60;/a&#62;&#60;br/&#62;
				&#60;a href=<span class="java&#45;quote">"SubPackagePage.html"</span>&#62;SubPackagePage&#60;/a&#62;			
			&#60;/wicket:link&#62;
		&#60;/div&#62;		
	&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>Please note that any link to the current page (aka self link) is disabled. For example in the home page the self link is rendered like this:<p class="paragraph"/><div class="code"><pre>&#60;span&#62;&#60;em&#62;HomePage&#60;/em&#62;&#60;/span&#62;</pre></div><p class="paragraph"/>The markup used to render disabled links can be customized using the markup settings (class org.apache.wicket.settings.MarkupSettings) available in the application class:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	//wrap disabled links with &#60;b&#62; tag
	getMarkupSettings().setDefaultBeforeDisabledLink(<span class="java&#45;quote">"&#60;b&#62;"</span>);
	getMarkupSettings().setDefaultAfterDisabledLink(<span class="java&#45;quote">"&#60;/b&#62;"</span>);		
&#125;</pre></div><p class="paragraph"/>The purpose of &#60;wicket:link&#62; tag is not limited to just simplifying the usage of bookmarkable pages. As we will see in chapter 13, this tag can also be adopted to manage web resources like pictures, CSS files, JavaScript files and so on.



<h2 id="urls_4">10.4 External links</h2>
<p class="paragraph"/>Since Wicket uses plain HTML markup files as templates, we can place an anchor to an external page directly inside the markup file. When we need to dynamically generate external anchors, we can use link component <code>org.apache.wicket.markup.html.link.ExternalLink</code>. In order to build an external link we must specify the value of the href attribute using a model or a plain string. In the next snippet, given an instance of Person, we generate a Google search query for its full name:<p class="paragraph"/>Html:<p class="paragraph"/><div class="code"><pre>&#60;a wicket:id=<span class="java&#45;quote">"externalSite"</span>&#62;Search me on Google!&#60;/a&#62;</pre></div><p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre>Person person = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>); 
<span class="java&#45;object">String</span> fullName = person.getFullName();
//Space characters must be replaced by character '+'
<span class="java&#45;object">String</span> googleQuery = <span class="java&#45;quote">"http://www.google.com/search?q="</span> + fullName.replace(<span class="java&#45;quote">" "</span>, <span class="java&#45;quote">"+"</span>);
add(<span class="java&#45;keyword">new</span> ExternalLink(<span class="java&#45;quote">"externalSite"</span>, googleQuery));</pre></div><p class="paragraph"/>Generated anchor:<p class="paragraph"/><div class="code"><pre>&#60;a href=<span class="java&#45;quote">"http://www.google.com/search?q=John+Smith"</span>&#62;Search me on Google!&#60;/a&#62;</pre></div><p class="paragraph"/>If we need to specify a dynamic value for the text inside the anchor, we can pass it as an additional constructor parameter:<p class="paragraph"/>Html:<p class="paragraph"/><div class="code"><pre>&#60;a wicket:id=<span class="java&#45;quote">"externalSite"</span>&#62;Label goes here...&#60;/a&#62;</pre></div><p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre>Person person = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>); 
<span class="java&#45;object">String</span> fullName = person.getFullName();
<span class="java&#45;object">String</span> googleQuery = <span class="java&#45;quote">"http://www.google.com/search?q="</span> + fullName.replace(<span class="java&#45;quote">" "</span>, <span class="java&#45;quote">"+"</span>);
<span class="java&#45;object">String</span> linkLabel = <span class="java&#45;quote">"Search '"</span> + fullName + <span class="java&#45;quote">"' on Google."</span>;<p class="paragraph"/>add(<span class="java&#45;keyword">new</span> ExternalLink(<span class="java&#45;quote">"externalSite"</span>, googleQuery, linkLabel));</pre></div><p class="paragraph"/>Generated anchor:<p class="paragraph"/><div class="code"><pre>&#60;a href=<span class="java&#45;quote">"http://www.google.com/search?q=John+Smith"</span>&#62;Search 'John Smith' on Google.&#60;/a&#62;</pre></div>


<h2 id="urls_5">10.5 Stateless links</h2>
<p class="paragraph"/>Component Link has a stateful nature, hence it cannot be used with stateless pages. To use links with these kinds of pages Wicket provides the convenience <code>org.apache.wicket.markup.html.link.StatelessLink</code> component which is basically a subtype of Link with the stateless hint set to true.<p class="paragraph"/>Please keep in mind that Wicket generates a new instance of a stateless page also to serve stateless links, so the code inside the onClick() method can not depend on instance variables. To illustrate this potential issue let's consider the following code (from the project StatelessPage) where the value of the variable index is used inside onclick():<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class StatelessPage <span class="java&#45;keyword">extends</span> WebPage &#123;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">int</span> index = 0;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> StatelessPage(PageParameters parameters) &#123;
		<span class="java&#45;keyword">super</span>(parameters);
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> void onInitialize() &#123;
		<span class="java&#45;keyword">super</span>.onInitialize();
		setStatelessHint(<span class="java&#45;keyword">true</span>);<p class="paragraph"/>		add(<span class="java&#45;keyword">new</span> StatelessLink(<span class="java&#45;quote">"statelessLink"</span>) &#123;<p class="paragraph"/>			@Override
			<span class="java&#45;keyword">public</span> void onClick() &#123;
				//It will always print zero
				<span class="java&#45;object">System</span>.out.println(index++);
			&#125;<p class="paragraph"/>		&#125;);
	&#125;	
&#125;</pre></div><p class="paragraph"/>The printed value will always be zero because a new instance of the page is used every time the user clicks on the statelessLink link.


<h2 id="urls_6">10.6 Generating structured and clear URLs</h2>
<p class="paragraph"/>Having structured URLs in our site is a basic requirement if we want to build an efficient SEO strategy, but it also contributes to improve user experience with more intuitive URLs. Wicket provides two different ways to control URL generation. The first (and simplest) is to ‚Äúmount‚Äù one or more pages to an arbitrary path, while a more powerful technique is to use custom implementations of IMapperContext and IPageParametersEncoder interfaces. In the next paragraphs we will learn both of these two techniques.<p class="paragraph"/><h3>Mounting a single page</h3><p class="paragraph"/>With Wicket we can mount a page to a given path in much the same way as we map a servlet filter to a desired path inside file web.xml (see <a href="../guide/single.html#helloWorld_2" class="guide">paragraph 4.2</a>). Using mountPage(String path, Class &#60;T&#62;¬†pageClass) method of the WepApplication class we tell Wicket to respond with a new instance of pageClass whenever a user navigates to the given path. In the application class of the project MountedPagesExample we mount MountedPage to the "/pageMount" path:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	mountPage(<span class="java&#45;quote">"/pageMount"</span>, MountedPage.class);
	//Other initialization code&#8230;
&#125;</pre></div><p class="paragraph"/>The path provided to mountPage will be used to generate the URL for any page of the specified class:<p class="paragraph"/><div class="code"><pre>//it will <span class="java&#45;keyword">return</span> <span class="java&#45;quote">"/pageMount"</span>
RequestCycle.get().urlFor(MountedPage.class);</pre></div><p class="paragraph"/>Under the hood the mountPage method mounts an instance of the request mapper <code>org.apache.wicket.request.mapper.MountedMapper</code> configured for the given path:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">final</span> &#60;T <span class="java&#45;keyword">extends</span> Page&#62; void mountPage(<span class="java&#45;keyword">final</span> <span class="java&#45;object">String</span> path,<span class="java&#45;keyword">final</span> <span class="java&#45;object">Class</span>&#60;T&#62; pageClass) &#123;
	mount(<span class="java&#45;keyword">new</span> MountedMapper(path, pageClass));
&#125;</pre></div><p class="paragraph"/>Request mappers and the Application's method mount have been introduced in the previous chapter (<a href="../guide/single.html#requestProcessing_3" class="guide">paragraph 9.3</a>).<p class="paragraph"/><h3>Using parameter placeholders with mounted pages</h3><p class="paragraph"/>The path specified for mounted pages can contain dynamic segments which are populated with the values of the named parameters used to build the page. These segments are declared using special segments called parameter placeholders. Consider the path used in the following example:<p class="paragraph"/><div class="code"><pre>mountPage(<span class="java&#45;quote">"/pageMount/$&#123;foo&#125;/otherSegm"</span>, MountedPageWithPlaceholder.class);</pre></div><p class="paragraph"/>The path used above is composed by three segments: the first and the last are fixed while the second will be replaced by the value of the named parameter foo that must be provided when the page  MountedPageWithPlaceholder is instantiated:<p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre>PageParameters pageParameters = <span class="java&#45;keyword">new</span> PageParameters();
pageParameters.add(<span class="java&#45;quote">"foo"</span>, <span class="java&#45;quote">"foo"</span>);<p class="paragraph"/>setResponsePage(MountedPageWithPlaceholder.class, pageParameters)</pre></div><p class="paragraph"/>Generated URL:<p class="paragraph"/><div class="code"><pre>&#60;Application path&#62;/pageMount/foo/otherSegm</pre></div><p class="paragraph"/>On the contrary if we manually insert an URL like '&#60;web app path&#62;/pageMount/bar/otherSegm', we can read value 'bar' retrieving the named parameter foo inside our page.<p class="paragraph"/>Place holders can be declared as optional using the '#' character in place of '$':<p class="paragraph"/><div class="code"><pre>mountPage(<span class="java&#45;quote">"/pageMount/&#35;&#123;foo&#125;/otherSegm"</span>, MountedPageOptionalPlaceholder.class);</pre></div><p class="paragraph"/>If the named parameter for an optional placeholder is missing, the corresponding segment is removed from the final URL:<p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre>PageParameters pageParameters = <span class="java&#45;keyword">new</span> PageParameters();
setResponsePage(MountedPageWithPlaceholder.class, pageParameters);</pre></div><p class="paragraph"/>Generated URL:<p class="paragraph"/><div class="code"><pre>&#60;Application path&#62;/pageMount/otherSegm</pre></div><p class="paragraph"/><h3>Mounting a package</h3><p class="paragraph"/>In addition to mounting a single page, Wicket allows to mount all of the pages inside a package to a given path. Method mountPackage(String¬†path, Class&#60;T&#62;¬†pageClass) of class WepApplication will mount every page inside pageClass's package to the specified path.<p class="paragraph"/>The resulting URL for package-mounted pages will have the following structure:<p class="paragraph"/><div class="code"><pre>&#60;Application path&#62;/mountedPath/&#60;PageClassName&#62;&#91;optional query string&#93;</pre></div><p class="paragraph"/>For example in the MountedPagesExample project we have mounted all pages inside the subpackage org.tutorialWicket.subPackage with this line of code:<p class="paragraph"/><div class="code"><pre>mountPackage(<span class="java&#45;quote">"/mountPackage"</span>, StatefulPackageMount.class);</pre></div><p class="paragraph"/>StatefulPackageMount is one of the pages placed into the desired package and its URL will be:<p class="paragraph"/><div class="code"><pre>&#60;Application path&#62;/mountPackage/StatefulPackageMount?1</pre></div><p class="paragraph"/>Similarly to what is done by the mountPage method, the implementation of the mountPackage method mounts an instance of <code>org.apache.wicket.request.mapper.PackageMapper</code> to the given path.<p class="paragraph"/><h3>Providing custom mapper context to request mappers</h3><p class="paragraph"/>Interface <code>org.apache.wicket.request.mapper.IMapperContext</code> is used by request mappers to create new page instances and to retrieve static URL segments used to build and parse page URLs. Here is the list of these segments:
<ul class="star">
<li>Namespace: it's the first URL segment of non-mounted pages. By default its value is wicket.</li>
<li>Identifier for non-bookmarkable URLs: it's the segment that identifies non bookmarkable pages. By default its value is page.</li>
<li>Identifier for bookmarkable URLs: it's the segment that identifies bookmarkable pages. By default its value is bookmarkable (as we have seen before in <a href="../guide/single.html#urls_1" class="guide">paragraph 10.1.1</a>).</li>
<li>Identifier for resources: it's the segment that identifies Wicket resources. Its default value is resources. The topic of resource management will be covered in <a href="../guide/single.html#resources" class="guide">chapter 16</a>.</li>
</ul><p class="paragraph"/>IMapperContext provides a getter method for any segment listed above. By default Wicket uses class <code>org.apache.wicket.DefaultMapperContext</code> as mapper context.<p class="paragraph"/>Project CustomMapperContext is an example of customization of mapper context where we use index as identifier for non-bookmarkable pages and staticURL as identifier for bookmarkable pages. In this project, instead of implementing our mapper context from scratch, we used DefaultMapperContext as base class overriding just the two methods we need to achieve the desired result (getBookmarkableIdentifier() and getPageIdentifier()).  The final implementation is the following:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class CustomMapperContext <span class="java&#45;keyword">extends</span> DefaultMapperContext&#123;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getBookmarkableIdentifier() &#123;
		<span class="java&#45;keyword">return</span> <span class="java&#45;quote">"staticURL"</span>;
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getPageIdentifier() &#123;
		<span class="java&#45;keyword">return</span> <span class="java&#45;quote">"index"</span>;
	&#125;
&#125;</pre></div><p class="paragraph"/>Now to use a custom mapper context in our application we must override the newMapperContext() method declared in the Application class and make it return our custom implementation of IMapperContext:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> IMapperContext newMapperContext() &#123;
	<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> CustomMapperContext();
&#125;</pre></div><p class="paragraph"/><h3>Controlling how page parameters are encoded with IPageParametersEncoder</h3><p class="paragraph"/>Some request mappers (like MountedMapper and PackageMapper) can delegate page parameters encoding/decoding to interface <code>org.apache.wicket.request.mapper.parameter.IPage ParametersEncoder</code>. This entity exposes two methods: encodePageParameters() and decodePageParameters(): the first  one is invoked to encode page parameters into an URL while the second one extracts parameters from the URL.<p class="paragraph"/>Wicket comes with a built-in implementation of this interface which encodes named page parameters as URL segments using the following pattern: /paramName1/paramValue1/paramName2/param Value2...<p class="paragraph"/>This built-in encoder is <code>org.apache.wicket.request.mapper.parameter.UrlPathPageParametersEncoder</code> class. In the <code>PageParametersEncoderExample</code> project we have manually mounted a <code>MountedMapper</code> that takes as input also an <code>UrlPathPageParametersEncoder</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init() &#123;
	<span class="java&#45;keyword">super</span>.init();
	mount(<span class="java&#45;keyword">new</span> MountedMapper(<span class="java&#45;quote">"/mountedPath"</span>, MountedPage.class, <span class="java&#45;keyword">new</span> UrlPathPageParametersEncoder()));
&#125;</pre></div><p class="paragraph"/>The home page of the project contains just a link to the MountedPage web page. The code of the link and the resulting page URL are:<p class="paragraph"/>Link code:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> Link(<span class="java&#45;quote">"mountedPage"</span>) &#123;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> void onClick() &#123;<p class="paragraph"/>		PageParameters pageParameters = <span class="java&#45;keyword">new</span> PageParameters();
		pageParameters.add(<span class="java&#45;quote">"foo"</span>, <span class="java&#45;quote">"foo"</span>);
		pageParameters.add(<span class="java&#45;quote">"bar"</span>, <span class="java&#45;quote">"bar"</span>);<p class="paragraph"/>		setResponsePage(MountedPage.class, pageParameters);
	&#125;
&#125;);</pre></div><p class="paragraph"/>Generated URL:<p class="paragraph"/><div class="code"><pre>&#60;Application path&#62;/mountedPath/foo/foo/bar/bar?1</pre></div><p class="paragraph"/><h3>Encrypting page URLs</h3><p class="paragraph"/>Sometimes URLs are a double‚Äìedged sword for our site because they can expose too many details about the internal structure of our web application making it more vulnerable to malicious users.<p class="paragraph"/>To avoid this kind of security threat we can use the <code>CryptoMapper</code> request mapper which wraps an existing mapper and encrypts the original URL producing a single encrypted segment:<p class="paragraph"/><img border="0" class="center" src="../img/url-encrypted.png"></img><p class="paragraph"/>Typically, <code>CryptoMapper</code> is registered into a Wicket application as the root request mapper wrapping the default one:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init() &#123;
	<span class="java&#45;keyword">super</span>.init();
	setRootRequestMapper(<span class="java&#45;keyword">new</span> CryptoMapper(getRootRequestMapper(), <span class="java&#45;keyword">this</span>)); 
	//pages and resources must be mounted after we have set CryptoMapper
	mountPage(<span class="java&#45;quote">"/foo/"</span>, HomePage.class);</pre></div><p class="paragraph"/>As pointed out in the code above, pages and resources must be mounted after having set <code>CryptoMapper</code> as root mapper, otherwise the mounted paths will not work.<p class="paragraph"/><blockquote class="warning">
By default <code>CryptoMapper</code> encrypts page URLs with a cipher that might not be strong enough for production environment. Paragraph 21.4 will provide a more detailed description of how Wicket encrypts page URLs and we will see how to use stronger ciphers.
</blockquote>



<h2 id="urls_7">10.7 Summary</h2>
<p class="paragraph"/>Links and URLs are not trivial topics as they may seem and in Wicket they are strictly interconnected. Developers must choose the right trade-off between producing structured URLs and avoiding to make them verbose and vulnerable.<p class="paragraph"/>In this chapter we have explored the tools provided by Wicket to control how URLs are generated. We have started with static URLs for bookmarkable pages and we have seen how to pass parameters to target pages with PageParameters. In the second part of the chapter we focused on mounting pages to a specific path and on controlling how parameters are encoded by Wicket. Finally, we have also seen how to encrypt URLs to prevent security vulnerabilities.


<h1 id="modelsforms">11 Wicket models and forms</h1>
In Wicket the concept of ‚Äúmodel‚Äù is probably the most important topic of the entire framework and it is strictly related to the usage of its components. In addition, models are also an important element for  internationalization, as we will see in paragraph 12.6. However, despite their fundamental role, in Wicket models are not difficult to understand but the best way to learn how they work is to use them with forms. That's why we haven't talked about models so far, and why this chapter discusses these two topics together.


<h2 id="modelsforms_1">11.1 What is a model?</h2>
<p class="paragraph"/>Model is essentially a <a href="http://en.wikipedia.org/wiki/Facade_pattern" target="blank">facade</a> interface which allows components to access and modify their data without knowing any detail about how they are managed or persisted. Every component has at most one related model, while a model can be shared among different components. In Wicket a model is any implementation of the interface <code>org.apache.wicket.model.IModel</code>:<p class="paragraph"/><img border="0" class="center" src="../img/uml-imodel.png"></img><p class="paragraph"/>The IModel interface defines just the methods needed to get and set a data object (getObject() and setObject()), decoupling components from concrete details about the persistence strategy adopted for data. In addition, the level of indirection introduced by models allows access data object only when it is really needed (for example during the rendering phase) and not earlier when it may not be ready to be used.<p class="paragraph"/>Any component can get/set its model as well as its data object using the 4 public shortcut methods listed in the class diagram above. The two methods onModelChanged() and onModelChanging() are triggered by Wicket each time a model is modified: the first one is called after the model has been changed, the second one just before the change occurs. In the examples seen so far we have worked with Label component using its constructor which takes as input two string parameters, the component id and the text to display:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"helloMessage"</span>, <span class="java&#45;quote">"Hello WicketWorld!"</span>));</pre></div><p class="paragraph"/>This constructor internally builds a model which wraps the second string parameter. That's why we didn't mention label model in the previous examples. Here is the code of this constructor:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> Label(<span class="java&#45;keyword">final</span> <span class="java&#45;object">String</span> id, <span class="java&#45;object">String</span> label) &#123;
	<span class="java&#45;keyword">this</span>(id, <span class="java&#45;keyword">new</span> Model&#60;<span class="java&#45;object">String</span>&#62;(label));
&#125;</pre></div><p class="paragraph"/>Class <code>org.apache.wicket.model.Model</code> is a basic implementation of <code>IModel</code>. It can wrap any object that implements the interface java.io.Serializable. The reason of this constraint over data object is that this model is stored in the web session, and we know from chapter 6 that data are stored into session using serialization.<p class="paragraph"/><blockquote class="note">
In general, Wicket models support a detaching capability that allows us to work also with non-serializable objects as data model. We will see the detaching mechanism later in this chapter.
</blockquote><p class="paragraph"/>Just like any other Wicket components, Label provides a constructor that takes as input the component id and the model to use with the component. Using this constructor the previous example becomes:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"helloMessage"</span>, <span class="java&#45;keyword">new</span> Model&#60;<span class="java&#45;object">String</span>&#62;(<span class="java&#45;quote">"Hello WicketWorld!"</span>)));</pre></div><p class="paragraph"/><blockquote class="note">
The Model class comes with a bunch of factory methods that makes it easier to build new model instances. For example the of(T object) method creates a new instance of Model which wraps any Object instance inside it. So instead of writing<p class="paragraph"/>	new Model&#60;String&#62;("Hello WicketWorld!")<p class="paragraph"/>we can write<p class="paragraph"/>	Model.of("Hello WicketWorld!")<p class="paragraph"/>If the data object is a List, a Map or a Set we can use similar methods called ofList, ofMap and ofSet.   
From now on we will use these factory methods in our examples.
</blockquote><p class="paragraph"/>It's quite clear that if our Label must display a static text it doesn't make much sense to build a model by hand like we did in the last code example.
However is not unusual to have a Label that must display a dynamic value, like the input provided by a user or a value read from a database. Wicket models are designed to solve these kinds of problems.<p class="paragraph"/>Let's say we need a label to display the current time stamp each time a page is rendered. We can implement a custom model which returns a new Date instance when the getObject() method is called:<p class="paragraph"/><div class="code"><pre>IModel timeStampModel = <span class="java&#45;keyword">new</span> Model&#60;<span class="java&#45;object">String</span>&#62;()&#123;
	@Override
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getObject() &#123;
		<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> Date().toString();
	&#125;
&#125;;<p class="paragraph"/>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"timeStamp"</span>, timeStampModel));</pre></div><p class="paragraph"/>Even if sometimes writing a custom model could be a good choice to solve a specific problem, Wicket already provides a set of IModel implementations which should fit most of our needs. In the next paragraph we will see a couple of models that allow us to easily integrate JavaBeans with our web applications and in particular with our forms.<p class="paragraph"/><blockquote class="note">
By default the class Component escapes HTML sensitive characters (like '&#60;', '&#62;' or '&#38;') from the textual representation of its model object. The term 'escape' means that these characters will be replaced with their corresponding HTML <a href="http://en.wikipedia.org/wiki/Character_entity_reference" target="blank">entity</a> (for example '&#60;' becomes '&#38;lt; '). This is done for security reasons as a malicious user could attempt to inject markup or JavaScript into our pages. If we want to display the raw content stored inside a model, we can tell the Component class not to escape characters by calling the setEscapeModelStrings(false) method.
</blockquote>



<h2 id="modelsforms_2">11.2 Models and JavaBeans</h2>
<p class="paragraph"/>One of the main goals of Wicket is to use JavaBeans and POJO as data model, overcoming the impedance mismatch between web technologies and OO paradigm. In order to make this task as easy as possible, Wicket offers two special model classes: <code>org.apache.wicket.model.PropertyModel</code> and <code>org.apache.wicket.model.CompoundPropertyModel</code>. We will see how to use them in the next two examples, using the following JavaBean as the data object:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class Person <span class="java&#45;keyword">implements</span> Serializable &#123;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> name;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> surname;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> address;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> email;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> passportCode;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> Person spouse;
	<span class="java&#45;keyword">private</span> List&#60;Person&#62; children;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> Person(<span class="java&#45;object">String</span> name, <span class="java&#45;object">String</span> surname) &#123;
		<span class="java&#45;keyword">this</span>.name = name;
		<span class="java&#45;keyword">this</span>.surname = surname;
	&#125;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getFullName()&#123;
   		<span class="java&#45;keyword">return</span> name + <span class="java&#45;quote">" "</span> + surname;
	&#125;<p class="paragraph"/>	/&#42; 	 
	 &#42; Getters and setters <span class="java&#45;keyword">for</span> <span class="java&#45;keyword">private</span> fields
     &#42;/
&#125;</pre></div><p class="paragraph"/><h3>PropertyModel</h3><p class="paragraph"/>Let's say we want to display the name field of a Person instance with a label. We could, of course, use the Model class like we did in the previous example, obtaining something like this:<p class="paragraph"/><div class="code"><pre>Person person = <span class="java&#45;keyword">new</span> Person();		
//load person's data...<p class="paragraph"/>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"name"</span>, <span class="java&#45;keyword">new</span> Model(person.getName()));</pre></div><p class="paragraph"/>However this solution has a huge drawback: the text displayed by the label will be static and if we change the value of the field, the label won't update its content. Instead, to always display the current value of a class field, we should use the <code>org.apache.wicket.model.PropertyModel</code> model class:<p class="paragraph"/><div class="code"><pre>Person person = <span class="java&#45;keyword">new</span> Person();		
//load person's data...<p class="paragraph"/>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"name"</span>, <span class="java&#45;keyword">new</span> PropertyModel(person, <span class="java&#45;quote">"name"</span>));</pre></div><p class="paragraph"/>PropertyModel has just one constructor with two parameters: the model object (person in our example) and the name of the property we want to read/write ("name" in our example). This last parameter is called property expression. Internally, methods getObject/setObject use property expression to get/set property's value. To resolve class properties PropertyModel uses class <code>org.apache.wicket.util.lang.Property</code> Resolver which can access any kind of property, private fields included.<p class="paragraph"/>Just like the Java language, property expressions support dotted notation to select sub properties. So if we want to display the name of the Person's spouse we can write:<p class="paragraph"/><div class="code"><pre>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"spouseName"</span>, <span class="java&#45;keyword">new</span> PropertyModel(person, <span class="java&#45;quote">"spouse.name"</span>));</pre></div><p class="paragraph"/><blockquote class="note">
PropertyModel is null-safe, which means we don't have to worry if property expression includes a null value in its path. If such a value is encountered, an empty string will be returned.
</blockquote><p class="paragraph"/>If property is an array or a List, we can specify an index after its name. For example, to display the name of the first child of a Person we can write the following property expression:<p class="paragraph"/><div class="code"><pre>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"firstChildName"</span>, <span class="java&#45;keyword">new</span> PropertyModel(person, <span class="java&#45;quote">"children.0.name"</span>));</pre></div><p class="paragraph"/>Indexes and map keys can be also specified using squared brackets:<p class="paragraph"/><div class="code"><pre>children&#91;0&#93;.name &#8230;
mapField&#91;key&#93;.subfield ...</pre></div><p class="paragraph"/><h3>CompoundPropertyModel and model inheritance</h3><p class="paragraph"/>Class <code>org.apache.wicket.model.CompoundPropertyModel</code> is a particular kind of model which is usually used in conjunction with another Wicket feature called model inheritance. With this feature, when a component needs to use a model but none has been assigned to it, it will search through the whole container hierarchy for a parent with an inheritable model. Inheritable models are those which implement interface <code>org.apache.wicket.model.IComponentInheritedModel</code> and <code>CompoundPropertyModel</code> is one of them. Once a <code>CompoundPropertyModel</code> has been inherited by a component, it will behave just like a PropertyModel using the id of the component as property expression. As a consequence, to make the most of CompoundPropertyModel we must assign it to one of the containers of a given component, rather than directly to the component itself.<p class="paragraph"/>For example if we use CompoundPropertyModel with the previous example (display spouse's name), the code would become like this:<p class="paragraph"/><div class="code"><pre>//set CompoundPropertyModel as model <span class="java&#45;keyword">for</span> the container of the label
setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(person));<p class="paragraph"/>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"spouse.name"</span>);<p class="paragraph"/>add(label);</pre></div><p class="paragraph"/>Note that now the id of the label is equal to the property expression previously used with PropertyModel. Now as a further example let's say we want to extend the code above to display all of the main informations of a person (name, surname, address and email). All we have to do is to add one label for every additional information using the relative property expression as component id:<p class="paragraph"/><div class="code"><pre>//Create a person named 'John Smith'
Person person = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>);
setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(person));<p class="paragraph"/>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"name"</span>));
add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"surname"</span>));
add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"address"</span>));
add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"email"</span>));
add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"spouse.name"</span>));</pre></div><p class="paragraph"/>CompoundPropertyModel can save us a lot of boring coding if we choose the id of components according to properties name. However it's also possible to use this type of model even if the id of a component does not correspond to a valid property expression. The method bind(String property) allows to create a property model from a given CompoundPropertyModel using the provided parameter as property expression. For example if we want to display the spouse's name in a label having "xyz" as id, we can write the following code:<p class="paragraph"/><div class="code"><pre>//Create a person named 'John Smith'
Person person = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>);
CompoundPropertyModel compoundModel;
setDefaultModel(compoundModel = <span class="java&#45;keyword">new</span> CompoundPropertyModel(person));<p class="paragraph"/>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"xyz"</span>, compoundModel.bind(<span class="java&#45;quote">"spouse.name"</span>)));</pre></div><p class="paragraph"/>CompoundPropertyModel are particularly useful when used in combination with Wicket forms, as we will see in the next paragraph.<p class="paragraph"/><blockquote class="note">
Model is referred to as static model because the result of its method getObject is fixed and it is not dynamically evaluated each time the method is called. In contrast, models like PropertyModel and CompoundProperty Model are called dynamic models.
</blockquote>


<h2 id="modelsforms_3">11.3 Wicket forms</h2>
<p class="paragraph"/>Web applications use HTML forms to collect user input and send it to the server. Wicket provides <code>org.apache.wicket.markup.html.form.Form</code> class to handle web forms. This component must be bound to &#60;form&#62; tag. The following snippet shows how to create a very basic Wicket form in a page:<p class="paragraph"/>Html:<p class="paragraph"/><div class="code"><pre>&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
    &#60;input type=<span class="java&#45;quote">"submit"</span> value=<span class="java&#45;quote">"submit"</span>/&#62;
&#60;/form&#62;</pre></div><p class="paragraph"/>
Java code:<p class="paragraph"/><div class="code"><pre>Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>)&#123;
    @Override
    <span class="java&#45;keyword">protected</span> void onSubmit() &#123;
    	<span class="java&#45;object">System</span>.out.println(<span class="java&#45;quote">"Form submitted."</span>);
    &#125;
&#125;;
add(form);</pre></div><p class="paragraph"/>Method onSubmit is called whenever a form has been submitted and it can be overridden to perform custom actions. Please note that a Wicket form can be submitted using a standard HTML submit button which is not mapped to any component (i.e. it does not have a wicket:id attribute). 
In the next chapter we will continue to explore Wicket forms and we will see how to submit forms using special components which implement interface <code>org.apache.wicket.markup.html.form.IFormSubmitter</code>.<p class="paragraph"/><h3>Form and models</h3><p class="paragraph"/>A form should contain some input fields (like text fields, check boxes, radio buttons, drop-down lists, text areas, etc.) to interact with users. Wicket provides an abstraction for all these kinds of elements with component org.apache.wicket.markup.html.form.FormComponent:<p class="paragraph"/><img border="0" class="center" src="../img/uml-form-component.png"></img><p class="paragraph"/>The purpose of FormComponent is to store the corresponding user input into its model when the form is submitted. The form is responsible for mapping input values to the corresponding components, avoiding us the burden of manually synchronizing models with input fields and vice versa.<p class="paragraph"/><h3>Login form</h3><p class="paragraph"/>As first example of interaction between the form and its models, we will build a classic login form which asks for username and password (project LoginForm).<p class="paragraph"/><blockquote class="warning">
The topic of security will be discussed later in chapter 22. The following form is for example purposes only and is not suited for a real application.
If you need to use a login form you should consider to use component <code>org.apache.wicket.authroles.authentication.panel.SignInPanel</code> shipped with Wicket.
</blockquote><p class="paragraph"/>This form needs two text fields, one of which must be a password field. We should also use a label to display the result of login process1. For the sake of simplicity, the login logic is all inside onSubmit and is quite trivial.<p class="paragraph"/>The following is a possible implementation of our form:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class LoginForm <span class="java&#45;keyword">extends</span> Form &#123;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> TextField usernameField;
	<span class="java&#45;keyword">private</span> PasswordTextField passwordField;
	<span class="java&#45;keyword">private</span> Label loginStatus;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> LoginForm(<span class="java&#45;object">String</span> id) &#123;
		<span class="java&#45;keyword">super</span>(id);<p class="paragraph"/>		usernameField = <span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>, Model.of(<span class="java&#45;quote">""</span>));
		passwordField = <span class="java&#45;keyword">new</span> PasswordTextField(<span class="java&#45;quote">"password"</span>, Model.of(<span class="java&#45;quote">""</span>));			
		loginStatus = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"loginStatus"</span>, Model.of(<span class="java&#45;quote">""</span>));<p class="paragraph"/>		add(usernameField);
		add(passwordField);
		add(loginStatus);
	&#125;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">final</span> void onSubmit() &#123;
		<span class="java&#45;object">String</span> username = (<span class="java&#45;object">String</span>)usernameField.getDefaultModelObject();
		<span class="java&#45;object">String</span> password = (<span class="java&#45;object">String</span>)passwordField.getDefaultModelObject();<p class="paragraph"/>		<span class="java&#45;keyword">if</span>(username.equals(<span class="java&#45;quote">"test"</span>) &#38;&#38; password.equals(<span class="java&#45;quote">"test"</span>))
			loginStatus.setDefaultModelObject(<span class="java&#45;quote">"Congratulations!"</span>);
		<span class="java&#45;keyword">else</span>
			loginStatus.setDefaultModelObject(<span class="java&#45;quote">"Wrong username or password!"</span>);			
	&#125;
&#125;</pre></div><p class="paragraph"/>Inside form's constructor we build the three components used in the form and we assign them a model containing an empty string:<p class="paragraph"/><div class="code"><pre>usernameField = <span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>, Model.of(<span class="java&#45;quote">""</span>));
passwordField = <span class="java&#45;keyword">new</span> PasswordTextField(<span class="java&#45;quote">"password"</span>, Model.of(<span class="java&#45;quote">""</span>));			
loginStatus = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"loginStatus"</span>, Model.of(<span class="java&#45;quote">""</span>));</pre></div><p class="paragraph"/>If we don't provide a model to a form component, we will get the following exception on form submission:<p class="paragraph"/><div class="code"><pre>java.lang.IllegalStateException: Attempt to set model object on <span class="java&#45;keyword">null</span> model of component:</pre></div><p class="paragraph"/>Component TextField corresponds to the standard text field, without any particular behavior or restriction on the allowed values. We must bind this component to the &#60;input&#62; tag with the attribute type set to "text". PasswordTextField is a subtype of TextFiled and it must be used with an &#60;input&#62; tag with the attribute type set to"password". For security reasons component PasswordTextField cleans its value at each request, so it wil be always empty after the form has been rendered. By default PasswordTextField fields are required, meaning that if we left them empty, the form won't be submitted (i.e. onSubmit won't be called). Class FormComponent provides method setRequired(boolean required) to change this behavior. Inside onSubmit, to get/set model objects we have used shortcut methods setDefaultModelObject and getDefaultModelObject. Both methods are defined in class Component (see class diagram from Illustration 9.1).<p class="paragraph"/>The following are the possible markup and code for the login page:<p class="paragraph"/>Html:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
	&#60;head&#62;
  		&#60;title&#62;Login page&#60;/title&#62;
	&#60;/head&#62;
	&#60;body&#62;
		&#60;form id=<span class="java&#45;quote">"loginForm"</span> method=<span class="java&#45;quote">"get"</span> wicket:id=<span class="java&#45;quote">"loginForm"</span>&#62;
  			&#60;fieldset&#62;
    			&#60;legend style=<span class="java&#45;quote">"color: &#35;F90"</span>&#62;Login&#60;/legend&#62;
    				&#60;p wicket:id=<span class="java&#45;quote">"loginStatus"</span>&#62;&#60;/p&#62;
    				&#60;span&#62;Username: &#60;/span&#62;&#60;input wicket:id=<span class="java&#45;quote">"username"</span> type=<span class="java&#45;quote">"text"</span> id=<span class="java&#45;quote">"username"</span> /&#62;&#60;br/&#62;
    				&#60;span&#62;Password: &#60;/span&#62;&#60;input wicket:id=<span class="java&#45;quote">"password"</span> type=<span class="java&#45;quote">"password"</span> id=<span class="java&#45;quote">"password"</span> /&#62;
    				&#60;p&#62;
    					&#60;input type=<span class="java&#45;quote">"submit"</span> name=<span class="java&#45;quote">"Login"</span> value=<span class="java&#45;quote">"Login"</span>/&#62;
    				&#60;/p&#62;
  	   	    &#60;/fieldset&#62;
		&#60;/form&#62;
	&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;<p class="paragraph"/>		<span class="java&#45;keyword">super</span>(parameters);
    	add(<span class="java&#45;keyword">new</span> LoginForm(<span class="java&#45;quote">"loginForm"</span>));<p class="paragraph"/>    &#125;
&#125;</pre></div><p class="paragraph"/>The example shows how Wicket form components can be used to store user input inside their model. However we can dramatically improve the form code using CompoundPropertyModel and its ability to access the properties of its model object. The revisited code is the following (the LoginFormRevisited project):<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class LoginForm <span class="java&#45;keyword">extends</span> Form&#123;<p class="paragraph"/>		<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> username;
		<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> password;
		<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> loginStatus;<p class="paragraph"/>		<span class="java&#45;keyword">public</span> LoginForm(<span class="java&#45;object">String</span> id) &#123;
			<span class="java&#45;keyword">super</span>(id);			
			setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(<span class="java&#45;keyword">this</span>));<p class="paragraph"/>			add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>));
			add(<span class="java&#45;keyword">new</span> PasswordTextField(<span class="java&#45;quote">"password"</span>));
			add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"loginStatus"</span>));
		&#125;<p class="paragraph"/>		<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">final</span> void onSubmit() &#123;			
			<span class="java&#45;keyword">if</span>(username.equals(<span class="java&#45;quote">"test"</span>) &#38;&#38; password.equals(<span class="java&#45;quote">"test"</span>))
				loginStatus = <span class="java&#45;quote">"Congratulations!"</span>;
			<span class="java&#45;keyword">else</span>
				loginStatus = <span class="java&#45;quote">"Wrong username or password !"</span>;			
		&#125;
	&#125;</pre></div><p class="paragraph"/>In this version the form itself is used as model object for its CompoundPropertyModel. This allows children components to have direct access to form fields and use them as backing objects, without explicitly creating a model for themselves.<p class="paragraph"/><blockquote class="note">
Keep in mind that when CompoundPropertyModel is inherited, it does not consider the ids of traversed containers for the final property expression, but it will always use the id of the visited child. To understand this potential pitfall, let's consider the following initialization code of a page:<p class="paragraph"/><div class="code"><pre>//Create a person named 'John Smith'
Person person = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>);
//Create a person named 'Jill Smith'
Person spouse = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"Jill"</span>, <span class="java&#45;quote">"Smith"</span>);
//Set Jill as John's spouse
person.setSpouse(spouse);<p class="paragraph"/>setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(person));
WebMarkupContainer spouseContainer = <span class="java&#45;keyword">new</span> WebMarkupContainer(<span class="java&#45;quote">"spouse"</span>);
Label name;
spouseContainer.add(name = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"name"</span>));<p class="paragraph"/>add(spouseContainer);</pre></div><p class="paragraph"/>The value displayed by label "name" will be "John" and not the spouse's name  "Jill" as you may expect. In this example the label doesn't own a model, so it must search up its container hierarchy for an inheritable model. However, its container (WebMarkup Container with id 'spouse') doesn't own a model, hence the request for a model is forwarded to the parent container, which in this case is the page. In the end the label inherits CompoundPropertyModel from page but only its own id is used for the property expression. The containers in between are never taken into account for the final property expression.
</blockquote>



<h2 id="modelsforms_4">11.4 Component DropDownChoice</h2>
<p class="paragraph"/>Class <code>org.apache.wicket.markup.html.form.DropDownChoice</code> is the form component needed to display a list of possible options as a drop-down list where users can select one of the proposed options. This component must be used with &#60;select&#62; tag:<p class="paragraph"/>Html:<p class="paragraph"/><div class="code"><pre>&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
	Select a fruit: &#60;select wicket:id=<span class="java&#45;quote">"fruits"</span>&#62;&#60;/select&#62;
&#60;div&#62;&#60;input type=<span class="java&#45;quote">"submit"</span> value=<span class="java&#45;quote">"submit"</span>/&#62;&#60;/div&#62;
&#60;/form&#62;</pre></div><p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre>List&#60;<span class="java&#45;object">String</span>&#62; fruits = Arrays.asList(<span class="java&#45;quote">"apple"</span>, <span class="java&#45;quote">"strawberry"</span>, <span class="java&#45;quote">"watermelon"</span>); 
form.add(<span class="java&#45;keyword">new</span> DropDownChoice&#60;<span class="java&#45;object">String</span>&#62;(<span class="java&#45;quote">"fruits"</span>, <span class="java&#45;keyword">new</span> Model(), fruits));</pre></div><p class="paragraph"/>Screenshot of generated page:<p class="paragraph"/><img border="0" class="center" src="../img/dropdown-choice.png"></img><p class="paragraph"/>In addition to the component id, in order to build a DropDownChoice we need to provide to its constructor two further parameters:
<ul class="star">
<li>a model containing the current selected item. This parameter is not required if we are going to inherit a CompoundPropertyModel for this component.</li>
<li>a list of options to display which can be supplied as a model or as a regular java.util.List.</li>
</ul><p class="paragraph"/>In the example above the possible options are provided as a list of String objects. Now let's take a look at the markup generated for them:<p class="paragraph"/><div class="code"><pre>&#60;select name=<span class="java&#45;quote">"fruits"</span> wicket:id=<span class="java&#45;quote">"fruits"</span>&#62;
	&#60;option value=<span class="java&#45;quote">""</span> selected=<span class="java&#45;quote">"selected"</span>&#62;Choose One&#60;/option&#62;
	&#60;option value=<span class="java&#45;quote">"0"</span>&#62;apple&#60;/option&#62;
	&#60;option value=<span class="java&#45;quote">"1"</span>&#62;strawberry&#60;/option&#62;
	&#60;option value=<span class="java&#45;quote">"2"</span>&#62;watermelon&#60;/option&#62;
&#60;/select&#62;</pre></div><p class="paragraph"/>The first option is a placeholder item corresponding to a null model value. By default DropDownChoice cannot have a null value so users are forced to select a not-null option. If we want to change this behavior we can set the nullValid flag to true via the setNullValid method. Please note that the placeholder text (‚ÄúChose one‚Äù) can be localized, as we will see in chapter 15. The other options are identified by the attribute value. By default the value of this attribute is the index of the single option inside the provided list of choices, while the text displayed to the user is obtained by  calling toString()on the choice object. This default behavior works fine as long as our options are simple objects like strings, but when we move to more complex objects we may need to implement a more sophisticated algorithm to generate the value to use as the option id and the one to display to user. Wicket has solved this problem with <code>org.apache.wicket.markup.html.form.IChoiceRender</code> interface. This interface defines method getDisplayValue(T object) that is called to generate the value to display for the given choice object, and method getIdValue(T object, int index) that is called to generate the option id. The built-in implementation of this interface is class <code>org.apache.wicket.markup.html.form.ChoiceRenderer</code> which renders the two values using property expressions.<p class="paragraph"/>In the following code we want to show a list of Person objects using their full name as value to display and using their passport code as option id:<p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre>List&#60;Person&#62; persons; 
//Initialize the list of persons here&#8230;
ChoiceRenderer personRenderer = <span class="java&#45;keyword">new</span> ChoiceRenderer(<span class="java&#45;quote">"fullName"</span>, <span class="java&#45;quote">"passportCode"</span>);
form.add(<span class="java&#45;keyword">new</span> DropDownChoice&#60;<span class="java&#45;object">String</span>&#62;(<span class="java&#45;quote">"persons"</span>, <span class="java&#45;keyword">new</span> Model&#60;Person&#62;(), persons, personRenderer));</pre></div><p class="paragraph"/>The choice renderer can be assigned to the DropDownChoice using one of its constructor that accepts this type of parameter (like we did in the example above) or after its creation invoking setChoiceRenderer method.


<h2 id="modelsforms_5">11.5 Model chaining</h2>
<p class="paragraph"/>Models that implement the interface <code>org.apache.wicket.model.IChainingModel</code> can be used to build a chain of models. These kinds of models are able to recognize whether their model object is itself an implementation of IModel and if so, they will call getObject on the wrapped model and the returned value will be the actual model object. In this way we can combine the action of an arbitrary number of models, making exactly a chain of models. Chaining models allows to combine different data persistence strategies, similarly to what we do with chains of <a href="http://java.sun.com/developer/technicalArticles/Streams/ProgIOStreams" target="blank">I/O streams.</a> To see model chaining in action we will build a page that implements the List/Detail View pattern, where we have a drop-down list of Person objects and a form to display and edit the data of the current selected Person.<p class="paragraph"/>The example page will look like this:<p class="paragraph"/><img border="0" class="center" src="../img/model-chaining.png"></img><p class="paragraph"/>What we want to do in this example is to chain the model of the DropDownChoice (which contains the selected Person) with the model of the Form. In this way the Form will work with the selected Person as backing object. The DropDownChoice component can be configured to automatically update its model each time we change the selected item on the client side. All we have to do is to override method wantOnSelectionChangedNotifications to make it return true. In practice, when this method returns true, DropDownChoice will submit its value every time JavaScript event onChange occurs, and its model will be consequently updated. To leverage this functionality, DropDownChoice doesn't need to be inside a form.<p class="paragraph"/>The following is the resulting markup of the example page:<p class="paragraph"/><div class="code"><pre>&#8230;
&#60;body&#62;
	List of persons &#60;select wicket:id=<span class="java&#45;quote">"persons"</span>&#62;&#60;/select&#62; &#60;br/&#62;
	&#60;br/&#62;
	&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;		
		&#60;div style=<span class="java&#45;quote">"display: table;"</span>&#62;
			&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Name: &#60;/div&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
					&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"name"</span>/&#62; 
				&#60;/div&#62;	
			&#60;/div&#62;
			&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Surname: &#60;/div&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
									&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"surname"</span>/&#62;
								&#60;/div&#62;	
							&#60;/div&#62;
							&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
								&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Address: &#60;/div&#62;
								&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
									&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"address"</span>/&#62;
								&#60;/div&#62;	
							&#60;/div&#62;
							&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
								&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Email: &#60;/div&#62;
								&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
									&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"email"</span>/&#62;
								&#60;/div&#62;
							&#60;/div&#62;
						&#60;/div&#62;	
						&#60;input type=<span class="java&#45;quote">"submit"</span> value=<span class="java&#45;quote">"Save"</span>/&#62;
					&#60;/form&#62;
				&#60;/body&#62;</pre></div><p class="paragraph"/>The initialization code for DropDownChoice is the following:<p class="paragraph"/><div class="code"><pre>Model&#60;Person&#62; listModel = <span class="java&#45;keyword">new</span> Model&#60;Person&#62;();
ChoiceRenderer&#60;Person&#62; personRender = <span class="java&#45;keyword">new</span> ChoiceRenderer&#60;Person&#62;(<span class="java&#45;quote">"fullName"</span>);
personsList = <span class="java&#45;keyword">new</span> DropDownChoice&#60;Person&#62;(<span class="java&#45;quote">"persons"</span>, listModel, loadPersons(), personRender)&#123;<p class="paragraph"/>		@Override
		<span class="java&#45;keyword">protected</span> <span class="java&#45;object">boolean</span> wantOnSelectionChangedNotifications() &#123;
			<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">true</span>;
		&#125;<p class="paragraph"/>&#125;;</pre></div><p class="paragraph"/>As choice render we have used the basic implementation provided with the org.apache.wicket .markup.html.form.ChoiceRenderer class that we have seen in the previous paragraph. loadPersons() is just an utility method which generates a list of Person instances. The model for DropDownChoice is a simple instance of the Model class.<p class="paragraph"/>Here is the whole code of the page (except for the loadPersons() method):<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class PersonListDetails <span class="java&#45;keyword">extends</span> WebPage &#123;
  <span class="java&#45;keyword">private</span> Form form;
  <span class="java&#45;keyword">private</span> DropDownChoice&#60;Person&#62; personsList;<p class="paragraph"/>  <span class="java&#45;keyword">public</span> PersonListDetails()&#123;
    Model&#60;Person&#62; listModel = <span class="java&#45;keyword">new</span> Model&#60;Person&#62;();
    ChoiceRenderer&#60;Person&#62; personRender = <span class="java&#45;keyword">new</span> ChoiceRenderer&#60;Person&#62;(<span class="java&#45;quote">"fullName"</span>);<p class="paragraph"/>    personsList = <span class="java&#45;keyword">new</span> DropDownChoice&#60;Person&#62;(<span class="java&#45;quote">"persons"</span>, listModel, loadPersons(),
                                                         personRender)&#123;
      @Override
      <span class="java&#45;keyword">protected</span> <span class="java&#45;object">boolean</span> wantOnSelectionChangedNotifications() &#123;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">true</span>;
      &#125;
	    &#125;;<p class="paragraph"/>	    add(personsList);<p class="paragraph"/>	    form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>, <span class="java&#45;keyword">new</span> CompoundPropertyModel&#60;Person&#62;(listModel));    
	    form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"name"</span>));
	    form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"surname"</span>));
	    form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"address"</span>));
	    form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"email"</span>));<p class="paragraph"/>	    add(form);
	  &#125;
	       //loadPersons()
	       //&#8230;
	&#125;</pre></div><p class="paragraph"/>The two models work together as a pipeline where the output of method getObject of Model is the model object of CompoundPropertyModel. As we have seen, model chaining allows us to combine the actions of two or more models without creating new custom implementations.


<h2 id="modelsforms_6">11.6 Detachable models</h2>
<p class="paragraph"/>In chapter 6 we have seen how Wicket uses serialization to store page instances. When an object is serialized, all its referenced objects are recursively serialized. For a page this means that all its children components, their related models as well as the model objects inside them will be serialized. 
For model objects this could be a serious issue for (at least) two main reasons:
<ol>
<li>The model object could be a very large instance, hence serialization would become very expensive in terms of time and memory.</li>
<li>We simply may not be able to use a serializable object as model object. In paragraphs 1.4 and 9.2 we stated that Wicket allows us to use a POJO as backing object, but <a href="http://en.wikipedia.org/wiki/Plain_Old_Java_Object#Definition" target="blank">POJOs</a> are ordinary objects with no prespecified interface, annotation or superclass, hence they are not required to implement the standard Serializable interface.</li>
</ol><p class="paragraph"/>To cope with these problems IModel extends another interface called IDetachable.<p class="paragraph"/><img border="0" class="center" src="../img/detachable-models.png"></img><p class="paragraph"/>This interface provides a method called detach() which is invoked by Wicket at the end of web request processing when data model is no more needed but before serialization occurs. Overriding this method we can clean any reference to data object keeping just the information needed to retrieve it later (for example the id of the table row where our data are stored). In this way we can avoid the serialization of the object wrapped into the model overcoming both the problem with non-serializable objects and the one with large data objects.<p class="paragraph"/>Since IModel inherits from IDetachable, every model of Wicket is ‚Äúdetachable‚Äù, although not all of them implement a detaching policy (like the Model class). 
Usually detaching operations are strictly dependent on the persistence technology adopted for model objects (like a relational db, a NoSQL db, a queue, etc), so it's not unusual to write a custom detachable model suited for the persistence technology chosen for a given project. To ease this task Wicket provides abstract model LoadableDetachableModel. This class internally holds a transient reference to a model object which is initialized the first time getObject()is called to precess a request. The concrete data loading is delegated to abstract method T load(). The reference to a model object is automatically set to null at the end of the request by the detach() method.<p class="paragraph"/>The following class diagram summarizes the methods defined inside LoadableDetachableModel.<p class="paragraph"/><img border="0" class="center" src="../img/loadable-detachable-model.png"></img><p class="paragraph"/>onDetach and onAttach can be overridden in order to obtain further control over the detaching procedure.<p class="paragraph"/>Now as example of a possible use of LoadableDetachableModel, we will build a model designed to work with entities managed via <a href="http://en.wikipedia.org/wiki/Java_Persistence_API" target="blank">JPA.</a> To understand the following code a basic knowledge of JPA is required even if we won't go into the detail of this standard.<p class="paragraph"/><blockquote class="warning">
The following model is provided for example purposes only and is not intended to be used in production environment. Important aspects such as transaction management are not taken into account and you should rework the code before considering to use it.
</blockquote><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class JpaLoadableModel&#60;T&#62; <span class="java&#45;keyword">extends</span> LoadableDetachableModel&#60;T&#62; &#123;<p class="paragraph"/>  <span class="java&#45;keyword">private</span> EntityManagerFactory entityManagerFactory;
  <span class="java&#45;keyword">private</span> <span class="java&#45;object">Class</span>&#60;T&#62; entityClass;
  <span class="java&#45;keyword">private</span> Serializable identifier;
  <span class="java&#45;keyword">private</span> List&#60;<span class="java&#45;object">Object</span>&#62; constructorParams;<p class="paragraph"/>  <span class="java&#45;keyword">public</span> JpaLoadableModel(EntityManagerFactory entityManagerFactory, T entity) &#123;<p class="paragraph"/>	<span class="java&#45;keyword">super</span>();<p class="paragraph"/>	PersistenceUnitUtil util = entityManagerFactory.getPersistenceUnitUtil();<p class="paragraph"/>		<span class="java&#45;keyword">this</span>.entityManagerFactory = entityManagerFactory;
	    <span class="java&#45;keyword">this</span>.entityClass = (<span class="java&#45;object">Class</span>&#60;T&#62;) entity.getClass();
	    <span class="java&#45;keyword">this</span>.identifier = (Serializable) util.getIdentifier(entity);<p class="paragraph"/>	    setObject(entity);
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> T load() &#123;
	   T entity = <span class="java&#45;keyword">null</span>;<p class="paragraph"/>	   <span class="java&#45;keyword">if</span>(identifier != <span class="java&#45;keyword">null</span>) &#123;  
	       EntityManager entityManager = entityManagerFactory.createEntityManager();
	       entity = entityManager.find(entityClass, identifier);
	     &#125;
	     <span class="java&#45;keyword">return</span> entity;
	   &#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> void onDetach() &#123;
	   <span class="java&#45;keyword">super</span>.onDetach();<p class="paragraph"/>	     T entity = getObject();
	     PersistenceUnitUtil persistenceUtil = entityManagerFactory.getPersistenceUnitUtil();<p class="paragraph"/>	     <span class="java&#45;keyword">if</span>(entity == <span class="java&#45;keyword">null</span>) <span class="java&#45;keyword">return</span>;<p class="paragraph"/>	     identifier = (Serializable) persistenceUtil.getIdentifier(entity);    
	  &#125;
	&#125;</pre></div><p class="paragraph"/>The constructor of the model takes as input two parameters: an implementation of the JPA interface  javax.persistence.EntityManagerFactory to manage JPA entities and the entity that must be handled by this model. Inside its constructor the model saves the class of the entity and its id (which could be null if the entity has not been persisted yet). These two informations are required to retrieve the entity at a later time and are used by the load method.<p class="paragraph"/>onDetach is responsible for updating the entity id before detachment occurs. The id can change the first time an entity is persisted (JPA generates a new id and assigns it to the entity). Please note that this model is not responsible for saving any changes occurred to the entity object before it is detached. If we don't want to loose these changes we must explicitly persist the entity before the detaching phase occurs.<p class="paragraph"/><blockquote class="warning">
Since the model of this example holds a reference to the EntityManager Factory, the implementation in use must be serializable.
</blockquote>


<h2 id="modelsforms_7">11.7 Using more than one model in a component</h2>
<p class="paragraph"/>Sometimes our custom components may need to use more than a single model to work properly. In such a case we must manually detach the additional models used by our components. In order to do this we can overwrite the Component's onDetach method that is called at the end of the current request. The following is the generic code of a component that uses two models:<p class="paragraph"/><div class="code"><pre>/&#42;&#42;
 &#42; 
 &#42; fooModel is used as main model <span class="java&#45;keyword">while</span> beeModel must be manually detached
 &#42;
 &#42;/
<span class="java&#45;keyword">public</span> class ComponetTwoModels <span class="java&#45;keyword">extends</span> Component&#123;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> IModel&#60;Bee&#62; beeModel;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> ComponetTwoModels(<span class="java&#45;object">String</span> id, IModel&#60;Foo&#62; fooModel, IModel&#60;Bee&#62; beeModel) &#123;
		<span class="java&#45;keyword">super</span>(id, fooModel);
		<span class="java&#45;keyword">this</span>.beeModel = beeModel;
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> void onDetach() &#123;
               <span class="java&#45;keyword">if</span>(beeModel != <span class="java&#45;keyword">null</span>)
	   beeModel.detach();<p class="paragraph"/>              <span class="java&#45;keyword">super</span>.onDetach();
	&#125;
&#125;</pre></div><p class="paragraph"/>When we overwrite onDetach we must call the super class implementation of this method, usually as last line in our custom implementation.


<h2 id="modelsforms_8">11.8 Use models!</h2>
<p class="paragraph"/>Like many people new to Wicket, you may need a little time to fully understand the power and the advantages of using models. Taking your first steps with Wicket you may be tempted to pass row objects to your components instead of using models:<p class="paragraph"/><div class="code"><pre>/&#42;&#42;
 &#42; 
 &#42; NOT TO DO: passing row objects to components instead of using models!
 &#42;
 &#42;/
<span class="java&#45;keyword">public</span> class CustomComponent <span class="java&#45;keyword">extends</span> Component&#123;
	<span class="java&#45;keyword">private</span> FooBean fooBean;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> CustomComponent(<span class="java&#45;object">String</span> id, FooBean fooBean) &#123;
		<span class="java&#45;keyword">super</span>(id);
		<span class="java&#45;keyword">this</span>.fooBean = fooBean;
	&#125;
	//...some other ugly code :)&#8230;
&#125;</pre></div><p class="paragraph"/>That's a bad practice and you must avoid it. Using models we do not only decouple our components from the data source, but we can also relay on them (if they are dynamic) to work with the most up-to-date version of our model object. If we decide to bypass models we lose all these advantages and we force model objects to be serialized.


<h2 id="modelsforms_9">11.9 Summary</h2>
<p class="paragraph"/>Models are at the core of Wicket and they are the basic ingredient needed to taste the real power of the framework. In this chapter we have seen how to use models to bring data to our components without littering their code with technical details about their persistence strategy.
We have also introduced Wicket forms as complementary topic. With forms and models we are able to bring our applications to life allowing them to interact with users. But what we have seen in this chapter about Wicket forms is just the tip of the iceberg. That's why the next chapter is entirely dedicated to them.


<h1 id="forms2">12 Wicket forms in detail</h1>
In the previous chapter we have only scratched the surface of Wicket forms. The Form component was not only designed to collect user input but also to extend the semantic of the classic HTML forms with new features.<p class="paragraph"/>One of such features is the ability to work with nested forms (they will be discussed in <a href="../guide/single.html#forms2_6" class="guide">paragraph 12.6</a>).<p class="paragraph"/>In this chapter we will continue to explore Wicket forms learning how to master them and how to build effective and user-proof forms for our web applications.



<h2 id="forms2_1">12.1 Default form processing</h2>
<p class="paragraph"/>In <a href="../guide/single.html#modelsforms_3" class="guide">paragraph 11.3</a> we have seen a very basic usage of the Form component and we didn't pay much attention to what happens behind the scenes of form submission. In Wicket when we submit a form we trigger the following steps on server side:
<ol>
<li>Form validation: user input is checked to see if it satisfies the validation rules set on the form. If validation fails, step number 2 is skipped and the form should display a feedback message to explain to user what went wrong. During this step input values (which are simple strings sent with a web request) are converted into Java objects. In the next paragraphs we will explore the infrastructures provided by Wicket for the three sub-tasks involved with form validation, which are: conversion of user input into objects, validation of user input, and visualization of feedback messages.</li>
<li>Updating of models: if validation succeeds, the form updates the model of its children components with the converted values obtained in the previous step.</li>
<li>Invoking callback methods onSubmit() or onError(): if we didn't have any validation error, method onSubmit() is called, otherwise onError() will be called. The default implementation of both these methods is left empty and we can override them to perform custom actions.</li>
</ol><p class="paragraph"/><blockquote class="note">
Please note that the model of form components is updated only if no validation error occurred (i.e. step two is performed only if validation succeeds). 
</blockquote><p class="paragraph"/>Without going into too much detail, we can say that the first two steps of form processing correspond to the invocation of one or more Form's internal methods (which are declared protected and final). Some examples of these methods are validate(), which is invoked during validation step, and updateFormComponentModels(), which is used at the step that updates the form field models.<p class="paragraph"/>The whole form processing is started invoking public method process(IFormSubmitter) (Later in <a href="../guide/single.html#forms2_5" class="guide">paragraph 12.5</a> we will introduce interface IFormSubmitter). 



<h2 id="forms2_2">12.2 Form validation and feedback messages</h2>
<p class="paragraph"/>A basic example of a validation rule is to make a field required. In <a href="../guide/single.html#modelsforms_3" class="guide">paragraph 11.3</a> we have already seen how this can be done calling setRequired(true) on a field. However, to set a validation rule on a FormComponent we must add the corresponding validator to it.<p class="paragraph"/>A validator is an implementation of the <code>org.apache.wicket.validation.IValidator</code> interface and the <code>FormComponent</code> has a version of method add which takes as input a reference of this interface.<p class="paragraph"/>For example if we want to use a text field to insert an email address, we could use the built-in validator  EmailAddressValidator to ensure that the inserted input will respect the email format <a href="http://en.wikipedia.org/wiki/Email_address" target="blank">local-part@domain</a> :<p class="paragraph"/><div class="code"><pre>TextField email = <span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"email"</span>);
email.add(EmailAddressValidator.getInstance());</pre></div><p class="paragraph"/>Wicket comes with a set of built-in validators that should suit most of our needs. We will see them later in this chapter.<p class="paragraph"/><h3>Feedback messages and localization</h3><p class="paragraph"/>Wicket generates a feedback message for each field that doesn't satisfy one of its validation rules. For example the message generated when a required field is left empty is the following<p class="paragraph"/><code>Field '&#60;label&#62;' is required.</code><p class="paragraph"/>&#60;label&#62; is the value of the label model set on a FormComponent with method setLabel(IModel &#60;String&#62; model). If such model is not provided, component id will be used as the default value.<p class="paragraph"/>The entire infrastructure of feedback messages is built on top of the Java internationalization (I18N) support and it uses <a href="http://docs.oracle.com/javase/tutorial/i18n/resbundle/index.html" target="blank">resource bundles</a> to store messages.<p class="paragraph"/><blockquote class="note">
The topics of internationalization will be covered in <a href="../guide/single.html#i18n" class="guide">chapter 15</a>. For now we will give just few notions needed to understand the examples from this chapter.
</blockquote><p class="paragraph"/>By default resource bundles are stored into properties files but we can easily configure other sources as described later in <a href="../guide/single.html#i18n_2" class="guide">paragraph 15.2</a>.<p class="paragraph"/>Default feedback messages (like the one above for required fields) are stored in the file Application. properties placed inside Wicket the org.apache.wicket package. Opening this file we can find the key and the localized value of the message:<p class="paragraph"/><code>Required=Field '$&#123;label&#125;' is required.</code><p class="paragraph"/>We can note the key (Required in our case) and the label parameter written in the <a href="http://en.wikipedia.org/wiki/Expression_Language" target="blank">expression language</a> (${label}). Scrolling down this file we can also find the message used by the Email AddressValidator:<p class="paragraph"/><code>EmailAddressValidator=The value of '${label}' is not a valid email address.</code><p class="paragraph"/>By default FormComponent provides 3 parameters for feedback message: input (the value that failed validation), label and name (this later is the id of the component).<p class="paragraph"/><blockquote class="warning">
Remember that component model is updated with the user input only if validation succeeds! As a consequence, we can't retrieve the wrong value inserted for a field from its model. Instead, we should use getValue() method of FormComponent class. (This method will be introduced in the example used later in this chapter)
</blockquote><p class="paragraph"/><h3>Displaying feedback messages and filtering them</h3><p class="paragraph"/>To display feedback messages we must use component <code>org.apache.wicket.markup.html.panel.FeedbackPanel</code>. This component automatically reads all the feedback messages generated during form validation and displays them with an unordered list:<p class="paragraph"/><div class="code"><pre>&#60;ul class=<span class="java&#45;quote">"feedbackPanel"</span>&#62; 
	&#60;li class=<span class="java&#45;quote">"feedbackPanelERROR"</span>&#62; 
		&#60;span class=<span class="java&#45;quote">"feedbackPanelERROR"</span>&#62;Field 'Username' is required.&#60;/span&#62; 
	&#60;/li&#62; 
&#60;/ul&#62;</pre></div><p class="paragraph"/>CSS classes "feedbackPanel" and "feedbackPanelERROR" can be used in order to customize the style of the message list:<p class="paragraph"/><img border="0" class="center" src="../img/feedback-panel-style.png"></img><p class="paragraph"/>The component can be freely placed inside the page and we can set the maximum amount of displayed messages with the setMaxMessages() method.<p class="paragraph"/>Error messages can be filtered using three built-in filters:
<ul class="star">
<li><strong class="bold">ComponentFeedbackMessageFilter</strong>: shows only messages coming from a specific component.</li>
<li><strong class="bold">ContainerFeedbackMessageFilter</strong>: shows only messages coming from a specific container or from any of its children components.</li>
<li><strong class="bold">ErrorLevelFeedbackMessageFilter</strong>: shows only messages with a level of severity equals or greater than a given lower bound. Class FeedbackMessage defines a set of static constants to express different levels of severity: DEBUG, ERROR, WARNING, INFO, SUCCESS, etc.... Levels of severity for feedback messages are discussed later in this chapter.</li>
</ul><p class="paragraph"/>These filters are intended to be used when there are more than one feedback panel (or more than one form) in the same page. We can pass a filter to a feedback panel via its constructor or using the setFilter method. Custom filters can be created implementing the IFeedbackMessageFilter interface. An example of custom filter is illustrated later in this paragraph.<p class="paragraph"/><h3>Built-in validators</h3><p class="paragraph"/>Wicket already provides a number of built-in validators ready to be used. The following table is a short reference where validators are listed along with a brief description of what they do. The default feedback message used by each of them is reported as well:<p class="paragraph"/><h4>EmailAddressValidator</h4><p class="paragraph"/>Checks if input respects the format local-part&#64;domain.<p class="paragraph"/><strong class="bold">Message:</strong><p class="paragraph"/><code>The value of '${label}' is not a valid email address.</code><p class="paragraph"/><h4>UrlValidator</h4><p class="paragraph"/>Checks if input is a valid URL. We can specify in the constructor which protocols are allowed (http://, https://, and ftp://).<p class="paragraph"/><strong class="bold">Message:</strong><p class="paragraph"/><code>The value of '${label}' is not a valid URL.</code><p class="paragraph"/><h4>DateValidator</h4><p class="paragraph"/>Validator class that can be extended or used as a factory class to get date validators to check if a date is bigger than a lower bound (method minimum(Date min)), smaller than a upper bound (method maximum(Date max)) or inside a range (method range(Date min, Date max)).<p class="paragraph"/><strong class="bold">Messages:</strong><p class="paragraph"/><code>The value of '${label}' is less than the minimum of ${minimum}.</code><p class="paragraph"/><code>The value of '${label}' is larger than the maximum of ${maximum}.</code><p class="paragraph"/><code>The value of '${label}' is not between ${minimum} and ${maximum}.</code><p class="paragraph"/><h4>RangeValidator</h4><p class="paragraph"/>Validator class that can be extended or used as a factory class to get validators to check if a value is bigger than a given lower bound (method minimum(T min)), smaller than a upper bound (method maximum(T max)) or inside a range (method range(T min,T max)).<p class="paragraph"/>The type of the value is a generic subtype of java.lang.Comparable and must implement Serializable interface.<p class="paragraph"/><strong class="bold">Messages:</strong><p class="paragraph"/><code>The value of '${label}' must be at least ${minimum}.</code><p class="paragraph"/><code>The value of '${label}' must be at most ${maximum}.</code><p class="paragraph"/><code>The value of '${label}' must be between ${minimum} and ${maximum}.</code><p class="paragraph"/><h4>StringValidator</h4><p class="paragraph"/>Validator class that can be extended or used as a factory class to get validators to check if the length of a string value is bigger then a given lower bound (method minimumLength (int min)), smaller then a given upper bound (method maximumLength (int max)) or within a given range (method lengthBetween(int min, int max)).<p class="paragraph"/>To accept only string values consisting of exactly n characters, we must use method exactLength(int length).<p class="paragraph"/><strong class="bold">Messages:</strong><p class="paragraph"/><code>The value of '${label}' is shorter than the minimum of ${minimum} characters.</code><p class="paragraph"/><code>The value of '${label}' is longer than the maximum of ${maximum} characters.</code><p class="paragraph"/><code>The value of '${label}' is not between ${minimum} and ${maximum} characters long.</code><p class="paragraph"/><code>The value of '${label}' is not exactly ${exact} characters long.</code><p class="paragraph"/><h4>CreditCardValidator</h4><p class="paragraph"/>Checks if input is a valid credit card number. This validator supports some of the most popular credit cards (like ‚ÄúAmerican Express", "MasterCard", ‚ÄúVisa‚Äù or ‚ÄúDiners Club‚Äù).<p class="paragraph"/><strong class="bold">Message:</strong><p class="paragraph"/><code>The credit card number is invalid.</code><p class="paragraph"/><h4>EqualPasswordInputValidator</h4><p class="paragraph"/>This validator checks if two password fields have the same value.<p class="paragraph"/><strong class="bold">Message:</strong><p class="paragraph"/><code>${label0} and ${label1} must be equal.</code><p class="paragraph"/><h3>Overriding standard feedback messages with custom bundles</h3><p class="paragraph"/>If we don't like the default validation feedback messages, we can override them providing custom properties files. In these files we can write our custom messages using the same keys of the messages we want to override. For example if we wanted to override the default message for invalid email addresses, our properties file would contain a line like this:<p class="paragraph"/><code>EmailAddressValidator=Man, your email address is not good!</code><p class="paragraph"/>As we will see in the next chapter, Wicket searches for custom properties files in various positions inside the application's class path, but for now we will consider just the properties file placed next to our application class. The name of this file must be equal to the name of our application class:<p class="paragraph"/><img border="0" class="center" src="../img/custom-properties-file.png"></img><p class="paragraph"/>The example project OverrideMailMessage overrides email validator's message with a new one which also reports the value that failed validation:<p class="paragraph"/><code>EmailAddressValidator=The value '${input}' inserted for field '${label}' is not a valid email address.</code><p class="paragraph"/><img border="0" class="center" src="../img/validation-error-message.png"></img><p class="paragraph"/><h3>Creating custom validators</h3><p class="paragraph"/>If our web application requires a complex validation logic and built-in validators are not enough, we can  implement our own custom validators. For example (project UsernameCustomValidator) suppose we are working on the registration page of our site where users can create their profile choosing their username. Our registration form should validate the new username checking if it was already chosen by another user. In a situation like this we may need to implement a custom validator that queries a specific data source to check if a username is already in use.<p class="paragraph"/>For the sake of simplicity, the validator of our example will check the given username against a fixed list of three existing usernames.<p class="paragraph"/>A custom validator must simply implement interface IValidator:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class UsernameValidator <span class="java&#45;keyword">implements</span> IValidator&#60;<span class="java&#45;object">String</span>&#62; &#123;
	List&#60;<span class="java&#45;object">String</span>&#62; existingUsernames = Arrays.asList(<span class="java&#45;quote">"bigJack"</span>, <span class="java&#45;quote">"anonymous"</span>, <span class="java&#45;quote">"mrSmith"</span>);<p class="paragraph"/>	<span class="java&#45;keyword">public</span> void validate(IValidatable&#60;<span class="java&#45;object">String</span>&#62; validatable) &#123;
		<span class="java&#45;object">String</span> chosenUserName = validatable.getValue();<p class="paragraph"/>		<span class="java&#45;keyword">if</span>(existingUsernames.contains(chosenUserName))&#123;
			ValidationError error = <span class="java&#45;keyword">new</span> ValidationError(<span class="java&#45;keyword">this</span>);
			Random random = <span class="java&#45;keyword">new</span> Random();<p class="paragraph"/>			error.setVariable(<span class="java&#45;quote">"suggestedUserName"</span>, 
					validatable.getValue() + random.nextInt());
			validatable.error(error);
		&#125;
	&#125;	
&#125;</pre></div><p class="paragraph"/>The only method defined inside IValidator is validate(IValidatable&#60;T&#62; validatable) and is invoked during validation's step. Interface IValidatable represents the component being validated and it can be used to retrieve the component model (getModel()) or the value to validate (getValue()).<p class="paragraph"/>The custom validation logic is all inside IValidator's method validate. When validation fails a validator must use IValidatable's method error(IValidationError error) to generate the appropriate feedback message. In the code above we used the ValidationError class as convenience implementation of the IValidationError interface which represents the validation error that must be displayed to the user. This class provides a constructor that uses the class name of the validator in input as key for the resource to use as feedback message (i.e. 'UsernameValidator' in the example). If we want to specify more then one key to use to locate the error message, we can use method addKey(String key) of ValidationError class.<p class="paragraph"/>In our example when validation fails, we suggest a possible username concatenating the given input with a pseudo-random integer. This value is passed to the feedback message with a variable named suggestedUserName. The message is inside application's properties file:<p class="paragraph"/><code>UsernameValidator=The username '${input}' is already in use. Try with '${suggestedUserName}'</code><p class="paragraph"/>To provide further variables to our feedback message we can use method setVariable(String name, Object value) of class ValidationError as we did in our example.<p class="paragraph"/>The code of the home page of the project will be examined in the next paragraph after we have introduced the topic of flash messages.<p class="paragraph"/><h3>Using flash messages</h3><p class="paragraph"/>So far we have considered just the error messages generated during validation step. However Wicket's Component class provides a set of methods to explicitly generate feedback messages called flash messages. These methods are:
<ul class="star">
<li>debug(Serializable message)</li>
<li>info(Serializable message)</li>
<li>success(Serializable message)</li>
<li>warn(Serializable message)</li>
<li>error(Serializable message)</li>
<li>fatal(Serializable message)</li>
</ul><p class="paragraph"/>Each of these methods corresponds to a level of severity for the message. The list above is sorted by increasing level of severity.<p class="paragraph"/>In the example seen in the previous paragraph we have a form which uses success method to notify user when the inserted username is valid. Inside this form there are two FeedbackPanel components: one to display the error message produced by custom validator and the other one to display the success message. The code of the example page is the following:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;body&#62;
	&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
		Username: &#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"username"</span>/&#62;
		&#60;br/&#62;
		&#60;input type=<span class="java&#45;quote">"submit"</span>/&#62;
	&#60;/form&#62;
	&#60;div style=<span class="java&#45;quote">"color:green"</span> wicket:id=<span class="java&#45;quote">"succesMessage"</span>&#62;
	&#60;/div&#62;
	&#60;div style=<span class="java&#45;quote">"color:red"</span> wicket:id=<span class="java&#45;quote">"feedbackMessage"</span>&#62;
	&#60;/div&#62;
&#60;/body&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;	
	Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>)&#123;
		@Override
		<span class="java&#45;keyword">protected</span> void onSubmit() &#123;
			<span class="java&#45;keyword">super</span>.onSubmit();
			success(<span class="java&#45;quote">"Username is good!"</span>);
		&#125;
	&#125;;<p class="paragraph"/>	TextField mail;<p class="paragraph"/>	form.add(mail = <span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>, Model.of(<span class="java&#45;quote">""</span>)));
	mail.add(<span class="java&#45;keyword">new</span> UsernameValidator());<p class="paragraph"/>	add(<span class="java&#45;keyword">new</span> FeedbackPanel(<span class="java&#45;quote">"feedbackMessage"</span>, 
		<span class="java&#45;keyword">new</span> ExactErrorLevelFilter(FeedbackMessage.ERROR)));
	add(<span class="java&#45;keyword">new</span> FeedbackPanel(<span class="java&#45;quote">"succesMessage"</span>, 
		<span class="java&#45;keyword">new</span> ExactErrorLevelFilter(FeedbackMessage.SUCCESS)));<p class="paragraph"/>	add(form);
    &#125;<p class="paragraph"/>    class ExactErrorLevelFilter <span class="java&#45;keyword">implements</span> IFeedbackMessageFilter&#123;
    	<span class="java&#45;keyword">private</span> <span class="java&#45;object">int</span> errorLevel;<p class="paragraph"/>		<span class="java&#45;keyword">public</span> ExactErrorLevelFilter(<span class="java&#45;object">int</span> errorLevel)&#123;
			<span class="java&#45;keyword">this</span>.errorLevel = errorLevel;
		&#125;<p class="paragraph"/>		<span class="java&#45;keyword">public</span> <span class="java&#45;object">boolean</span> accept(FeedbackMessage message) &#123;
			<span class="java&#45;keyword">return</span> message.getLevel() == errorLevel;
		&#125;<p class="paragraph"/>    &#125;
    //UsernameValidator definition
    //&#8230;
&#125;</pre></div><p class="paragraph"/>The two feedback panels must be filtered in order to display just the messages with a given level of severity (ERROR for validator message and SUCCESS for form's flash message). Unfortunately the built-in message filter ErrorLevelFeedbackMessageFilter is not suitable for this task because its filter condition does not check for an exact error level (the given level is used as lower bound value). As a consequence, we had to build a custom filter (inner class ExactErrorLevelFilter) to accept only the desired severity level (see method accept of interface IFeedbackMessageFilter).<p class="paragraph"/><blockquote class="note">
Since version 6.13.0 Wicket provides the additional filter class org.apache.wicket.feedback.ExactLevelFeedbackMessageFilter to accept only feedback messages of a certain error level.
</blockquote><p class="paragraph"/>


<h2 id="forms2_3">12.3 Input value conversion</h2>
<p class="paragraph"/>Working with Wicket we will rarely need to worry about conversion between input values (which are strings because the underlying HTTP protocol) and Java types because in most cases the default conversion mechanism will be smart enough to infer the type of the model object and perform the proper conversion. However, sometimes we may need to work under the hood of this mechanism to make it properly work or to perform custom conversions. That's why this paragraph will illustrate how to control input value conversion.<p class="paragraph"/>The component that is responsible for converting input is the FormComponent itself with its convertInput() method. In order to convert its input a FormComponent must know the type of its model object. This parameter can be explicitly set with method setType(Class&#60;?&#62; type):<p class="paragraph"/><div class="code"><pre>//<span class="java&#45;keyword">this</span> field must receive an integer value
TextField integerField = <span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"number"</span>, <span class="java&#45;keyword">new</span> Model()).setType(<span class="java&#45;object">Integer</span>.class));</pre></div><p class="paragraph"/>If no type has been provided, FormComponent will try to ask its model for this information. The PropertyModel and CompoundPropertyModel models can use reflection to get the type of object model. By default, if FormComponent can not obtain the type of its model object in any way, it will consider it as a simple String.<p class="paragraph"/>Once FormComponent has determined the type of model object, it can look up for a converter, which is the entity in charge of converting input to Java object and vice versa. Converters are instances of <code>org.apache.wicket.util.convert.IConverter</code> interface and are registered by our application class on start up.<p class="paragraph"/>To get a converter for a specific type we must call method getConverter(Class&#60;C&#62; type) on the interface IConverterLocator returned by Application's method getConverterLocator():<p class="paragraph"/><div class="code"><pre>//retrieve converter <span class="java&#45;keyword">for</span> <span class="java&#45;object">Boolean</span> type
Application.get().getConverterLocator().getConverter(<span class="java&#45;object">Boolean</span>.class);</pre></div><p class="paragraph"/><blockquote class="note">
Components which are subclasses of AbstractSingleSelectChoice don't follow the schema illustrated above to convert user input.<p class="paragraph"/>These kinds of components (like DropDownChoice and RadioChoice1) use their choice render and their collection of possible choices to perform input conversion.
</blockquote><p class="paragraph"/><h3>Creating custom application-scoped converters</h3><p class="paragraph"/>The default converter locator used by Wicket is <code>org.apache.wicket.ConverterLocator</code>. This class provides converters for the most common Java types. Here we can see the converters registered inside its constructor:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> ConverterLocator()
&#123;
	set(<span class="java&#45;object">Boolean</span>.TYPE, BooleanConverter.INSTANCE);
	set(<span class="java&#45;object">Boolean</span>.class, BooleanConverter.INSTANCE);
	set(<span class="java&#45;object">Byte</span>.TYPE, ByteConverter.INSTANCE);
	set(<span class="java&#45;object">Byte</span>.class, ByteConverter.INSTANCE);
	set(<span class="java&#45;object">Character</span>.TYPE, CharacterConverter.INSTANCE);
	set(<span class="java&#45;object">Character</span>.class, CharacterConverter.INSTANCE);
	set(<span class="java&#45;object">Double</span>.TYPE, DoubleConverter.INSTANCE);
	set(<span class="java&#45;object">Double</span>.class, DoubleConverter.INSTANCE);
	set(<span class="java&#45;object">Float</span>.TYPE, FloatConverter.INSTANCE);
	set(<span class="java&#45;object">Float</span>.class, FloatConverter.INSTANCE);
	set(<span class="java&#45;object">Integer</span>.TYPE, IntegerConverter.INSTANCE);
	set(<span class="java&#45;object">Integer</span>.class, IntegerConverter.INSTANCE);
	set(<span class="java&#45;object">Long</span>.TYPE, LongConverter.INSTANCE);
	set(<span class="java&#45;object">Long</span>.class, LongConverter.INSTANCE);
	set(<span class="java&#45;object">Short</span>.TYPE, ShortConverter.INSTANCE);
	set(<span class="java&#45;object">Short</span>.class, ShortConverter.INSTANCE);
	set(Date.class, <span class="java&#45;keyword">new</span> DateConverter());
	set(Calendar.class, <span class="java&#45;keyword">new</span> CalendarConverter());
	set(java.sql.Date.class, <span class="java&#45;keyword">new</span> SqlDateConverter());
	set(java.sql.Time.class, <span class="java&#45;keyword">new</span> SqlTimeConverter());
	set(java.sql.Timestamp.class, <span class="java&#45;keyword">new</span> SqlTimestampConverter());
	set(BigDecimal.class, <span class="java&#45;keyword">new</span> BigDecimalConverter());
&#125;</pre></div><p class="paragraph"/>If we want to add more converters to our application, we can override Application's method newConverterLocator which is used by application class to build its converter locator.<p class="paragraph"/>To illustrate how to implement custom converters and use them in our application, we will build a form with two text field: one to input a regular expression pattern and another one to input a string value that will be split with the given pattern.<p class="paragraph"/>The first text field will have an instance of class java.util.regex.Pattern as model object. The final page will look like this (the code of this example is from the CustomConverter project):<p class="paragraph"/><img border="0" class="center" src="../img/regex-form.png"></img><p class="paragraph"/>The conversion between Pattern and String is quite straightforward. The code of our custom converter is the following:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class RegExpPatternConverter <span class="java&#45;keyword">implements</span> IConverter&#60;Pattern&#62; &#123;
	@Override
	<span class="java&#45;keyword">public</span> Pattern convertToObject(<span class="java&#45;object">String</span> value, Locale locale) &#123;
		<span class="java&#45;keyword">return</span> Pattern.compile(value);
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> convertToString(Pattern value, Locale locale) &#123;
		<span class="java&#45;keyword">return</span> value.toString();
	&#125;
&#125;</pre></div><p class="paragraph"/>Methods declared by interface IConverter take as input a Locale parameter in order to deal with locale-sensitive data and conversions. We will learn more about locales and internationalization in <a href="../guide/single.html#i18n" class="guide">paragraph 15</a>.<p class="paragraph"/>Once we have implemented our custom converter, we must override method newConverterLocator() inside our application class and tell it to add our new converter to the default set:<p class="paragraph"/><div class="code"><pre>@Override
	<span class="java&#45;keyword">protected</span> IConverterLocator newConverterLocator() &#123;
		ConverterLocator defaultLocator = <span class="java&#45;keyword">new</span> ConverterLocator();<p class="paragraph"/>		defaultLocator.set(Pattern.class, <span class="java&#45;keyword">new</span> RegExpPatternConverter());<p class="paragraph"/>		<span class="java&#45;keyword">return</span> defaultLocator;
	&#125;</pre></div><p class="paragraph"/>Finally, in the home page of the project we build the form which displays (with a flash message) the tokens obtained splitting the string with the given pattern:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
    <span class="java&#45;keyword">private</span> Pattern regExpPattern;
    <span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> stringToSplit;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;		
    	TextField regExpPatternTxt;
	TextField stringToSplitTxt;<p class="paragraph"/>    	Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>)&#123;
			@Override
			<span class="java&#45;keyword">protected</span> void onSubmit() &#123;
				<span class="java&#45;keyword">super</span>.onSubmit();
				<span class="java&#45;object">String</span> messageResult = <span class="java&#45;quote">"Tokens <span class="java&#45;keyword">for</span> the given string and pattern:&#60;br/&#62;"</span>;
				<span class="java&#45;object">String</span>&#91;&#93; tokens = regExpPattern.split(stringToSplit);<p class="paragraph"/>				<span class="java&#45;keyword">for</span> (<span class="java&#45;object">String</span> token : tokens) &#123;
					messageResult += <span class="java&#45;quote">"&#45; "</span> + token + <span class="java&#45;quote">"&#60;br/&#62;"</span>;
				&#125;				
				success(messageResult);
		&#125;
	&#125;;<p class="paragraph"/>		form.setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(<span class="java&#45;keyword">this</span>));
		form.add(regExpPatternTxt = <span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"regExpPattern"</span>));
		form.add(stringToSplitTxt = <span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"stringToSplit"</span>));
		add(<span class="java&#45;keyword">new</span> FeedbackPanel(<span class="java&#45;quote">"feedbackMessage"</span>).setEscapeModelStrings(<span class="java&#45;keyword">false</span>));<p class="paragraph"/>		add(form);
    &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
If the user input can not be converted to the target type, FormComponent will generate the default error message ‚ÄúThe value of '${label}' is not a valid ${type}.‚Äù. The bundle key for this message is IConverter.
</blockquote>



<h2 id="forms2_4">12.4 Validation with JSR 303</h2>
Standard JSR 303 defines a set of annotations and APIs to validate our domain objects at field-level. Wicket has introduced an experimental support for this standard since version 6.4.0 and with version 6.14.0 it has became an official Wicket module (named <code>wicket-bean-validation</code>).
In this paragraph we will see the basic steps needed to use JSR 303 validation in our Wicket application. Code snippets are from example project <code>JSR303validation</code>.<p class="paragraph"/>In the example application we have a form to insert the data for a new <code>Person</code> bean and its relative <code>Address</code>. The code for class <code>Person</code> is the following<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class Person <span class="java&#45;keyword">implements</span> Serializable&#123;<p class="paragraph"/>	@NotNull
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> name;<p class="paragraph"/>	//regular expression to validate an email address     
	@Pattern(regexp = <span class="java&#45;quote">"^&#91;_A&#45;Za&#45;z0&#45;9&#45;&#93;+(.&#91;_A&#45;Za&#45;z0&#45;9&#45;&#93;+)&#42;&#91;A&#45;Za&#45;z0&#45;9&#45;&#93;+(.&#91;A&#45;Za&#45;z0&#45;9&#45;&#93;+)&#42;((.&#91;A&#45;Za&#45;z&#93;&#123;2,&#125;)&#123;1&#125;$)"</span>)
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> email;<p class="paragraph"/>	@Range(min = 18, max = 150)
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">int</span> age;<p class="paragraph"/>	<code>Past </code>NotNull 
	<span class="java&#45;keyword">private</span> Date birthDay;<p class="paragraph"/>	@NotNull
	<span class="java&#45;keyword">private</span> Address address; 
&#125;</pre></div><p class="paragraph"/>You can note the JSR 303 annotations used in the code above to declare validation constraints on class fields. Class <code>Address</code> has the following code:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class Address <span class="java&#45;keyword">implements</span> Serializable &#123;<p class="paragraph"/>	@NotNull
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> city;<p class="paragraph"/>	@NotNull
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> street;<p class="paragraph"/>	@Pattern(regexp = "&#92;&#92;d+<span class="java&#45;quote">", message = "</span>&#123;address.invalidZipCode&#125;")
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> zipCode;
&#125;</pre></div><p class="paragraph"/>You might have noted that in class <code>Address</code> we have used annotation <code>Pattern using also attribute </code>message<code> which contains the key of the bundle to use for validation message. Our custom bundle is contained inside </code>HomePage.properties@:<p class="paragraph"/><div class="code"><pre>address.invalidZipCode=The inserted zip code is not valid.</pre></div><p class="paragraph"/>To tell Wicket to use JSR 303, we must register bean validator on Application's startup:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class WicketApplication <span class="java&#45;keyword">extends</span> WebApplication &#123;
	@Override
	<span class="java&#45;keyword">public</span> void init()&#123;
		<span class="java&#45;keyword">super</span>.init();<p class="paragraph"/>		<span class="java&#45;keyword">new</span> BeanValidationConfiguration().configure(<span class="java&#45;keyword">this</span>);
	&#125;
&#125;</pre></div><p class="paragraph"/>The last step to harness JSR 303 annotations is to add validator <code>org.apache.wicket.bean.validation.PropertyValidator</code> to our corresponding form components:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
	<span class="java&#45;keyword">super</span>(parameters);<p class="paragraph"/>	setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel&#60;Person&#62;(<span class="java&#45;keyword">new</span> Person()));<p class="paragraph"/>	Form&#60;<span class="java&#45;object">Void</span>&#62; form = <span class="java&#45;keyword">new</span> Form&#60;<span class="java&#45;object">Void</span>&#62;(<span class="java&#45;quote">"form"</span>);<p class="paragraph"/>	form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"name"</span>).add(<span class="java&#45;keyword">new</span> PropertyValidator()));
	form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"email"</span>).add(<span class="java&#45;keyword">new</span> PropertyValidator()));
	form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"age"</span>).add(<span class="java&#45;keyword">new</span> PropertyValidator()));
        //&#8230;
&#125;</pre></div><p class="paragraph"/>Now we can run our application an see that JSR 303 annotations are fully effective:<p class="paragraph"/><img border="0" class="center" src="../img/jsr303-form-validation.png"></img><p class="paragraph"/>


<h2 id="forms2_5">12.5 Submit form with an IFormSubmittingComponent</h2>
<p class="paragraph"/>Besides submitting forms with a standard HTML submit button, Wicket allows us to use special components which implement interface IFormSubmittingComponent. This entity is a subinterface of  IFormSubmitter:<p class="paragraph"/><img border="0" class="center" src="../img/class-diag-IFormSubmittingComponent.png"></img><p class="paragraph"/>At the beginning of this chapter we have seen that form processing is started by process method which takes as input an instance of IFormSubmitter. This parameter corresponds to the IFormSubmittingComponent clicked by a user to submit the form and it is null if we have used a standard HTML submit button (like we have done so far).<p class="paragraph"/>A submitting component is added to a form just like any other child component using method add(Component...).<p class="paragraph"/>A form can have any number of submitting components and we can specify which one among them is the default one by calling the Form's method setDefaultButton(IFormSubmittingComponent ¬†component). The default submitter is the one that will be used when user presses 'Enter' key in a field of the form. In order to make the default button work, Wicket will add to our form a hidden &#60;div&#62; tag containing a text field and a submit button with some JavaScript code to trigger it:<p class="paragraph"/><div class="code"><pre>&#60;div style=<span class="java&#45;quote">"width:0px;height:0px;position:absolute;left:&#45;100px;top:&#45;100px;overflow:hidden"</span>&#62;
	&#60;input type=<span class="java&#45;quote">"text"</span> autocomplete=<span class="java&#45;quote">"off"</span>/&#62;
	&#60;input type=<span class="java&#45;quote">"submit"</span> name=<span class="java&#45;quote">"submit2"</span> onclick=<span class="java&#45;quote">" <span class="java&#45;keyword">var</span> b=document...."</span>/&#62;
&#60;/div&#62;</pre></div><p class="paragraph"/>Just like Wicket forms, interface IFormSubmitter defines methods onSubmit and onError. These two methods have the priority over the namesake methods of the form, meaning that when a form is submitted with an IFormSubmitter, the onSubmit of the submitter is called before the one of the form. Similarly, if validation errors occurs during the first step of form processing, submitter's method onError is called before the form's one.<p class="paragraph"/><blockquote class="note">
Starting with Wicket version 6.0 interface IFormSubmitter defines a further callback method called onAfterSubmit(). This method is called after form's method onSubmit() has been executed.
</blockquote><p class="paragraph"/><h3>Components Button and SubmitLink</h3><p class="paragraph"/>Component <code>org.apache.wicket.markup.html.form.Button</code> is a basic implementation of a form submitter. It can be used with either the &#60;input&#62; or &#60;button&#62; tags. The string model received as input by its constructor is used as button label and it will be the value of the markup attribute value.<p class="paragraph"/>In the following snippet we have a form with two submit buttons bound to an &#60;input&#62; tag. One of them is set as default button and both have a string model for the label:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;body&#62;
	&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
		Username: &#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"username"</span>/&#62;
		&#60;br/&#62;
		&#60;input type=<span class="java&#45;quote">"submit"</span> wicket:id=<span class="java&#45;quote">"submit1"</span>/&#62;
		&#60;input type=<span class="java&#45;quote">"submit"</span> wicket:id=<span class="java&#45;quote">"submit2"</span>/&#62;
	&#60;/form&#62;
&#60;/body&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;		
		Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>);<p class="paragraph"/>	     	form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>, Model.of(<span class="java&#45;quote">""</span>)));
	    	form.add(<span class="java&#45;keyword">new</span> Button(<span class="java&#45;quote">"submit1"</span>, Model.of(<span class="java&#45;quote">"First submitter"</span>)));
		Button secondSubmitter;
		form.add(secondSubmitter = <span class="java&#45;keyword">new</span> Button(<span class="java&#45;quote">"submit2"</span>, Model.of(<span class="java&#45;quote">"Second submitter"</span>)));<p class="paragraph"/>	    	form.setDefaultButton(secondSubmitter);
		add(form);
	&#125;
&#125;</pre></div><p class="paragraph"/><strong class="bold">Generated markup:</strong><p class="paragraph"/><div class="code"><pre>&#60;form wicket:id=<span class="java&#45;quote">"form"</span> id=<span class="java&#45;quote">"form1"</span> method=<span class="java&#45;quote">"post"</span> action=<span class="java&#45;quote">"?0&#45;1.IFormSubmitListener&#45;form"</span>&#62;
   &#60;div&#62;
      &#8230;
      &#60;!&#45;&#45; Code generated by Wicket to handle the <span class="java&#45;keyword">default</span> button &#45;&#45;&#62;
      &#8230;
   &#60;/div&#62;			
   Username: &#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"username"</span> value=<span class="java&#45;quote">""</span> name=<span class="java&#45;quote">"username"</span>/&#62;
   &#60;br/&#62;
   &#60;input type=<span class="java&#45;quote">"submit"</span> wicket:id=<span class="java&#45;quote">"submit1"</span> name=<span class="java&#45;quote">"submit1"</span> id=<span class="java&#45;quote">"submit13"</span> value=<span class="java&#45;quote">"First submitter"</span>/&#62;
   &#60;input type=<span class="java&#45;quote">"submit"</span> wicket:id=<span class="java&#45;quote">"submit2"</span> name=<span class="java&#45;quote">"submit2"</span> id=<span class="java&#45;quote">"submit22"</span> value=<span class="java&#45;quote">"Second submitter"</span>/&#62;
&#60;/form&#62;</pre></div><p class="paragraph"/>Another component that can be used to submit a form is <code>org.apache.wicket.markup.html.form.SubmitLink</code>. This component uses JavaScript to submit the form. Like the name suggests, the component can be used with the &#60;a&#62; tag but it can be also bound to any other tag that supports the event handler onclick. When used with the &#60;a&#62; tag, the JavaScript code needed to submit the form will be placed inside href attribute while with other tags the script will go inside the event handler onclick.<p class="paragraph"/>A notable difference between this component and Button is that SubmitLink can be placed outside the form it must submit. In this case we must specify the form to submit in its constructor:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;html xmlns:wicket=<span class="java&#45;quote">"http://wicket.apache.org"</span>&#62;
	&#60;head&#62;
	&#60;/head&#62;
	&#60;body&#62;
		&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
			Password: &#60;input type=<span class="java&#45;quote">"password"</span> wicket:id=<span class="java&#45;quote">"password"</span>/&#62;
			&#60;br/&#62;					
		&#60;/form&#62;
		&#60;button wicket:id=<span class="java&#45;quote">"externalSubmitter"</span>&#62;
			Submit
		&#60;/button&#62;
	&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;		
		Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>);<p class="paragraph"/>		form.add(<span class="java&#45;keyword">new</span> PasswordTextField(<span class="java&#45;quote">"password"</span>, Model.of(<span class="java&#45;quote">""</span>)));
		//specify the form to submit
		add(<span class="java&#45;keyword">new</span> SubmitLink(<span class="java&#45;quote">"externalSubmitter"</span>, form));
		add(form);
	&#125;
&#125;</pre></div><p class="paragraph"/><h3>Disabling default form processing</h3><p class="paragraph"/>With an IFormSubmittingComponent we can choose to skip the default form submission process  by setting the appropriate flag to false with the setDefaultFormProcessing method. When the default form processing is disabled only the submitter's onSubmit is called while form's validation and models updating are skipped.<p class="paragraph"/>This can be useful if we want to implement a ‚ÄúCancel‚Äù button on our form which redirects user to another page without validating his/her input.<p class="paragraph"/>When we set this flag to false we can decide to manually invoke the form processing by calling the process(IFormSubmittingComponent) method.



<h2 id="forms2_6">12.6 Nested forms</h2>
<p class="paragraph"/>As you might already known, HTLM doesn't allow to have nested forms. However with Wicket we can overcome this limitation by adding one or more form components to a parent form.<p class="paragraph"/>This can be useful if we want to split a big form into smaller ones in order to reuse them and to better distribute responsibilities among different components.
Forms can be nested to an arbitrary level:<p class="paragraph"/><div class="code"><pre>&#60;form wicket:id=<span class="java&#45;quote">"outerForm"</span>&#62; 
	&#8230;
	&#60;form wicket:id=<span class="java&#45;quote">"innerForm"</span>&#62; 
		&#8230;
		&#60;form wicket:id=<span class="java&#45;quote">"veryInnerForm"</span>&#62;
			&#8230;
		&#60;/form&#62; 
	&#60;/form&#62; 
&#60;/form&#62;</pre></div><p class="paragraph"/>When a form is submitted also its nested forms are submitted and they participate in the validation step. This means that if a nested form contains invalid input values, the outer form won't be submitted. On the contrary, nested forms can be singularly submitted without depending on the status of their outer form.<p class="paragraph"/>To submit a parent form when one of its children forms is submitted, we must override its method wantSubmitOnNestedFormSubmit and make it return true. 


<h2 id="forms2_7">12.7 Multi-line text input</h2>
<p class="paragraph"/>HTML provides a multi-line text input control with &#60;textarea&#62; tag. The Wicket counterpart for this kind of control is <code>org.apache.wicket.markup.html.form.TextArea</code> component:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;textarea wicket:id=<span class="java&#45;quote">"description"</span> rows=<span class="java&#45;quote">"5"</span> cols=<span class="java&#45;quote">"40"</span>&#62;&#60;/textarea&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre>form.add(<span class="java&#45;keyword">new</span> TextArea(<span class="java&#45;quote">"description"</span>, Model.of(<span class="java&#45;quote">""</span>)));</pre></div><p class="paragraph"/>Component TextArea is used just like any other single-line text field. To specify the size of the text area we can write attributes rows and cols directly in the markup file or we can create new attribute modifiers and add them to our TextArea component.


<h2 id="forms2_8">12.8 File upload</h2>
<p class="paragraph"/>Wicket supports file uploading with the FileUploadField component which must be used with the &#60;input&#62; tag whose type attribute must be set to "file". In order to send a file on form submission we must enable multipart mode calling MultiPart(true)on our form.<p class="paragraph"/>In the next example (project UploadSingleFile) we will see a form which allows users to upload a file into the temporary directory of the server (path /tmp on Unix/Linux systems):<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
	&#60;head&#62;
	&#60;/head&#62;
	&#60;body&#62;
		&#60;h1&#62;Upload your file here!&#60;/h1&#62;
		&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
			&#60;input type=<span class="java&#45;quote">"file"</span> wicket:id=<span class="java&#45;quote">"fileUploadField"</span>/&#62; 
			&#60;input type=<span class="java&#45;quote">"submit"</span> value=<span class="java&#45;quote">"Upload"</span>/&#62;
		&#60;/form&#62;
		&#60;div wicket:id=<span class="java&#45;quote">"feedbackPanel"</span>&#62;
		&#60;/div&#62;
	&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
	<span class="java&#45;keyword">private</span> FileUploadField fileUploadField;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
	   	fileUploadField = <span class="java&#45;keyword">new</span> FileUploadField(<span class="java&#45;quote">"fileUploadField"</span>);<p class="paragraph"/>		Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>)&#123;
			@Override
			<span class="java&#45;keyword">protected</span> void onSubmit() &#123;
				<span class="java&#45;keyword">super</span>.onSubmit();<p class="paragraph"/>				FileUpload fileUpload = fileUploadField.getFileUpload();<p class="paragraph"/>				<span class="java&#45;keyword">try</span> &#123;
					File file = <span class="java&#45;keyword">new</span> File(<span class="java&#45;object">System</span>.getProperty(<span class="java&#45;quote">"java.io.tmpdir"</span>) + <span class="java&#45;quote">"/"</span> +
					fileUpload.getClientFileName());<p class="paragraph"/>					fileUpload.writeTo(file);
				&#125; <span class="java&#45;keyword">catch</span> (IOException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;;<p class="paragraph"/>		form.setMultiPart(<span class="java&#45;keyword">true</span>);
		//set a limit <span class="java&#45;keyword">for</span> uploaded file's size
		form.setMaxSize(Bytes.kilobytes(100));
		form.add(fileUploadField);
		add(<span class="java&#45;keyword">new</span> FeedbackPanel(<span class="java&#45;quote">"feedbackPanel"</span>));
		add(form);
	&#125;
&#125;</pre></div><p class="paragraph"/>The code that copies the uploaded file to the temporary directory is inside the onSubmit method of the Form class. The uploaded file is handled with an instance of class FileUpload returned by the  getFileUpload() method of the FileUploadField class. This class provides a set of methods to perform some common tasks like getting the name of the uploaded file (getClientFileName()), coping the file into a directory (writeTo(destinationFile)), calculating file digest (getDigest (digestAlgorithm)) and so on.<p class="paragraph"/>Form component can limit the size for uploaded files using its setMaxSize(size) method. In the example we have set this limit to 100 kb to prevent users from uploading files bigger than this size.<p class="paragraph"/><blockquote class="note">
The maximum size for uploaded files can also be set at application's level using the setDefaultMaximumUploadSize(Bytes maxSize) method of class ApplicationSettings:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	getApplicationSettings().setDefaultMaximumUploadSize(Bytes.kilobytes(100));  
&#125;</pre></div>
</blockquote><p class="paragraph"/><h3>Upload multiple files</h3><p class="paragraph"/>If we need to upload multiple files at once and our clients support HTML5, we can still use FileUploadField adding attribute "multiple" to its tag. If we can not rely on HTML5, we can use the MultiFileUploadField component which allows the user to upload an arbitrary number of files using a JavaScript-based solution.
An example showing how to use this component can be found in Wicket module wicket-examples in file MultiUploadPage.java. The live example is hosted at <a href="http://www.wicket-library.com/wicket-examples-6.0.x/upload/multi" target="blank">http://www.wicket-library.com/wicket-examples-6.0.x/upload/multi</a> .



<h2 id="forms2_9">12.9 Creating complex form components with FormComponentPanel</h2>
<p class="paragraph"/>In <a href="../guide/single.html#layout_2" class="guide">chapter 5.2.2</a> we have seen how to use class Panel to create custom components with their own markup and with an arbitrary number of children components.<p class="paragraph"/>While it's perfectly legal to use Panel also to group form components, the resulting component won't be itself a form component and it won't participate in the form's submission workflow.<p class="paragraph"/>This could be a strong limitation if the custom component needs to coordinate its children during sub-tasks like input conversion or model updating. That's why in Wicket we have the <code>org.apache.wicket.markup.html.form.FormComponentPanel</code> component which combines the features of a Panel (it has its own markup file) and a FormComponent (it is a subclass of FormComponent).<p class="paragraph"/>A typical scenario in which we may need to implement a custom FormComponentPanel is when our web application and its users work with different units of measurement for the same data.<p class="paragraph"/>To illustrate this possible scenario, let's consider a form where a user can insert a  temperature that will be recorded after being converted to Kelvin degrees (see the example project CustomForm ComponentPanel).<p class="paragraph"/>The Kelvin scale is wildly adopted among the scientific community and it is one of the seven base units of the <a href="http://en.wikipedia.org/wiki/International_System_of_Units" target="blank">International System of Units</a> , so it makes perfect sense to store temperatures expressed with this unit of measurement.<p class="paragraph"/>However, in our everyday life we still use other temperature scales like Celsius or Fahrenheit, so it would be nice to have a component which internally works with Kelvin degrees and automatically applies conversion between Kelvin temperature scale and the one adopted by the user.<p class="paragraph"/>In order to implement such a component, we can make a subclass of FormComponentPanel and leverage the convertInput and onBeforeRender methods: in the implementation of the convertInput method we will convert input value to Kelvin degrees while in the implementation of onBeforeRender method we will take care of converting the Kelvin value to the temperature scale adopted by the user.<p class="paragraph"/>Our custom component will contain two children components: a text field to let user insert and edit a temperature value and a label to display the letter corresponding to user's temperature scale (F for Fahrenheit and C for Celsius). The resulting markup file is the following:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
&#60;/head&#62;
&#60;body&#62;
	&#60;wicket:panel&#62;
		Registered temperature: &#60;input size=<span class="java&#45;quote">"3"</span> maxlength=<span class="java&#45;quote">"3"</span>         
                             wicket:id=<span class="java&#45;quote">"registeredTemperature"</span>/&#62; 
		&#60;label wicket:id=<span class="java&#45;quote">"mesuramentUnit"</span>&#62;&#60;/label&#62; 
	&#60;/wicket:panel&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>As shown in the markup above FormComponentPanel uses the same &#60;wicket:panel&#62; tag used by Panel to define its markup. Now let's see the Java code of the new form component starting with the onInitialize() method:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class TemperatureDegreeField <span class="java&#45;keyword">extends</span> FormComponentPanel&#60;<span class="java&#45;object">Double</span>&#62; &#123;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> TextField&#60;<span class="java&#45;object">Double</span>&#62; userDegree;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> TemperatureDegreeField(<span class="java&#45;object">String</span> id) &#123;
		<span class="java&#45;keyword">super</span>(id);		
	&#125;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> TemperatureDegreeField(<span class="java&#45;object">String</span> id, IModel&#60;<span class="java&#45;object">Double</span>&#62; model) &#123;
		<span class="java&#45;keyword">super</span>(id, model);		
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> void onInitialize() &#123;
		<span class="java&#45;keyword">super</span>.onInitialize();<p class="paragraph"/>		AbstractReadOnlyModel&#60;<span class="java&#45;object">String</span>&#62; labelModel=<span class="java&#45;keyword">new</span> AbstractReadOnlyModel&#60;<span class="java&#45;object">String</span>&#62;()&#123;
			@Override
			<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getObject() &#123;
				<span class="java&#45;keyword">if</span>(getLocale().equals(Locale.US))
					<span class="java&#45;keyword">return</span> <span class="java&#45;quote">"¬∞F"</span>;
				<span class="java&#45;keyword">return</span> <span class="java&#45;quote">"¬∞C"</span>;
			&#125;
		&#125;;<p class="paragraph"/>		add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"mesuramentUnit"</span>, labelModel));
		add(userDegree=<span class="java&#45;keyword">new</span> TextField&#60;<span class="java&#45;object">Double</span>&#62;(<span class="java&#45;quote">"registeredTemperature"</span>, <span class="java&#45;keyword">new</span> 
                        Model&#60;<span class="java&#45;object">Double</span>&#62;()));
		userDegree.setType(<span class="java&#45;object">Double</span>.class);
	&#125;</pre></div><p class="paragraph"/>Inside the onInitialize method we have created a read-only model for the label that displays the letter corresponding to the user's temperature scale. To determinate which temperature scale is in use, we retrieve the Locale from the session by calling Component's getLocale() method (we will talk more about this method in <a href="../guide/single.html#i18n" class="guide">paragraph 15</a>). Then, if locale is the one corresponding to the United States, the chosen scale will be Fahrenheit, otherwise it will be considered as Celsius.<p class="paragraph"/>In the final part of onInitialize() we add the two components to our custom form component. You may have noticed that we have explicitly set the type of model object for the text field to double. This is necessary as the starting model object is a null reference and this prevents the component from automatically determining the type of its model object.<p class="paragraph"/>Now we can look at the rest of the code containing the convertInput and onBeforeRender methods:<p class="paragraph"/><div class="code"><pre>// continued example
	@Override
	<span class="java&#45;keyword">protected</span> void convertInput() &#123;
		<span class="java&#45;object">Double</span> userDegreeVal = userDegree.getConvertedInput();
		<span class="java&#45;object">Double</span> kelvinDegree;<p class="paragraph"/>		<span class="java&#45;keyword">if</span>(getLocale().equals(Locale.US))&#123;
			kelvinDegree = userDegreeVal +  459.67;
			BigDecimal bdKelvin = <span class="java&#45;keyword">new</span> BigDecimal(kelvinDegree);
			BigDecimal fraction = <span class="java&#45;keyword">new</span> BigDecimal(5).divide(<span class="java&#45;keyword">new</span> BigDecimal(9));<p class="paragraph"/>			kelvinDegree = bdKelvin.multiply(fraction).doubleValue();
		&#125;<span class="java&#45;keyword">else</span>&#123;
			kelvinDegree = userDegreeVal + 273.15;
		&#125;<p class="paragraph"/>		setConvertedInput(kelvinDegree);
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> void onBeforeRender() &#123;
		<span class="java&#45;keyword">super</span>.onBeforeRender();<p class="paragraph"/>		<span class="java&#45;object">Double</span> kelvinDegree = (<span class="java&#45;object">Double</span>) getDefaultModelObject();		
		<span class="java&#45;object">Double</span> userDegreeVal = <span class="java&#45;keyword">null</span>;<p class="paragraph"/>		<span class="java&#45;keyword">if</span>(kelvinDegree == <span class="java&#45;keyword">null</span>) <span class="java&#45;keyword">return</span>;<p class="paragraph"/>		<span class="java&#45;keyword">if</span>(getLocale().equals(Locale.US))&#123;
			BigDecimal bdKelvin = <span class="java&#45;keyword">new</span> BigDecimal(kelvinDegree);
			BigDecimal fraction = <span class="java&#45;keyword">new</span> BigDecimal(9).divide(<span class="java&#45;keyword">new</span> BigDecimal(5));<p class="paragraph"/>			kelvinDegree = bdKelvin.multiply(fraction).doubleValue();
			userDegreeVal = kelvinDegree &#45; 459.67;
		&#125;<span class="java&#45;keyword">else</span>&#123;
			userDegreeVal = kelvinDegree &#45; 273.15;
		&#125;<p class="paragraph"/>		userDegree.setModelObject(userDegreeVal);
	&#125;
&#125;</pre></div><p class="paragraph"/>Since our component does not directly receive the user input, convertInput() must read this value from the inner text field using FormComponent's getConvertedInput() method which returns the input value already converted to the type specified for the component (Double in our case). Once we have the user input we convert it to kelvin degrees and we use the resulting value to set the converted input for our custom component (using method setConvertedInput(T convertedInput)).<p class="paragraph"/>Method onBeforeRender() is responsible for synchronizing the model of the inner textfield with the model of our custom component. To do this we retrieve the model object of the custom component with the getDefaultModelObject() method, then we convert it to the temperature scale adopted by the user and finally we use this value to set the model object of the text field.



<h2 id="forms2_10">12.10 Stateless form</h2>
<p class="paragraph"/>In <a href="../guide/single.html#versioningCaching" class="guide">chapter 8</a> we have seen how Wicket pages can be divided into two categories: stateful and stateless. Pages that are stateless don't need to be stored in the user session and they should be used  when we don't need to save any user data in the user session (for example in the public area of a site).<p class="paragraph"/>Besides saving resources on server-side, stateless pages can be adopted to improve user experience and to avoid security weaknesses. A typical situation where a stateless page can bring these benefits is when we have to implement a login page.<p class="paragraph"/>For this kind of page we might encounter two potential problems if we chose to use a stateful page. The first problem occurs when the user tries to login without a valid session assigned to him. This could happen if the user leaves the login page opened for a period of time bigger than the session's timeout and then he decides to log in. Under these conditions the user will be redirected to a 'Page expired' error page, which is not exactly a nice thing for user experience.<p class="paragraph"/>The second problem occurs when a malicious user or a web crawler program attempts to login into our web application, generating a huge number of page versions and consequently increasing the size of the user session.<p class="paragraph"/>To avoid these kinds of problems we should build a stateless login page which does not depend on a user session. Wicket provides a special version of the Form component called StatelessForm which is stateless by default (i.e its method getStatelessHint() returns true), hence it's an ideal solution when we want to build a stateless page with a form. A possible implementation of our login form is the following (example project StatelessLoginForm):<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
   &#60;head&#62;
      &#60;meta charset=<span class="java&#45;quote">"utf&#45;8"</span> /&#62;
   &#60;/head&#62;
   &#60;body&#62;
      &#60;div&#62;Session is &#60;b wicket:id=<span class="java&#45;quote">"sessionType"</span>&#62;&#60;/b&#62;&#60;/div&#62;
      &#60;br/&#62;
      &#60;div&#62;Type 'user' as correct credentials&#60;/div&#62;
      &#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
         &#60;fieldset&#62;
            Username: &#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"username"</span>/&#62; &#60;br/&#62;
            Password: &#60;input type=<span class="java&#45;quote">"password"</span> wicket:id=<span class="java&#45;quote">"password"</span>/&#62;&#60;br/&#62;
            &#60;input type=<span class="java&#45;quote">"submit"</span>/&#62;
         &#60;/fieldset&#62;
      &#60;/form&#62;
      &#60;br/&#62;
      &#60;div wicket:id=<span class="java&#45;quote">"feedbackPanel"</span>&#62;&#60;/div&#62;
   &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
    <span class="java&#45;keyword">private</span> Label sessionType;
    <span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> password;
    <span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> username;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
       StatelessForm form = <span class="java&#45;keyword">new</span> StatelessForm(<span class="java&#45;quote">"form"</span>)&#123;
         @Override
         <span class="java&#45;keyword">protected</span> void onSubmit() &#123;
            //sign in <span class="java&#45;keyword">if</span> username and password are ‚Äúuser‚Äù
            <span class="java&#45;keyword">if</span>(<span class="java&#45;quote">"user"</span>.equals(username) &#38;&#38; username.equals(password))
               info(<span class="java&#45;quote">"Username and password are correct!"</span>);
            <span class="java&#45;keyword">else</span>
               error(<span class="java&#45;quote">"Wrong username or password"</span>);
         &#125;
      &#125;;<p class="paragraph"/>      form.add(<span class="java&#45;keyword">new</span> PasswordTextField(<span class="java&#45;quote">"password"</span>));
      form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>));<p class="paragraph"/>      add(form.setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(<span class="java&#45;keyword">this</span>)));<p class="paragraph"/>      add(sessionType = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"sessionType"</span>, Model.of(<span class="java&#45;quote">""</span>)));
      add(<span class="java&#45;keyword">new</span> FeedbackPanel(<span class="java&#45;quote">"feedbackPanel"</span>));
    &#125;<p class="paragraph"/>    @Override
    <span class="java&#45;keyword">protected</span> void onBeforeRender() &#123;
       <span class="java&#45;keyword">super</span>.onBeforeRender();<p class="paragraph"/>       <span class="java&#45;keyword">if</span>(getSession().isTemporary())
          sessionType.setDefaultModelObject(<span class="java&#45;quote">"temporary"</span>);
       <span class="java&#45;keyword">else</span>
          sessionType.setDefaultModelObject(<span class="java&#45;quote">"permanent"</span>);
    &#125;
&#125;</pre></div><p class="paragraph"/>Label sessionType shows if current session is temporary or not and is set inside onBeforeRender(): if our page is really stateless the session will be always temporary. We have also inserted a feedback panel in the home page that shows if the credentials are correct. This was done to make the example form more interactive.



<h2 id="forms2_11">12.11 Working with radio buttons and checkboxes</h2>
<p class="paragraph"/>In this paragraph we will see which components can be used to handle HTML radio buttons and checkboxes. Both these input elements are usually grouped together to display a list of possible choices:<p class="paragraph"/><img border="0" class="center" src="../img/choice-form-screenshot.png"></img><p class="paragraph"/>A check box can be used as single component to set a boolean property. For this purpose Wicket provides the <code>org.apache.wicket.markup.html.form.CheckBox</code> component which must be attached to &#60;input type="checkbox".../&#62; tag. In the next example (project SingleCheckBox) we will consider a form similar to the one used in <a href="../guide/single.html#modelsforms_5" class="guide">paragraph 11.5</a> to edit a Person object, but with an additional checkbox to let the user decide if she wants to subscribe to our mailing list or not. The form uses the following bean as backing object:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class RegistrationInfo <span class="java&#45;keyword">implements</span> Serializable &#123;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> name;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> surname;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> address;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> email;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">boolean</span> subscribeList;<p class="paragraph"/>	/&#42;Getters and setters&#42;/
&#125;</pre></div><p class="paragraph"/>The markup and the code for this example are the following:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;		
		&#60;div style=<span class="java&#45;quote">"display: table;"</span>&#62;
			&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Name: &#60;/div&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
					&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"name"</span>/&#62; 
				&#60;/div&#62;	
			&#60;/div&#62;
			&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Surname: &#60;/div&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
					&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"surname"</span>/&#62;
				&#60;/div&#62;	
			&#60;/div&#62;
			&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Address: &#60;/div&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
					&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"address"</span>/&#62;
				&#60;/div&#62;	
			&#60;/div&#62;
			&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Email: &#60;/div&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
					&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"email"</span>/&#62;
				&#60;/div&#62;
			&#60;/div&#62;
			&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Subscribe list:&#60;/div&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
					&#60;input type=<span class="java&#45;quote">"checkbox"</span> wicket:id=<span class="java&#45;quote">"subscribeList"</span>/&#62;
				&#60;/div&#62;
			&#60;/div&#62;
		&#60;/div&#62;	
	&#60;input type=<span class="java&#45;quote">"submit"</span> value=<span class="java&#45;quote">"Save"</span>/&#62;
&#60;/form&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
    	RegistrationInfo registrtionInfo = <span class="java&#45;keyword">new</span> RegistrationInfo();
    	registrtionInfo.setSubscribeList(<span class="java&#45;keyword">true</span>);<p class="paragraph"/>    	Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>, 
    			<span class="java&#45;keyword">new</span> CompoundPropertyModel&#60;RegistrationInfo&#62;(registrtionInfo));<p class="paragraph"/>    	form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"name"</span>));
	form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"surname"</span>));
	form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"address"</span>));
	form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"email"</span>));
	form.add(<span class="java&#45;keyword">new</span> CheckBox(<span class="java&#45;quote">"subscribeList"</span>));<p class="paragraph"/>	add(form);
&#125;</pre></div><p class="paragraph"/>Please note that the checkbox will be initially selected because we have set to true the subscribe flag during the model object creation (with instruction registrtionInfo.setSubscribeList(true)):<p class="paragraph"/><img border="0" class="center" src="../img/subscribe-checkbox-set.png"></img><p class="paragraph"/><h3>Working with grouped checkboxes</h3><p class="paragraph"/>When we need to display a given number of options with checkboxes, we can use the <code>org.apache.wicket.markup.html.form.CheckBoxMultipleChoice</code> component. For example, If our options are a list of strings, we can display them in this way:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;div wicket:id=<span class="java&#45;quote">"checkGroup"</span>&#62;
		&#60;input type=<span class="java&#45;quote">"checkbox"</span>/&#62;It will be replaced by the actual checkboxes&#8230;
&#60;/div&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre>List&#60;<span class="java&#45;object">String</span>&#62; fruits = Arrays.asList(<span class="java&#45;quote">"apple"</span>, <span class="java&#45;quote">"strawberry"</span>, <span class="java&#45;quote">"watermelon"</span>); 
form.add(<span class="java&#45;keyword">new</span> CheckBoxMultipleChoice(<span class="java&#45;quote">"checkGroup"</span>, <span class="java&#45;keyword">new</span> ListModel&#60;<span class="java&#45;object">String</span>&#62;(<span class="java&#45;keyword">new</span>  
								 ArrayList&#60;<span class="java&#45;object">String</span>&#62;()), fruits));</pre></div><p class="paragraph"/><strong class="bold">Screenshot:</strong><p class="paragraph"/><img border="0" class="center" src="../img/grouped-checkbox.png"></img><p class="paragraph"/>This component can be attached to a &#60;div&#62; tag or to a &#60;span&#62; tag. No specific content is required for this tag as it will be populated with the actual checkboxes. Since this component allows multiple selection, its model object is a list. In the example above we have used model class <code>org.apache.wicket.model.util.ListModel</code> which is specifically designed to wrap a List object.<p class="paragraph"/>By default CheckBoxMultipleChoice inserts a &#60;br/&#62; tag as suffix after each option. We can configure both the suffix and the prefix used by the component with the setPrefix and setSuffix methods.<p class="paragraph"/>When our options are more complex objects than simple strings, we can render them using an IChoiceRender, as we did for DropDownChoice in <a href="../guide/single.html#modelsforms_5" class="guide">paragraph 11.5</a>:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;div wicket:id=<span class="java&#45;quote">"checkGroup"</span>&#62;
		&#60;input type=<span class="java&#45;quote">"checkbox"</span>/&#62;It will be replaced by actual checkboxes&#8230;
&#60;/div&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre>Person john = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>);
Person bob = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"Bob"</span>, <span class="java&#45;quote">"Smith"</span>);
Person jill = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"Jill"</span>, <span class="java&#45;quote">"Smith"</span>);
List&#60;Person&#62; theSmiths = Arrays.asList(john, bob, jill); 
ChoiceRenderer render = <span class="java&#45;keyword">new</span> ChoiceRenderer(<span class="java&#45;quote">"name"</span>);
form.add(<span class="java&#45;keyword">new</span> CheckBoxMultipleChoice(<span class="java&#45;quote">"checkGroup"</span>, <span class="java&#45;keyword">new</span> ListModel&#60;<span class="java&#45;object">String</span>&#62;(<span class="java&#45;keyword">new</span> ArrayList&#60;<span class="java&#45;object">String</span>&#62;()),   
                                    theSmiths, render));</pre></div><p class="paragraph"/><strong class="bold">Screenshot:</strong><p class="paragraph"/><img border="0" class="center" src="../img/grouped-checkbox2.png"></img><p class="paragraph"/><h3>How to implement a "Select all" checkbox</h3><p class="paragraph"/>A nice feature we can offer to users when we have a group of checkboxes is a ‚Äúspecial‚Äù checkbox which selects/unselects all the other options of the group:<p class="paragraph"/><img border="0" class="center" src="../img/select-all-checkbox.png"></img><p class="paragraph"/>Wicket comes with a couple of utility components that make it easy to implement such a feature. They are CheckboxMultipleChoiceSelector and CheckBoxSelector classes, both inside package <code>org.apache.wicket.markup.html.form</code>. The difference between these two components is that the first works with an instance of CheckBoxMultipleChoice while the second takes in input a list of CheckBox objects:<p class="paragraph"/><div class="code"><pre>/&#42; CheckboxMultipleChoiceSelector usage: &#42;/<p class="paragraph"/>CheckBoxMultipleChoice checkGroup;
//checkGroup initialization&#8230;
CheckboxMultipleChoiceSelector cbmcs = <span class="java&#45;keyword">new</span> CheckboxMultipleChoiceSelector(<span class="java&#45;quote">"id"</span>, checkGroup);<p class="paragraph"/>/&#42; CheckBoxSelector usage: &#42;/<p class="paragraph"/>CheckBox checkBox1, checkBox2, checkBox3;
//checks initialization&#8230;
CheckBoxSelector cbmcs = <span class="java&#45;keyword">new</span> CheckBoxSelector(<span class="java&#45;quote">"id"</span>, checkBox1, checkBox2, checkBox3);</pre></div><p class="paragraph"/><h3>Working with grouped radio buttons</h3><p class="paragraph"/>For groups of radio buttons we can use the <code>org.apache.wicket.markup.html.form.RadioChoice</code> component which works in much the same way as CheckBoxMultipleChoice:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;div wicket:id=<span class="java&#45;quote">"radioGroup"</span>&#62;
	&#60;input type=<span class="java&#45;quote">"radio"</span>/&#62;It will be replaced by actual radio buttons&#8230;
&#60;/div&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre>List&#60;<span class="java&#45;object">String</span>&#62; fruits = Arrays.asList(<span class="java&#45;quote">"apple"</span>, <span class="java&#45;quote">"strawberry"</span>, <span class="java&#45;quote">"watermelon"</span>); 
form.add(<span class="java&#45;keyword">new</span> RadioChoice(<span class="java&#45;quote">"radioGroup"</span>, Model.of(<span class="java&#45;quote">""</span>), fruits));</pre></div><p class="paragraph"/><strong class="bold">Screenshot:</strong><p class="paragraph"/><img border="0" class="center" src="../img/grouped-radiobutton.png"></img><p class="paragraph"/>Just like CheckBoxMultipleChoice, this component provides the setPrefix and setSuffix methods to configure the prefix and suffix for our options and it supports IChoiceRender as well. In addition, RadioChoice provides the wantOnSelectionChangedNotifications() method to notify the web server when the selected option changes (this is the same method seen for DropDownChoice in paragraph 9.4).



<h2 id="forms2_12">12.12 Selecting multiple values with ListMultipleChoices and Palette</h2>
<p class="paragraph"/>Checkboxes work well when we have a small amount of options to display, but they quickly become chaotic as the number of options increases. To overcome this limit we can use the &#60;select&#62; tag switching it to multiple-choice mode with attribute multiple="multiple":<p class="paragraph"/><img border="0" class="center" src="../img/list-multiple-choices.png"></img><p class="paragraph"/>Now the user can select multiple options by holding down Ctrl key (or Command key for Mac) and selecting them.<p class="paragraph"/>To work with multiple choice list Wicket provides the <code>org.apache.wicket.markup.html.form.ListMultipleChoice</code> component:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;select wicket:id=<span class="java&#45;quote">"fruits"</span>&#62;
	&#60;option&#62;choice 1&#60;/option&#62;
	&#60;option&#62;choice 2&#60;/option&#62;
&#60;/select&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre>List&#60;<span class="java&#45;object">String</span>&#62; fruits = Arrays.asList(<span class="java&#45;quote">"apple"</span>, <span class="java&#45;quote">"strawberry"</span>, <span class="java&#45;quote">"watermelon"</span>); 
form.add(<span class="java&#45;keyword">new</span> ListMultipleChoice(<span class="java&#45;quote">"fruits"</span>, <span class="java&#45;keyword">new</span> ListModel&#60;<span class="java&#45;object">String</span>&#62;(<span class="java&#45;keyword">new</span> ArrayList&#60;<span class="java&#45;object">String</span>&#62;()), fruits));</pre></div><p class="paragraph"/><strong class="bold">Screenshot:</strong><p class="paragraph"/><img border="0" class="center" src="../img/list-multiple-choices2.png"></img><p class="paragraph"/>This component must be bound to a &#60;select&#62; tag but the attribute multiple="multiple" is not required as it will automatically be added by the component.<p class="paragraph"/>The number of visible rows can be set with the setMaxRows(int maxRows) method.<p class="paragraph"/><h3>Component Palette</h3><p class="paragraph"/>While multiple choice list solves the problem of handling a big number of multiple choices, it is not much intuitive for end users. That's why desktop GUIs have introduced a more complex component which can be generally referred to as multi select transfer component (it doesn't have an actual official name):<p class="paragraph"/><img border="0" class="center" src="../img/multi-select-transfer-component.png"></img><p class="paragraph"/>This kind of component is composed by two multiple-choice lists, one on the left displaying the available options and the other one on the right displaying the selected options. User can move options from a list to another by double clicking on them or using the buttons placed between the two list.<p class="paragraph"/>Built-in <code>org.apache.wicket.extensions.markup.html.form.palette.Palette</code> component provides an out-of-the-box implementation of a multi select transfer component. It works in a similar way to ListMultipleChoice:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#60;div wicket:id=<span class="java&#45;quote">"palette"</span>&#62;
   Select will be replaced by the actual content&#8230;
	   &#60;select multiple=<span class="java&#45;quote">"multiple"</span>&#62;
     &#60;option&#62;option1&#60;/option&#62;
     &#60;option&#62;option2&#60;/option&#62;
     &#60;option&#62;option3&#60;/option&#62;
&#60;/div&#62;</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre>Person john = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>);
Person bob = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"Bob"</span>, <span class="java&#45;quote">"Smith"</span>);
Person jill = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"Jill"</span>, <span class="java&#45;quote">"Smith"</span>);
Person andrea = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"Andrea"</span>, <span class="java&#45;quote">"Smith"</span>);<p class="paragraph"/>List&#60;Person&#62; theSmiths = Arrays.asList(john, bob, jill, andrea); 
ChoiceRenderer render = <span class="java&#45;keyword">new</span> ChoiceRenderer(<span class="java&#45;quote">"name"</span>);<p class="paragraph"/>form.add(<span class="java&#45;keyword">new</span> Palette(<span class="java&#45;quote">"palette"</span>, Model.of(<span class="java&#45;keyword">new</span> ArrayList&#60;<span class="java&#45;object">String</span>&#62;()), <span class="java&#45;keyword">new</span> ListModel&#60;<span class="java&#45;object">String</span>&#62; (theSmiths), render, 5, <span class="java&#45;keyword">true</span>));</pre></div><p class="paragraph"/><strong class="bold">Screenshot:</strong><p class="paragraph"/><img border="0" class="center" src="../img/multi-select-transfer-component-wicket.png"></img><p class="paragraph"/>The last two parameters of the Palette's constructor (an integer value and a boolean value) are, respectively, the number of visible rows for the two lists and a flag to choose if we want to display the two optional buttons which move selected options up and down. The descriptions of the two lists (‚ÄúAvailable‚Äù and ‚ÄúSelected‚Äù) can be customized providing two resources with keys palette.available and palette.selected.<p class="paragraph"/>The markup of this component uses a number of CSS classes which can be extended/overriden to customize the style of the component. We can find these classes and see which tags they decorate in the default markup file of the component:<p class="paragraph"/><div class="code"><pre>&#60;table cellspacing=<span class="java&#45;quote">"0"</span> cellpadding=<span class="java&#45;quote">"2"</span> class=<span class="java&#45;quote">"palette"</span>&#62;
&#60;tr&#62;
	&#60;td class=<span class="java&#45;quote">"header headerAvailable"</span>&#62;&#60;span wicket:id=<span class="java&#45;quote">"availableHeader"</span>&#62;&#91;available header&#93;&#60;/span&#62;&#60;/td&#62;
	&#60;td&#62;&#38;&#35;160;&#60;/td&#62;
	&#60;td class=<span class="java&#45;quote">"header headerSelected"</span>&#62;&#60;span wicket:id=<span class="java&#45;quote">"selectedHeader"</span>&#62;&#91;selected header&#93;&#60;/span&#62;                                           
        &#60;/td&#62; 
&#60;/tr&#62;
&#60;tr&#62;
	&#60;td class=<span class="java&#45;quote">"pane choices"</span>&#62;
		&#60;select wicket:id=<span class="java&#45;quote">"choices"</span> class=<span class="java&#45;quote">"choicesSelect"</span>&#62;&#91;choices&#93;&#60;/select&#62;	
	&#60;/td&#62;
	&#60;td class=<span class="java&#45;quote">"buttons"</span>&#62;
		&#60;button type=<span class="java&#45;quote">"button"</span> wicket:id=<span class="java&#45;quote">"addButton"</span> class=<span class="java&#45;quote">"button add"</span>&#62;&#60;div/&#62; 
               &#60;/button&#62;&#60;br/&#62;
		&#60;button type=<span class="java&#45;quote">"button"</span> wicket:id=<span class="java&#45;quote">"removeButton"</span> class=<span class="java&#45;quote">"button remove"</span>&#62;&#60;div/&#62; 
               &#60;/button&#62;&#60;br/&#62;
		&#60;button type=<span class="java&#45;quote">"button"</span> wicket:id=<span class="java&#45;quote">"moveUpButton"</span> class=<span class="java&#45;quote">"button up"</span>&#62;&#60;div/&#62;  
               &#60;/button&#62;&#60;br/&#62;
		&#60;button type=<span class="java&#45;quote">"button"</span> wicket:id=<span class="java&#45;quote">"moveDownButton"</span> class=<span class="java&#45;quote">"button down"</span>&#62;&#60;div/&#62;  
               &#60;/button&#62;&#60;br/&#62;
	&#60;/td&#62;
	&#60;td class=<span class="java&#45;quote">"pane selection"</span>&#62;
		&#60;select class=<span class="java&#45;quote">"selectionSelect"</span> wicket:id=<span class="java&#45;quote">"selection"</span>&#62;&#91;selection&#93;&#60;/select&#62;	
	&#60;/td&#62;
&#60;/tr&#62;
&#60;/table&#62;</pre></div>


<h2 id="forms2_13">12.13 Summary</h2>

Forms are the standard solution to let users interact with our web applications. In this chapter we have seen the three steps involved with the form processing workflow in Wicket. We have started looking at form validation and feedback messages generation, then we have seen how Wicket converts input values into Java objects and vice versa.<p class="paragraph"/>In the second part of the chapter we learnt how to build reusable form components and how to  implement a stateless form. We have ended the chapter with an overview of the built-in form components needed to handle standard input form elements like checkboxes, radio buttons and multiple selections lists.<p class="paragraph"/>



<h1 id="repeaters">13 Displaying multiple items with repeaters</h1>
A common task for web applications is to display a set of items. The most typical scenario where we need such kind of visualization is when we have to display some kind of search result. With the old template-based technologies (like JSP) we used to accomplish this task using classic for or while loops:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
&#60;meta http&#45;equiv=<span class="java&#45;quote">"Content&#45;Type"</span> content=<span class="java&#45;quote">"text/html; charset=UTF&#45;8"</span>&#62;
&#60;title&#62;Insert title here&#60;/title&#62;
&#60;/head&#62;
&#60;body&#62;
  &#60;%
    <span class="java&#45;keyword">for</span>(<span class="java&#45;object">int</span> i = 12; i&#60;=32; i++) &#123;
      %&#62;
      &#60;div&#62;Hello! I'm index n¬∞&#60;%= %&#62;&#60;/div&#62;
  &#60;% 
    &#125;
  %&#62;
&#60;/body&#62;</pre></div><p class="paragraph"/>To ease this task Wicket provides a number of special-purpose components called repeaters which are designed to use their related markup to display the items of a given set in a more natural and less chaotic way.<p class="paragraph"/>In this chapter we will see some of the built-in repeaters that come with Wicket.


<h2 id="repeaters_1">13.1 The RepeatingView Component</h2>
<p class="paragraph"/>Component <code>org.apache.wicket.markup.repeater.RepeatingView</code> is a container which renders its children components using the tag it is bound to. It can contain an arbitrary number of children elements and we can obtain a new valid id for a new child calling its method newChildId(). This component is particularly suited when we have to repeat a simple markup fragment, for example when we want to display some items as a HTML list:<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#60;ul&#62;
    &#60;li wicket:id=<span class="java&#45;quote">"listItems"</span>&#62;&#60;/li&#62;
&#60;/ul&#62;</pre></div><p class="paragraph"/><strong class="bold">Java Code:</strong>
<div class="code"><pre>RepeatingView listItems = <span class="java&#45;keyword">new</span> RepeatingView(<span class="java&#45;quote">"listItems"</span>);<p class="paragraph"/>listItems.add(<span class="java&#45;keyword">new</span> Label(listItems.newChildId(), <span class="java&#45;quote">"green"</span>));
listItems.add(<span class="java&#45;keyword">new</span> Label(listItems.newChildId(), <span class="java&#45;quote">"blue"</span>));
listItems.add(<span class="java&#45;keyword">new</span> Label(listItems.newChildId(), <span class="java&#45;quote">"red"</span>));</pre></div><p class="paragraph"/><strong class="bold">Generated markup:</strong>
<div class="code"><pre>&#60;ul&#62;
    &#60;li&#62;green&#60;/li&#62;
    &#60;li&#62;blue&#60;/li&#62;
    &#60;li&#62;red&#60;/li&#62;
&#60;/ul&#62;</pre></div><p class="paragraph"/>As we can see in this example, each child component has been rendered using the parent markup as if it was its own.



<h2 id="repeaters_2">13.2 The ListView Component</h2>
<p class="paragraph"/>As its name suggests, component <code>org.apache.wicket.markup.html.list.ListView</code> is designed to display a given list of objects which can be provided as a standard Java List or as a model containing the concrete List. ListView iterates over the list and creates a child component of type <code>org.apache.wicket.markup.html.list.ListItem</code> for every encountered item.<p class="paragraph"/>Unlike RepeatingView this component is intended to be used with complex markup fragments containing nested components.<p class="paragraph"/>To generate its children, ListView calls its abstract method populateItem(ListItem&#60;T&#62; item) for each item in the list, so we must provide an implementation of this method to tell the component how to create its children components. In the following example we use a ListView to display a list of Person objects:<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#8230;
	&#60;body&#62;
		&#60;div id=<span class="java&#45;quote">"bd"</span> style=<span class="java&#45;quote">"display: table;"</span>&#62;
			&#60;div wicket:id=<span class="java&#45;quote">"persons"</span> style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;&#60;b&#62;Full name: &#60;/b&#62;&#60;/div&#62;
				&#60;div wicket:id=<span class="java&#45;quote">"fullName"</span> style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;&#60;/div&#62;
			&#60;/div&#62;
		&#60;/div&#62;
	&#60;/body&#62;
...</pre></div><p class="paragraph"/><strong class="bold">Java Code (Page Constructor):</strong>
<div class="code"><pre><span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
	List&#60;Person&#62; persons = Arrays.asList(<span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>), 
                                        <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"Dan"</span>, <span class="java&#45;quote">"Wong"</span>));<p class="paragraph"/>   	add(<span class="java&#45;keyword">new</span> ListView&#60;Person&#62;(<span class="java&#45;quote">"persons"</span>, persons) &#123;
		@Override
		<span class="java&#45;keyword">protected</span> void populateItem(ListItem&#60;Person&#62; item) &#123;
	   		item.add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"fullName"</span>, <span class="java&#45;keyword">new</span> PropertyModel(item.getModel(), <span class="java&#45;quote">"fullName"</span>)));
		&#125;			
   &#125;);
&#125;</pre></div><p class="paragraph"/><strong class="bold">Screenshot of generated page:</strong><p class="paragraph"/><img border="0" class="center" src="../img/simple-listview-screenshot.png"></img><p class="paragraph"/>In this example we have displayed the full name of two Person's instances. The most interesting part of the code is the implementation of method populateItem where parameter item is the current child component created by ListView and its model contains the corresponding element of the list. Please note that inside populateItem we must add nested components to the <code>item</code> object and not directly to the <code>ListView</code>.<p class="paragraph"/><h3>ListView and Form</h3><p class="paragraph"/>By default <code>ListView</code> replaces its children components with new instances every time is rendered. Unfortunately this behavior is a problem if <code>ListView</code> is inside a form and it contains form components. The problem is caused by the fact that children components are replaced by new ones before form is rendered, hence they can't keep their input value if validation fails and, furthermore, their feedback messages can not be displayed.<p class="paragraph"/>To avoid this kind of problem we can force <code>ListView</code> to reuse its children components using its method setReuseItems and passing true as parameter. If for any reason we need to refresh children components after we have invoked setReuseItems(true), we can use MarkupContainer's method <code>removeAll()</code> to force <code>ListView</code> to rebuild them.



<h2 id="repeaters_3">13.3 The RefreshingView Component</h2>
<p class="paragraph"/>Component <code>org.apache.wicket.markup.repeater.RefreshingView</code> is a subclass of  RepeatingView that comes with a customizable rendering strategy for its children components.<p class="paragraph"/>RefreshingView defines abstract methods populateItem(Item) and getItemModels(). The first method is similar to the namesake method seen for ListView, but it takes in input an instance of class <code>org.apache.wicket.markup.repeater.Item</code> which is a subclass of <code>ListItem</code>. RefreshingView is designed to display a collection of models containing the actual items. An iterator over these models is returned by the other abstract method getItemModels.<p class="paragraph"/>The following code is a version of the previous example that uses <code>RefreshingView</code> in place of <code>ListView</code>:<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#8230;
	&#60;body&#62;
		&#60;div id=<span class="java&#45;quote">"bd"</span> style=<span class="java&#45;quote">"display: table;"</span>&#62;
			&#60;div wicket:id=<span class="java&#45;quote">"persons"</span> style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;&#60;b&#62;Full name: &#60;/b&#62;&#60;/div&#62;
				&#60;div wicket:id=<span class="java&#45;quote">"fullName"</span> style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;&#60;/div&#62;
			&#60;/div&#62;
		&#60;/div&#62;
	&#60;/body&#62;
...</pre></div><p class="paragraph"/><strong class="bold">Java Code (Page Constructor):</strong>
<div class="code"><pre><span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
   //define the list of models to use
   <span class="java&#45;keyword">final</span> List&#60;IModel&#60;Person&#62;&#62; persons = <span class="java&#45;keyword">new</span> ArrayList&#60;IModel&#60;Person&#62;&#62;();<p class="paragraph"/>   persons.add(Model.of(<span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>))); 
   persons.add(Model.of(<span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"Dan"</span>, <span class="java&#45;quote">"Wong"</span>)));<p class="paragraph"/>   add(<span class="java&#45;keyword">new</span> RefreshingView&#60;Person&#62;(<span class="java&#45;quote">"persons"</span>) &#123;
	@Override
	<span class="java&#45;keyword">protected</span> void populateItem(Item&#60;Person&#62; item) &#123;
	   item.add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"fullName"</span>, <span class="java&#45;keyword">new</span> PropertyModel(item.getModel(), <span class="java&#45;quote">"fullName"</span>)));
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> Iterator&#60;IModel&#60;Person&#62;&#62; getItemModels() &#123;
	   <span class="java&#45;keyword">return</span> persons.iterator();
	&#125;			
   &#125;);
&#125;</pre></div><p class="paragraph"/><h3>Item reuse strategy</h3><p class="paragraph"/>Similar to <code>ListView</code>, the default behavior of the <code>RefreshingView</code> is to replace its children with new instances every time is rendered. The strategy that decides if and how children components must be refreshed is returned by method <code>getItemReuseStrategy</code>. This strategy is an implementation of interface IItemReuseStrategy. The default implementation used by <code>RefreshingView</code> is class <code>DefaultItemReuseStrategy</code> but Wicket provides also strategy <code>ReuseIfModelsEqualStrategy</code> which reuses an item if its model has been returned by the iterator obtained with method <code>getItemModels</code>.<p class="paragraph"/>To set a custom strategy we must use method <code>setItemReuseStrategy</code>.



<h2 id="repeaters_4">13.4 Pageable repeaters</h2>
<p class="paragraph"/>Wicket offers a number of components that should be used when we have to display a big number of  items (for example the results of a select SQL query).<p class="paragraph"/>All these components implement interface <code>org.apache.wicket.markup.html.navigation.paging.IPageable</code> and use interface <code>IDataProvider</code> (placed in package <code>org.apache.wicket.markup.repeater.data</code>) as data source. This interface is designed to support data paging. We will see an example of data paging later in <a href="../guide/single.html#repeaters_4" class="guide">paragraph 13.4.2</a>.<p class="paragraph"/>The methods defined by IDataProvider are the following:
<ul class="star">
<li>iterator(long first, long count): returns an iterator over a subset of the entire dataset. The subset starts from the item at position first and includes all the next count items (i.e. it's the closed interval first,first+count).</li>
<li>size(): gets the size of the entire dataset.</li>
<li>model(T object): this method is used to wrap an item returned by the iterator with a model. This can be necessary if, for example, we need to wrap items with a detachable model to prevent them from being serialized.</li>
</ul><p class="paragraph"/>Wicket already provides implementations of IDataProvider to work with a List as data source (ListDataProvider) and to support data sorting (SortableDataProvider).<p class="paragraph"/><h3>Component DataView</h3><p class="paragraph"/>Class <code>org.apache.wicket.markup.repeater.data.DataView</code> is the simplest pageable repeater shipped with Wicket. DataView comes with abstract method populateItem(Item) that must be implemented to configure children components. In the following example we use a DataView to display a list of Person objects in a HTML table:<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#60;table&#62;
	&#60;tr&#62;
	   &#60;th&#62;Name&#60;/th&#62;&#60;th&#62;Surename&#60;/th&#62;&#60;th&#62;Address&#60;/th&#62;&#60;th&#62;Email&#60;/th&#62;
	&#60;/tr&#62;
	&#60;tr wicket:id=<span class="java&#45;quote">"rows"</span>&#62;
	   &#60;td wicket:id=<span class="java&#45;quote">"dataRow"</span>&#62;&#60;/td&#62;
	&#60;/tr&#62;
&#60;/table&#62;</pre></div><p class="paragraph"/><strong class="bold">Java Code:</strong>
<div class="code"><pre>//method loadPersons is defined elsewhere
List&#60;Person&#62; persons = loadPersons();
ListDataProvider&#60;Person&#62; listDataProvider = <span class="java&#45;keyword">new</span> ListDataProvider&#60;Person&#62;(persons);<p class="paragraph"/>DataView&#60;Person&#62; dataView = <span class="java&#45;keyword">new</span> DataView&#60;Person&#62;(<span class="java&#45;quote">"rows"</span>, listDataProvider) &#123;<p class="paragraph"/>  @Override
  <span class="java&#45;keyword">protected</span> void populateItem(Item&#60;Person&#62; item) &#123;
    Person person = item.getModelObject();
    RepeatingView repeatingView = <span class="java&#45;keyword">new</span> RepeatingView(<span class="java&#45;quote">"dataRow"</span>);<p class="paragraph"/>    repeatingView.add(<span class="java&#45;keyword">new</span> Label(repeatingView.newChildId(), person.getName()));
    repeatingView.add(<span class="java&#45;keyword">new</span> Label(repeatingView.newChildId(), person.getSurename()));
    repeatingView.add(<span class="java&#45;keyword">new</span> Label(repeatingView.newChildId(), person.getAddress()));    
    repeatingView.add(<span class="java&#45;keyword">new</span> Label(repeatingView.newChildId(), person.getEmail()));
    item.add(repeatingView); 
  &#125;
&#125;;
add(dataView);</pre></div><p class="paragraph"/>Please note that in the code above we have used also a RepeatingView component to populate the rows of the table.<p class="paragraph"/>In the next paragraph we will see a similar example that adds support for data paging.<p class="paragraph"/><h3>Data paging</h3><p class="paragraph"/>To enable data paging on a pageable repeater, we must first set the number of items to display per page with method setItemsPerPage(long items). Then, we must attach the repeater to panel PagingNavigator (placed in package <code>org.apache.wicket.markup.html.navigation.paging</code>) which is responsible for rendering a navigation bar containing the links illustrated in the following picture:<p class="paragraph"/><img border="0" class="center" src="../img/paging-navigator.png"></img><p class="paragraph"/>Project PageDataViewExample mixes a DataView component with a PagingNavigator to display the list of all countries of the world sorted by alphabetical order. Here is the initialization code of the project home page:<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#60;table&#62;
  &#60;tr&#62;
    &#60;th&#62;ISO 3166&#45;1&#60;/th&#62;&#60;th&#62;Name&#60;/th&#62;&#60;th&#62;<span class="java&#45;object">Long</span> name&#60;/th&#62;&#60;th&#62;Capital&#60;/th&#62;&#60;th&#62;Population&#60;/th&#62;
  &#60;/tr&#62;
  &#60;tr wicket:id=<span class="java&#45;quote">"rows"</span>&#62;
    &#60;td wicket:id=<span class="java&#45;quote">"dataRow"</span>&#62;&#60;/td&#62;
  &#60;/tr&#62;
&#60;/table&#62;</pre></div><p class="paragraph"/><strong class="bold">Java Code:</strong>
<div class="code"><pre><span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
  <span class="java&#45;keyword">super</span>(parameters);
  //method loadCountriesFromCsv is defined elsewhere in the class.
  //It reads countries data from a csv file and returns each row as an array of Strings.
  List&#60;<span class="java&#45;object">String</span>&#91;&#93;&#62; countries = loadCountriesFromCsv();
  ListDataProvider&#60;<span class="java&#45;object">String</span>&#91;&#93;&#62; listDataProvider = <span class="java&#45;keyword">new</span> ListDataProvider&#60;<span class="java&#45;object">String</span>&#91;&#93;&#62;(countries);<p class="paragraph"/>  DataView&#60;<span class="java&#45;object">String</span>&#91;&#93;&#62; dataView = <span class="java&#45;keyword">new</span> DataView&#60;<span class="java&#45;object">String</span>&#91;&#93;&#62;(<span class="java&#45;quote">"rows"</span>, listDataProvider) &#123;
    @Override
    <span class="java&#45;keyword">protected</span> void populateItem(Item&#60;<span class="java&#45;object">String</span>&#91;&#93;&#62; item) &#123;
      <span class="java&#45;object">String</span>&#91;&#93; countriesArr = item.getModelObject();
      RepeatingView repeatingView = <span class="java&#45;keyword">new</span> RepeatingView(<span class="java&#45;quote">"dataRow"</span>);<p class="paragraph"/>      <span class="java&#45;keyword">for</span> (<span class="java&#45;object">int</span> i = 0; i &#60; countriesArr.length; i++)&#123;
         repeatingView.add(<span class="java&#45;keyword">new</span> Label(repeatingView.newChildId(), countriesArr&#91;i&#93;));
      &#125;
      item.add(repeatingView);
    &#125;
  &#125;;<p class="paragraph"/>  dataView.setItemsPerPage(15);<p class="paragraph"/>  add(dataView);
  add(<span class="java&#45;keyword">new</span> PagingNavigator(<span class="java&#45;quote">"pagingNavigator"</span>, dataView));
&#125;</pre></div><p class="paragraph"/>The data of a single country (ISO code, name, long name, capital and population) are handled with an array of strings. The usage of PagingNavigator is quite straightforward as we need to simply pass the pageable repeater to its constructor.<p class="paragraph"/>To explore the other pageable repeaters shipped with Wicket you can visit the page at <a href="http://www.wicket-library.com/wicket-examples/repeater/" target="blank">http://www.wicket-library.com/wicket-examples/repeater/</a> where you can find live examples of these components.<p class="paragraph"/><blockquote class="note">
Wicket provides also component PageableListView which is a sublcass of ListView that implements interface IPageable, hence it can be considered a pageable repeater even if it doesn't use interface IDataProvider as data source.
</blockquote>



<h2 id="repeaters_5">13.5 Summary</h2>
<p class="paragraph"/>In this chapter we have explored the built-in set of components called repeaters which are designed to repeat their own markup in output to display a set of items. We have started with component <code>RepeatingView</code> which can be used to repeat a simple markup fragment.<p class="paragraph"/>Then, we have seen components <code>ListView</code> and <code>RefreshingView</code> which should be used when the markup to repeat contains nested components to populate.<p class="paragraph"/>Finally, we have discussed those repeaters that support data paging and that are called pageable repeaters. We ended the chapter looking at an example where a pageable repeater is used with panel PagingNavigator to make its dataset navigable by the user.


<h1 id="componentQueueing">14 Component queueing</h1>
So far to build component hierarchy we have explicitly added each component and container in accordance with the corresponding markup. This necessary step can involve repetitive and boring code which must be change every time we decide to change markup hierarchy. 
Component queueing is a new feature in Wicket 7 that solves this problem allowing Wicket to build component hierarchy in Java automatically making your code simpler and more maintainable. This chapter should serve as a short introduction to what Component Queueing is and what problems it is trying to solve.



<h2 id="componentQueueing_1">14.1 Markup hierarchy and code</h2>
With Wicket as developers we use to define the hierarchy of components in the markup templates:<p class="paragraph"/><div class="code"><pre>&#60;form wicket:id='customer'&#62;
    &#60;input wicket:id='first' type='text'/&#62;
    &#60;input wicket:id='last' type='text'/&#62;
    &#60;div wicket:id=<span class="java&#45;quote">"child"</span>&#62;
        &#60;input wicket:id='first' type='text'/&#62;
        &#60;input wicket:id='last' type='text'/&#62;
        &#60;input wicket:id='dob' type='date'/&#62;
    &#60;/div&#62;
&#60;/form&#62;</pre></div><p class="paragraph"/>and then we repeat the same hierarchy in Java code:<p class="paragraph"/><div class="code"><pre>Form form=<span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"customer"</span>);
add(form);<p class="paragraph"/>form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>));
form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>));<p class="paragraph"/>WebMarkupContainer child=<span class="java&#45;keyword">new</span> WebMarkupContainer(<span class="java&#45;quote">"child"</span>);
form.add(child);<p class="paragraph"/>child.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>));
child.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>));
child.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"dob"</span>));</pre></div><p class="paragraph"/>The need for the hierarchy in the markup is obvious, it is simply how the markup works. On the Java side of things it may not be immediately apparent. After all, why can we not write the code like this?<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"customer"</span>));
add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>));
add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>));
WebMarkupContainer child=<span class="java&#45;keyword">new</span> WebMarkupContainer(<span class="java&#45;quote">"child"</span>);
add(child);
add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>));
add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>));
add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"dob"</span>));</pre></div><p class="paragraph"/>There are a couple of reasons:
<ul class="star">
<li>Ambiguities that happen with duplicate ids</li>
<li>Inheriting state from parent to child</li>
</ul><p class="paragraph"/>We will examine these below.<p class="paragraph"/><h3>Markup Id Ambiguities</h3><p class="paragraph"/>In the example above we have a form that collects the name of a customer along with the name of their child and the child‚Äôs date of birth. We mapped the name of the customer and child to form components with wicket ids <code>first</code> and <code>last</code>. If we were to add all the components to the same parent we would get an error because we cannot have two components with the same wicket id under the same parent (two components with id <code>first</code> and two with id <code>last</code>). 
Without hierarchy in Java we would have to make sure that all wicket ids in a markup file are unique, no small feat in a non-trivial page or panel. But, with hierarchy on the Java side we just have to make sure that no parent has two children with the same id, which is trivial.<p class="paragraph"/><h3>Inheriting State From Parents</h3><p class="paragraph"/>Suppose we wanted to hide form fields related to the child in the example above when certain conditions are met. Without hierarchy we would have to modify the <code>first</code>, <code>last</code>, and <code>dob</code> fields to implement the visibility check. Worse, whenever we would add a new child related field we would have to remember to implement the same check; this is a maintenance headache. With hierarchy this is easy, simply hide the parent container and all children will be hidden as well ‚Äî the code lives in one place and is automatically inherited by all descendant components. Thus, hierarchy on the Java side allows us to write succinct and maintainable code by making use of the parent-child relationship of components.<p class="paragraph"/><h3>Pain Points of the Java-Side Hierarchy</h3><p class="paragraph"/>While undeniably useful, the Java-side hierarchy can be a pain to maintain. It is very common to get requests to change things because the designer needs to wrap some components in a <code>div</code> with a dynamic style or class attribute. Essentially we want to go from:<p class="paragraph"/><div class="code"><pre>&#60;form wicket:id='customer'&#62;
    &#60;input wicket:id='first' type='text'/&#62;
    &#60;input wicket:id='last' type='text'/&#62;</pre></div><p class="paragraph"/>To:<p class="paragraph"/><div class="code"><pre>&#60;form wicket:id='customer'&#62;
    &#60;div wicket:id='container'&#62;
        &#60;input wicket:id='first' type='text'/&#62;
        &#60;input wicket:id='last' type='text'/&#62;
    &#60;/div&#62;</pre></div><p class="paragraph"/>Seems simple enough, but to do so we need to create the new container, find the code that adds all the components that have to be relocated and change it to add to the new container instead. This code:<p class="paragraph"/><div class="code"><pre>Form form=<span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"customer"</span>);
add(form);<p class="paragraph"/>form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>));
form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>));</pre></div><p class="paragraph"/>Will become:<p class="paragraph"/><div class="code"><pre>Form form=<span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"customer"</span>);
add(form);<p class="paragraph"/>WebMarkupContainer container=<span class="java&#45;keyword">new</span> WebMarkupContainer(<span class="java&#45;quote">"container"</span>);
form.add(container);<p class="paragraph"/>container.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>));
container.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>));</pre></div><p class="paragraph"/>Another common change is to tweak the nesting of markup tags. This is something a designer should be able to do on their own if the change is purely visual, but cannot if it means Wicket components will change parents.<p class="paragraph"/>In large pages with a lot of components these kinds of simple changes tend to cause a lot of annoyance for the developers.<p class="paragraph"/><h3>Component Queueing To The Rescue</h3><p class="paragraph"/>The idea behind component queueing is simple: instead of adding components to their parents directly, the developer can queue them in any ancestor and have Wicket automatically ‚Äòdequeue‚Äô them to the correct parent using the hierarchy defined in the markup. This will give us the best of both worlds: the developer only has to define the hierarchy once in markup, and have it automatically constructed in Java land.<p class="paragraph"/>That means we can go from code like this:<p class="paragraph"/><div class="code"><pre>Form form=<span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"customer"</span>);
add(form);<p class="paragraph"/>form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>));
form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>));<p class="paragraph"/>WebMarkupContainer child=<span class="java&#45;keyword">new</span> WebMarkupContainer(<span class="java&#45;quote">"child"</span>);
form.add(child);<p class="paragraph"/>child.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>));
child.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>));
child.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"dob"</span>));</pre></div><p class="paragraph"/>To code like this:<p class="paragraph"/><div class="code"><pre>queue(<span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"customer"</span>));
queue(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>));
queue(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>));<p class="paragraph"/>WebMarkupContainer child=<span class="java&#45;keyword">new</span> WebMarkupContainer(<span class="java&#45;quote">"child"</span>);
queue(child);
child.queue(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>));
child.queue(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>));
child.queue(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"dob"</span>));</pre></div><p class="paragraph"/><blockquote class="note">
Note that we had to queue child‚Äôs <code>first</code> and <code>last</code> name fields to the <code>child</code> container in order to disambiguate their wicket ids.
</blockquote><p class="paragraph"/>
The code above does not look shorter or that much different, so where is the advantage?<p class="paragraph"/>Suppose our designer wants us to wrap the customer‚Äôs first and last name fields with a <code>div</code> that changes its styling based on some condition. We saw how to do that above, we had to create a container and then reparent the two <code>TextField</code> components into it. Using queueing we can skip the second step, all we have to do is add the following line:<p class="paragraph"/><div class="code"><pre>queue(<span class="java&#45;keyword">new</span> WebMarkupContainer(<span class="java&#45;quote">"container"</span>));</pre></div><p class="paragraph"/>When dequeueing Wicket will automatically reparent the first and last name fields into the container for us.<p class="paragraph"/>If the designer later wanted to move the first name field out of the <code>div</code> we just added for them they could do it all by themselves without requiring any changes in the Java code. Wicket would dequeue the first name field into the form and the last name field into the container div.<p class="paragraph"/>


<h2 id="componentQueueing_2">14.2 Improved auto components</h2>
Auto components, such as Enclosure, are a very useful feature of Wicket, but they have always been a pain to implement and use.<p class="paragraph"/>Suppose we have:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;wicket:enclosure childId=<span class="xml&#45;quote">"first"</span>&#62;</span>
    <span class="xml&#45;tag">&#60;input wicket:id=<span class="xml&#45;quote">"first"</span> type=<span class="xml&#45;quote">"text"</span>/&#62;</span>
    <span class="xml&#45;tag">&#60;input wicket:id=<span class="xml&#45;quote">"last"</span> type=<span class="xml&#45;quote">"text"</span>/&#62;</span>
<span class="xml&#45;tag">&#60;/wicket:enclosure&#62;</span></pre></div><p class="paragraph"/>Together with:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"first"</span>).setRequired(<span class="java&#45;keyword">true</span>).setVisible(<span class="java&#45;keyword">false</span>));
add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"last"</span>).setRequired(<span class="java&#45;keyword">true</span>));</pre></div><p class="paragraph"/>When developing auto components the biggest pain point is in figuring out who the children of the auto component are. In the markup above the enclosure is a parent of the text fields, but in Java it would be a sibling because auto components do not modify the java-side hierarchy. So when the Enclosure is looking for its children it has to parse the markup to figure out what they are. This is not a trivial task.<p class="paragraph"/>Because auto components do not insert themselves properly into the Java hierarchy they are also hard for users to use. For example, the documentation of Enclosure does not recommend it to be used to wrap form components like we have above. When the page renders the enclosure will be hidden because <code>first</code> component is not visible. However, when we submit the form, <code>last</code> component will raise a required error. This is because <code>last</code> is not made a child of the hidden enclosure and therefore does not know its hidden ‚Äî so it will try to process its input and raise the error.<p class="paragraph"/>Had we used <code>queue</code> instead of <code>add</code> in the code above, everything would work as expected. As part of Queueing implementation Wicket will properly insert auto components into the Java hierarchy. Furthermore, auto components will remain in the hierarchy instead of being added before render and removed afterwords. This is a big improvement because developers will no longer have to parse markup to find the children components ‚Äî since children will be added to the enclosure by the dequeueing. Likewise, user restrictions are removed as well; the code above would work as expected.



<h2 id="componentQueueing_3">14.3 When are components dequeued?</h2>
Once you call <code>queue()</code>, when are the components dequeued into the page hierarchy? When is it safe to call <code>getParent()</code> or use methods such as <code>isVisibleInHierarchy()</code> which rely on component‚Äôs position in hierarchy?<p class="paragraph"/>The components are dequeued as soon as a path is available from <code>Page</code> to the component they are queued into. The dequeue operation needs access to markup which is only available once the Page is known (because the <code>Page</code> object controls the extension of the markup).<p class="paragraph"/>If the <code>Page</code> is known at the time of the <code>queue()</code> call (eg if its called inside <code>onInitialize()</code>) the components are dequeued before <code>queue()</code> returns.



<h2 id="componentQueueing_4">14.4 Restrictions of queueing</h2>
<h3>Ancestors</h3><p class="paragraph"/>Suppose on a user profile panel we have the following code:<p class="paragraph"/><div class="code"><pre>queue(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"first"</span>));
queue(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"last"</span>));<p class="paragraph"/>WebMarkupContainer secure=<span class="java&#45;keyword">new</span> WebMarkupContainer(<span class="java&#45;quote">"secure"</span>) &#123;
    void onConfigure() &#123;
       <span class="java&#45;keyword">super</span>.onConfigure();
       setVisible(isViewingOwnProfile());
    &#125;
&#125;;<p class="paragraph"/>queue(secure);
secure.queue(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"creditCardNumber"</span>));
secure.queue(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"creditCardExpiry"</span>));</pre></div><p class="paragraph"/>What is to prevent someone with access to markup from moving the <code>creditCardNumber</code> label out of the <code>secure</code> div, causing a big security problem for the site?<p class="paragraph"/>Wicket will only dequeue components either to the component they are queued to or any of its descendants.<p class="paragraph"/>In the code above this is the reason why we queued the <code>creditCardNumber</code> label into the <code>secure</code> container. That means it can only be dequeued into the <code>secure</code> container‚Äôs hierarchy.<p class="paragraph"/>This restriction allows developers to enforce certain parent-child relationships in their code.<p class="paragraph"/><h3>Regions</h3><p class="paragraph"/>Dequeuing of components will not happen across components that implement the <code>org.apache.wicket.IQueueRegion</code> interface. This interface is implemented by all components that provide their own markup such as: <code>Page</code>, <code>Panel</code>, <code>Border</code>, <code>Fragment</code>. This is done so that if both a page and panel contain a component with id <code>foo</code> the one queued into the page will not be dequeued into the panel. This minimizes confusion and debugging time. The rule so far is that if a component provides its own markup only components queued inside it will be dequeued into it.



<h2 id="componentQueueing_5">14.5 Summary</h2>
Component queueing is a new and improved way of creating the component hierarchy in Wicket 7. By having to define the hierarchy only once in markup we can make the Java-side code simpler and more maintainable.



<h1 id="i18n">15 Internationalization with Wicket</h1>
In <a href="../guide/single.html#forms2_2" class="guide">chapter 12.2</a> we have seen how the topic of localization is involved in the generation of feedback messages and we had a first contact with resource bundles. In this chapter we will continue to explore the localization support provided by Wicket and we will learn how to build pages and components ready to be localized in different languages.



<h2 id="i18n_1">15.1 Localization</h2>
<p class="paragraph"/>As we have seen in <a href="../guide/single.html#forms2_2" class="guide">paragraph 12.2</a>, the infrastructure of feedback messages is built on top of Java internationalization (i18n) support, so it should not be surprising that the same infrastructure is used also for localization purpose. However, while so far we have used only the &#60;ApplicationClassName&#62;.properties file to store our custom messages, in this chapter we will see that also pages, components, validators and even Java packages can have their own resource bundles. This allows us to split bundles into multiple files keeping them close to where they are used. But before diving into the details of internationalization with Wicket, it's worthwhile to quickly review how i18n works under Java, see what classes are involved and how they are integrated into Wicket.<p class="paragraph"/><blockquote class="note">
Providing a full description of Java support for i18n is clearly out of the scope of this document. If you need more informations about this topic you can find them in the JavaDocs and in the official <a href="http://docs.oracle.com/javase/tutorial/i18n/index.html" target="blank">i18n tutorial</a> .
</blockquote><p class="paragraph"/><h3>Class Locale and ResourceBundle</h3><p class="paragraph"/>Class java.util.Locale represents a specific country or language of the world and is used in Java to retrieve other locale-dependent informations like numeric and date formats, the currency in use in a country and so on. Such kind of informations are accessed through special entities called resource bundles which are implemented by class <code>java.util.ResourceBundle</code>. Every resource bundle is identified by a full name which is built using four parameters: a base name (which is required), a language code, a country code and a variant (which are all optional). These three optional parameters are provided by an instance of Locale with its three corresponding getter methods: getLanguage(), getCountry() and getVariant(). Parameter language code is a lowercase ISO 639 2-letter code (like zh for Chinese, de for German and so on) while country code is an uppercase ISO 3166 2-letter code (like CN for China, DE for Germany and so on). The final full name will have the following structure (NOTE: tokens inside squared brackets are optional):<p class="paragraph"/><div class="code"><pre>&#60;base name&#62;&#91; <em class="italic">&#60;language code&#62;&#91;</em> &#60;COUNTRY_CODE&#62;&#91;_&#60;variant code&#62;&#93;&#93;&#93;</pre></div><p class="paragraph"/>For example a bundle with MyBundle as base name and localized for Mandarin Chinese (language code zh, country code CH, variant cmn) will have MyBundle_zh_CH_cmn as full name. A base name can be a fully qualified class name, meaning that it can include a package name before the actual base name. The specified package will be the container of the given bundle. For example if we use org.foo.MyBundle as base name, the bundle named MyBundle will be searched inside package org.foo. The actual base name (MyBundle in our example) will be used to build the full name of the bundle following the same rules seen above.
<code>ResourceBundle</code> is an abstract factory class, hence it exposes a number of factory methods named  getBundle to load a concrete bundle. Without going into too much details we can say that a bundle corresponds to a file in the classpath. To find a file for a given bundle, getBundle needs first to generate an ordered list of candidate bundle names. These names are the set of all possible full names for a given bundle. For example if we have org.foo.MyBundle as base name and the current locale is the one seen before for Mandarin Chinese, the candidate names will be:
<ol>
<li>org.foo.MyBundle_zh_CH_cmn</li>
<li>org.foo.MyBundle_zh_CH</li>
<li>org.foo.MyBundle_zh</li>
<li>org.foo.MyBundle</li>
</ol><p class="paragraph"/>The list of these candidate names is generated starting from the most specific one and subtracting an optional parameter at each step. The last name of the list corresponds to the default resource bundle which is the most general name and is equal to the base name. Once that getBundle has generated the list of candidate names, it will iterate over them to find the first one for which is possible to load a class or a properties file. The class must be a subclass of <code>ResourceBundle</code> having as class name the full name used in the current iteration. If such a class is not found, getBundle will try to locate a properties file having a file name equals to the current full name (Java will automatically append extension .properties to the full name). For example given the resource bundle of the previous example, Java will search first for class org.foo.MyBundle_zh_CH_cmn and then for file MyBundle_zh_CH_cmn.properties inside package org.foo. If no file is found for any of the candidate names, a MissingResourceException will be thrown. Bundles contains local-dependent string resources identified by a key that is unique in the given bundle. So once we have obtained a valid bundle we can access these objects with method getString (String key).<p class="paragraph"/>As we have seen before working with feedback messages, in Wicket most of the times we will work with properties files rather than with bundle classes. In <a href="../guide/single.html#forms2_2" class="guide">paragraph 12.2</a> we used a properties file having as base name the class name of the application class and without any information about the locale. This file is the default resource bundle for a Wicket application. In <a href="../guide/single.html#i18n_3" class="guide">paragraph 15.3</a> we will explore the algorithm used in Wicket to locate the available bundles for a given component. Once we have learnt how to leverage this algorithm, we will be able to split our bundles into more files organized in a logical hierarchy.



<h2 id="i18n_2">15.2 Localization in Wicket</h2>
<p class="paragraph"/>A component can get the current locale in use calling its method getLocale(). By default this method will be recursively called on component's parent containers until one of them returns a valid locale. If no one of them returns a locale, this method will get the one associated with the current user session. This locale is automatically generated by Wicket in accordance with the language settings of the browser.<p class="paragraph"/>Developers can change the locale of the current session with Session's method setLocale (Locale locale):<p class="paragraph"/><div class="code"><pre>Session.get().setLocale(locale)</pre></div><p class="paragraph"/><h3>Style and variation parameters for bundles</h3><p class="paragraph"/>In addition to locale's informations, Wicket supports two further parameters to identify a resource bundle: style and variation. Parameter style is a string value and is defined at session-level. To set/get the style for the current session we can use the corresponding setter and getter of class Session:<p class="paragraph"/><div class="code"><pre>Session.get().setStyle(<span class="java&#45;quote">"myStyle"</span>);
Session.get().getStyle();</pre></div><p class="paragraph"/>If set, style's value contributes to the final full name of the bundle and it is placed between the base name and the locale's informations:<p class="paragraph"/><div class="code"><pre>&#60;base name&#62;&#91; <em class="italic">style&#93;&#91;</em> &#60;language code&#62;&#91; <em class="italic">&#60;COUNTRY_CODE&#62;&#91;</em> &#60;variant code&#62;&#93;&#93;&#93;</pre></div><p class="paragraph"/>Wicket gives the priority to candidate names containing the style information (if available). The other parameter we can use for localization is variation. Just like style also variation is a string value, but it is defined at component-level. The value of variation is returned by Component's method getVariation(). By default this method returns the variation of the parent component or a null value if a component hasn't a parent (i.e. it's a page). If we want to customize this parameter we must overwrite method  getVariation and make it return the desired value.<p class="paragraph"/>Variation's value contributes to the final full name of the bundle and is placed before style parameter:<p class="paragraph"/><div class="code"><pre>&#60;base name&#62;&#91; <em class="italic">variation&#93;&#91;_style&#93;&#91;</em> &#60;language code&#62;&#91; <em class="italic">&#60;COUNTRY_CODE&#62;&#91;</em> &#60;variant code&#62;&#93;&#93;&#93;</pre></div><p class="paragraph"/>
<h3>Using UTF-8 for resource bundles</h3><p class="paragraph"/>Java uses the standard character set <a href="http://en.wikipedia.org/wiki/ISO/IEC_8859-1" target="blank">ISO 8859-11</a> to encode text files like properties files. Unfortunately ISO 8859-1 does not support most of the extra-European languages like Chinese or Japanese. The only way to use properties files with such languages is to use escaped <a href="http://en.wikipedia.org/wiki/List_of_Unicode_characters" target="blank">Unicode</a> characters, but this leads to not human-readable files. For example if we wanted to write the word 'website' in simplified Chinese (the ideograms are ÁΩëÁ´ô) we should write the Unicode characters <code>&#117;7F51&#117;7AD9</code>.
For this reason ISO 8859-11 is being replaced with another Unicode-compliant character encoding called UTF-8. Text files created with this encoding can contain Unicode symbols in plain format.
Wicket provides a useful convention to use properties file encoded with UTF-8. We just have to add prefix <code>.utf8.</code> to file extension (i.e. <code>.utf8.properties</code>).<p class="paragraph"/><blockquote class="note">
If you want to use UTF-8 with your text files, make sure that your editor/IDE is actually using this character encoding. Some OS like Windows use a different encoding by default.
</blockquote><p class="paragraph"/><h3>Using XML files as resource bundles</h3><p class="paragraph"/>Starting from version 1.5, Java introduced the support for XML files as resource bundles. XML files are generally encoded with character sets UTF-8 or UTF-16 which support every symbol of the Unicode standard. In order to be a valid resource bundle the XML file must conform to the DTD available at <a href="http://www.oracle.com/webfolder/technetwork/jsc/dtd/properties.dtd" target="blank">http://www.oracle.com/webfolder/technetwork/jsc/dtd/properties.dtd</a> .<p class="paragraph"/>Here is an example of XML resource bundle taken from project LocalizedGreetings (file WicketApplication_zh.properties.xml) containing the translation in simplified Chinese of the greeting message ‚ÄúWelcome to the website!‚Äù:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;?xml version=<span class="xml&#45;quote">"1.0"</span> encoding=<span class="xml&#45;quote">"UTF&#45;8"</span>?&#62;</span>
&#60;!DOCTYPE properties SYSTEM <span class="xml&#45;quote">"http://www.oracle.com/webfolder/technetwork/jsc/dtd/properties.dtd"</span>&#62;
<span class="xml&#45;tag">&#60;properties&#62;</span>
	<span class="xml&#45;tag">&#60;entry key=<span class="xml&#45;quote">"greetingMessage"</span>&#62;</span>Ê¨¢ËøéÂÖâ‰∏¥Êú¨ÁΩëÁ´ôÔºÅ<span class="xml&#45;tag">&#60;/entry&#62;</span>
<span class="xml&#45;tag">&#60;/properties&#62;</span></pre></div><p class="paragraph"/>To use XML bundles in Wicket we don't need to put in place any additional configuration. The only rule we have to respect with these files is to use properties.xml as extension while their base name follows the same rules seen so far for bundle names.<p class="paragraph"/><h3>Reading bundles from code</h3><p class="paragraph"/>Class Component makes reading bundles very easy with method getString(String key). This method searches for a resource with the given key looking into the resource bundles visited by the lookup algorithm illustrated in <a href="../guide/single.html#i18n_3" class="guide">paragraph 15.3</a>. For example if we have a greeting message with key greetingMessage in our application's resource  bundle, we can read it from our component code with this instruction:<p class="paragraph"/><div class="code"><pre>getString(<span class="java&#45;quote">"greetingMessage"</span>);</pre></div><p class="paragraph"/><h3>Localization of bundles in Wicket</h3><p class="paragraph"/>In <a href="../guide/single.html#forms2_2" class="guide">paragraph 12.2</a> we have used as resource bundle the properties file placed next to our application class. This file is the default resource bundle for the entire application and it is used by the lookup algorithm if it doesn't find any better match for a given component and locale. If we want to provide localized versions of this file we must simply follow the rules of Java i18n and put our translated resources into another properties file with a name corresponding to the desired locale. For example project LocalizedGreetings comes with the default application's properties file ( WicketApplication.properties) containing a greeting message:<p class="paragraph"/><div class="code"><pre>greetingMessage=Welcome to the site!</pre></div><p class="paragraph"/>Along with this file we can also find a bundle for German (WicketApplication_de.properties) and another one in XML format for simplified Chinese (WicketApplication_zh.properties.xml). The example project consists of a single page (HomePage.java) displaying the greeting message. The current locale can be changed with a drop-down list and the possible options are English (the default one), German and simplified Chinese:<p class="paragraph"/><img border="0" class="center" src="../img/locale-german.png"></img><p class="paragraph"/>The label displaying the greeting message has a custom read-only model which returns the message with method getString. The initialization code for this label is this:<p class="paragraph"/><div class="code"><pre>AbstractReadOnlyModel&#60;<span class="java&#45;object">String</span>&#62; model = <span class="java&#45;keyword">new</span> AbstractReadOnlyModel&#60;<span class="java&#45;object">String</span>&#62;() &#123;			
			@Override
			<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getObject() &#123;
				<span class="java&#45;keyword">return</span> getString(<span class="java&#45;quote">"greetingMessage"</span>);			
			&#125;
&#125;;<p class="paragraph"/>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"greetingMessage"</span>, model));</pre></div><p class="paragraph"/>Class <code>org.apache.wicket.model.AbstractReadOnlyModel</code> is a convenience class for implementing read-only models. In this project we have implemented a custom read-only model for illustrative purposes only because Wicket already provides built-in models for the same task. We will see them in paragraph <a href="../guide/single.html#i18n_5" class="guide">paragraph 15.5</a>.<p class="paragraph"/>The rest of the code of the home page builds the stateless form and the drop-down menu used to change the locale.<p class="paragraph"/><div class="code"><pre>List&#60;Locale&#62; locales = Arrays.asList(Locale.ENGLISH, Locale.CHINESE, Locale.GERMAN);
<span class="java&#45;keyword">final</span> DropDownChoice&#60;Locale&#62; changeLocale = 
             <span class="java&#45;keyword">new</span> DropDownChoice&#60;Locale&#62;(<span class="java&#45;quote">"changeLocale"</span>, <span class="java&#45;keyword">new</span> Model&#60;Locale&#62;(), locales);<p class="paragraph"/>StatelessForm form = <span class="java&#45;keyword">new</span> StatelessForm(<span class="java&#45;quote">"form"</span>)&#123;
	@Override
	<span class="java&#45;keyword">protected</span> void onSubmit() &#123;
		Session.get().setLocale(changeLocale.getModelObject());
	&#125;
&#125;;<p class="paragraph"/>setStatelessHint(<span class="java&#45;keyword">true</span>);
add(form.add(changeLocale))</pre></div><p class="paragraph"/>
<h3>Localization of markup files</h3><p class="paragraph"/>Although resource bundles exist to extract local-dependent elements from our code and from UI components, in Wicket we can decide to provide different markup files for different locale settings. Just like standard markup files, by default localized markup files must be placed next to component's class and their file name must contain the locale's informations. In the following picture, CustomPanel comes with a standard (or default) markup file and with another one localized for German:<p class="paragraph"/><img border="0" class="center" src="../img/comp-with-markup-german.png"></img><p class="paragraph"/>When the current locale corresponds to German country (language code de), markup file CustomPanel_de.html will be used in place of the default one.<p class="paragraph"/><h3>Reading bundles with tag &#60;wicket:message&#62;</h3><p class="paragraph"/>String resources can be also retrieved directly from markup code using tag &#60;wicket:message&#62;. The key of the desired resource is specified with attribute key:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;wicket:message key=<span class="xml&#45;quote">"greetingMessage"</span>&#62;</span>message goes here<span class="xml&#45;tag">&#60;/wicket:message&#62;</span></pre></div><p class="paragraph"/>By default the resource value is not escaped for HTML entities. To do that use the <code>escape</code> attribute:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;wicket:message key=<span class="xml&#45;quote">"greetingMessage"</span> escape=<span class="xml&#45;quote">"true"</span>&#62;</span>message goes here<span class="xml&#45;tag">&#60;/wicket:message&#62;</span></pre></div><p class="paragraph"/>
<code>wicket:message</code> can be adopted also to localize the attributes of a tag. The name of the attribute and the resource key are expressed as a colon-separated value. In the following markup the content of attribute <code>value</code> will be replaced with the localized resource having 'key4value' as key:<p class="paragraph"/><div class="code"><pre>&#60;input type=<span class="java&#45;quote">"submit"</span> value=<span class="java&#45;quote">"Preview value"</span> wicket:message=<span class="java&#45;quote">"value:key4value"</span>/&#62;</pre></div><p class="paragraph"/>If we want to specify multiple attributes at once, we can separate them with a comma:<p class="paragraph"/><div class="code"><pre>&#60;input type=<span class="java&#45;quote">"submit"</span> value=<span class="java&#45;quote">"Preview value"</span> wicket:message=<span class="java&#45;quote">"value:key4value, title:key4title"</span>/&#62;</pre></div>



<h2 id="i18n_3">15.3 Bundles lookup algorithm</h2>
<p class="paragraph"/>As we hinted at the beginning of this chapter, by default Wicket provides a very flexible algorithm to locate the resource bundles available for a given component. In this paragraph we will learn how this default lookup algorithm works and which options it offers to manage our bundle files.<p class="paragraph"/><h3>Localizing pages and panels</h3><p class="paragraph"/>Similarly to application class, also component classes can have their own bundle files having as base name the class name of the related component and placed in the same package. So for example if class CustomPanel is a custom panel we created, we can provide it with a default bundle file called  CustomPanel.properties containing the textual resources used by this panel. This rule applies to page classes as well:<p class="paragraph"/><img border="0" class="center" src="../img/page-and-panel-bundle.png"></img><p class="paragraph"/>One fundamental thing to keep in mind when we work with these kinds of bundles is that the lookup algorithm gives priority to the bundles of the containers of the component that is requesting a localized resource. The more a container is higher in the hierarchy, the bigger is its priority over the other components. This mechanism was made to allow containers to overwrite resources used by children components. As a consequence the values inside the resource bundle of a page will have the priority over the other values with the same key defined in the bundles of children components.<p class="paragraph"/>To better grasp this concept let's consider the component hierarchy depicted in the following picture:<p class="paragraph"/><img border="0" class="center" src="../img/custom-panel-bundle.png"></img><p class="paragraph"/>If CustomPanel tries to retrieve the string resource having 'message' as key, it will get the value 'Wellcome!' and not the one defined inside its own bundle file.<p class="paragraph"/>The default message-lookup algorithm is not limited to component hierarchy but it also includes the class hierarchy of every component visited in the search strategy described so far. This makes bundle files inheritable, just like markup files. When the hierarchy of a container component is explored, any ancestor has the priority over children components. Consider for example the hierarchy in the following picture:<p class="paragraph"/><img border="0" class="center" src="../img/custom-panel-bundle2.png"></img><p class="paragraph"/>Similarly to the previous example, the bundle owned by CustomPanel is overwritten by the bundle of   page class BasePage (which has been inherited by CustomPage).<p class="paragraph"/><h3>Component-specific resources</h3><p class="paragraph"/>In order to make a resource specific for a given child component, we can prefix the message key with the id of the desired component. Consider for example the following code and bundle of a generic page:<p class="paragraph"/>Page code:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"label"</span>,<span class="java&#45;keyword">new</span> ResourceModel(<span class="java&#45;quote">"labelValue"</span>)));
add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"anotherLabel"</span>,<span class="java&#45;keyword">new</span> ResourceModel(<span class="java&#45;quote">"labelValue"</span>)));</pre></div><p class="paragraph"/>Page bundle:<p class="paragraph"/><div class="code"><pre>labelValue=Default value
anotherLabel.labelValue=Value <span class="java&#45;keyword">for</span> anotherLabel</pre></div><p class="paragraph"/>Label with id anotherLabel will display the value 'Value for anotherLabel' while label label will display 'Default value'. In a similar fashion, parent containers can specify a resource for a nested child component prepending also its relative path (the path is dot-separated):<p class="paragraph"/>Page code:<p class="paragraph"/><div class="code"><pre>Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>);
form.add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"anotherLabel"</span>,<span class="java&#45;keyword">new</span> ResourceModel(<span class="java&#45;quote">"labelValue"</span>)));
add(form);</pre></div><p class="paragraph"/>Page bundle:<p class="paragraph"/><div class="code"><pre>labelValue=Default value
anotherLabel.labelValue=Value <span class="java&#45;keyword">for</span> anotherLabel
form.anotherLabel.labelValue=Value <span class="java&#45;keyword">for</span> anotherLabel inside form</pre></div><p class="paragraph"/>With the code and the bundle above, the label inside the form will display the value 'Value for anotherLabel inside form'.<p class="paragraph"/><h3>Package bundles</h3><p class="paragraph"/>If no one of the previous steps can find a resource for the given key, the algorithm will look for package bundles. These bundles have <code>wicket-package</code> as base name and they can be placed in one of the package of our application:<p class="paragraph"/><img border="0" class="center" src="../img/package-bundles.png"></img><p class="paragraph"/>Packages are traversed starting from the one containing the component requesting for a resource and going up to the root package.<p class="paragraph"/><h3>Bundles for feedback messages</h3><p class="paragraph"/>The algorithm described so far applies to feedback messages as well. In case of validation errors, the component that has caused the error will be considered as the component which the string resource is relative to. Furthermore, just like application class and components, validators can have their own bundles placed next to their class and having as base name their class name. This allows us to distribute validators along with the messages they use to report errors:<p class="paragraph"/><img border="0" class="center" src="../img/validator-with-bundle.png"></img><p class="paragraph"/>Validator's resource bundles have the lowest priority in the lookup algorithm. They can be overwritten by resource bundles of components, packages and application class.<p class="paragraph"/><h3>Extending the default lookup algorithm</h3><p class="paragraph"/>Wicket implements the default lookup algorithm using the strategy pattern. The concrete strategies are abstracted with the interface <code>org.apache.wicket.resource.loader.IStringResourceLoader</code>. By default Wicket uses the following implementations of <code>IStringResourceLoader</code> (sorted by execution order):
<ol>
<li><strong class="bold">ComponentStringResourceLoader:</strong> implements most of the default algorithm. It searches for a given resource across bundles from the container hierarchy, from class hierarchy and from the given component.</li>
<li><strong class="bold">PackageStringResourceLoader:</strong> searches into package bundles.</li>
<li><strong class="bold">ClassStringResourceLoader:</strong> searches into bundles of a given class. By default the target class is the application class.</li>
<li><strong class="bold">ValidatorStringResourceLoader:</strong> searches for resources into validator's bundles. A list of validators is provided by the form component that failed validation.</li>
<li><strong class="bold">InitializerStringResourceLoader:</strong> this resource allows internationalization to interact with the initialization mechanism of the framework that will be illustrated in <a href="../guide/single.html#advanced_3" class="guide">paragraph 18.3</a>.</li>
</ol><p class="paragraph"/>Developer can customize lookup algorithm removing default resource loaders or adding custom implementations to the list of the resource loaders in use. This task can be accomplished using method getStringResourceLoaders of setting class <code>org.apache.wicket.settings.ResourceSettings</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
  <span class="java&#45;keyword">super</span>.init();
  //retrieve ResourceSettings and then the list of resource loaders
  List&#60;IStringResourceLoader&#62; resourceLoaders = getResourceSettings(). 
                                                getStringResourceLoaders();
  //customize the list...</pre></div>



<h2 id="i18n_4">15.4 Localization of component's choices</h2>
<p class="paragraph"/>Components that inherit from <code>AbstractChoice</code> (such as <code>DropDownChoice</code>, <code>CheckBoxMultipleChoice</code> and <code>RadioChoice</code>) must override method <code>localizeDisplayValues</code> and make it return true to localize the values displayed for their choices. By default this method return false so values are displayed as they are. Once localization is activated we can use display values as key for our localized string resources. In project LocalizedChoicesExample we have a drop-down list that displays four colors (green, red, blue, and yellow) which are localized in three languages (English, German and Italian). The current locale can be changed with another drop-down menu (in a similar fashion to project <code>LocalizedGreetings</code>). The code of the home page and the relative bundles are the following:<p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
	<span class="java&#45;keyword">super</span>(parameters);<p class="paragraph"/>	List&#60;Locale&#62; locales = Arrays.asList(Locale.ENGLISH, Locale.ITALIAN, Locale.GERMAN);
	List&#60;<span class="java&#45;object">String</span>&#62; colors = Arrays.asList(<span class="java&#45;quote">"green"</span>, <span class="java&#45;quote">"red"</span>, <span class="java&#45;quote">"blue"</span>, <span class="java&#45;quote">"yellow"</span>);<p class="paragraph"/>	<span class="java&#45;keyword">final</span> DropDownChoice&#60;Locale&#62; changeLocale = <span class="java&#45;keyword">new</span> DropDownChoice&#60;Locale&#62;(<span class="java&#45;quote">"changeLocale"</span>, 
                                                    <span class="java&#45;keyword">new</span> Model&#60;Locale&#62;(), locales);<p class="paragraph"/>	StatelessForm form = <span class="java&#45;keyword">new</span> StatelessForm(<span class="java&#45;quote">"form"</span>)&#123;
		@Override
		<span class="java&#45;keyword">protected</span> void onSubmit() &#123;
			Session.get().setLocale(changeLocale.getModelObject());
		&#125;
	&#125;;<p class="paragraph"/>	DropDownChoice&#60;<span class="java&#45;object">String</span>&#62; selectColor = <span class="java&#45;keyword">new</span> DropDownChoice&#60;<span class="java&#45;object">String</span>&#62;(<span class="java&#45;quote">"selectColor"</span>, <span class="java&#45;keyword">new</span> 
                                                            Model&#60;<span class="java&#45;object">String</span>&#62;(), colors)&#123;
		@Override
		<span class="java&#45;keyword">protected</span> <span class="java&#45;object">boolean</span> localizeDisplayValues() &#123;
			<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">true</span>;
		&#125;
	&#125;;<p class="paragraph"/>	form.add(selectColor);
	add(form.add(changeLocale));
    &#125;</pre></div><p class="paragraph"/>Default bundle (English):<p class="paragraph"/><div class="code"><pre>selectColor.<span class="java&#45;keyword">null</span>=Select a color
green=Green
red=Red
blue=Blue
yellow=Yellow</pre></div><p class="paragraph"/>German bundle:<p class="paragraph"/><div class="code"><pre>selectColor.<span class="java&#45;keyword">null</span>=W√§hlen Sie eine Farbe
green=Gr√ºn
red=Rot
blue=Blau
yellow=Gelb</pre></div><p class="paragraph"/>Italian bundle:<p class="paragraph"/><div class="code"><pre>selectColor.<span class="java&#45;keyword">null</span>=Scegli un colore
green=Verde
red=Rosso
blue=Blu
yellow=Giallo</pre></div><p class="paragraph"/>Along with the localized versions of colors names, in the bundles above we can also find a custom value for the placeholder text (‚ÄúSelect a color ‚Äù) used for null value. The resource key for this resource is 'null' or '&#60;component id&#62;.null' if we want to make it component-specific.



<h2 id="i18n_5">15.5 Internationalization and Models</h2>
<p class="paragraph"/>Internationalization is another good chance to taste the power of models. Wicket provides two built-in models to better integrate our components with string resources: they are ResourceModel and StringResourceModel.<p class="paragraph"/><h3>ResourceModel</h3><p class="paragraph"/>Model <code>org.apache.wicket.model.ResourceModel</code> acts just like the read-only model we have implemented in <a href="../guide/single.html#i18n_3" class="guide">paragraph 15.3</a>. It simply retrieves a string resource corresponding to a given key:<p class="paragraph"/><div class="code"><pre>//build a ResourceModel <span class="java&#45;keyword">for</span> key 'greetingMessage'
<span class="java&#45;keyword">new</span> ResourceModel(<span class="java&#45;quote">"greetingMessage"</span>);</pre></div><p class="paragraph"/>We can also specify a default value to use if the requested resource is not found:<p class="paragraph"/><div class="code"><pre>//build a ResourceModel with a <span class="java&#45;keyword">default</span> value
<span class="java&#45;keyword">new</span> ResourceModel(<span class="java&#45;quote">"notExistingResource"</span>, <span class="java&#45;quote">"Resource not found."</span>);</pre></div><p class="paragraph"/><h3>StringResourceModel</h3><p class="paragraph"/>Model <code>org.apache.wicket.model.StringResourceModel</code> allows to work with complex and dynamic string resources containing parameters and property expressions. The basic constructor of this model takes in input a resource key and another model. This further model can be used by both the key and the related resource to specify dynamic values with property expressions. For example let's say that we are working on an e-commerce site which has a page where users can see an overview of their orders. To handle the state of user's orders we will use the following bean and enum (the code is from project StringResourceModelExample):<p class="paragraph"/>Bean:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class Order <span class="java&#45;keyword">implements</span> Serializable &#123;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> Date orderDate;
	<span class="java&#45;keyword">private</span> ORDER_STATUS status;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> Order(Date orderDate, ORDER_STATUS status) &#123;
		<span class="java&#45;keyword">super</span>();
		<span class="java&#45;keyword">this</span>.orderDate = orderDate;
		<span class="java&#45;keyword">this</span>.status = status;
	&#125;
	//Getters and setters <span class="java&#45;keyword">for</span> <span class="java&#45;keyword">private</span> fields
&#125;</pre></div><p class="paragraph"/>Enum:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> enum ORDER_STATUS &#123;<p class="paragraph"/>	PAYMENT_ACCEPTED(0),
	IN_PROGRESS(1),
	SHIPPING(2),
	DELIVERED(3);<p class="paragraph"/>	<span class="java&#45;keyword">private</span> <span class="java&#45;object">int</span> code;
	//Getters and setters <span class="java&#45;keyword">for</span> <span class="java&#45;keyword">private</span> fields	
&#125;</pre></div><p class="paragraph"/>Now what we want to do in this page is to print a simple label which displays the status of an order and the date on  which the order has been submitted. All the informations about the order will be passed to a StringResourceModel with a model containing the bean Order. The bundle in use contains the following key/value pairs:<p class="paragraph"/><div class="code"><pre>orderStatus.0=Your payment submitted on $&#123;orderDate&#125; has been accepted.
orderStatus.1=Your order submitted on $&#123;orderDate&#125; is in progress.
orderStatus.2=Your order submitted on $&#123;orderDate&#125; has been shipped.
orderStatus.3=Your order submitted on $&#123;orderDate&#125; has been delivered.</pre></div><p class="paragraph"/>The values above contain a property expression (${orderDate}) that will be evaluated on the data object of the model. The same technique can be applied to the resource key in order to load the right resource according to the state of the order:<p class="paragraph"/><div class="code"><pre>Order order = <span class="java&#45;keyword">new</span> Order(<span class="java&#45;keyword">new</span> Date(), ORDER_STATUS.IN_PROGRESS);
add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"orderStatus"</span>, <span class="java&#45;keyword">new</span> StringResourceModel(<span class="java&#45;quote">"orderStatus.$&#123;status.code&#125;"</span>, Model.of(order))));</pre></div><p class="paragraph"/>As we can see in the code above also the key contains a property expression (${status.code}) which makes its value dynamic. In this way the state of an object (an Order in our example) can determinate which resource will be loaded by StringResourceModel. If we don't use properties expressions we can provide a null value as model and in this case StringResourceModel will behave exactly as a ResourceModel. StringResourceModel supports also the same parameter substitution used by standard class <code>java.text.MessageFormat</code>.<p class="paragraph"/>Parameters can be generic objects but if we use a model as parameter, StringResourceModel will use the data object inside it as actual value (it will call getObject on the model). Parameters are passed as a vararg argument with method <code>setParameters(Object&#8230; parameters)</code>. Here is an example of usage of parameter substitution:<p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre>PropertyModel propertyModel = <span class="java&#45;keyword">new</span> PropertyModel&#60;Order&#62;(order, <span class="java&#45;quote">"orderDate"</span>);
//build a string model with two parameters: a property model and an integer value
StringResourceModel srm = <span class="java&#45;keyword">new</span> StringResourceModel(<span class="java&#45;quote">"orderStatus.delay"</span>).setParameters(propertyModel, 3);</pre></div><p class="paragraph"/>Bundle:<p class="paragraph"/><div class="code"><pre>orderStatus.delay=Your order submitted on $&#123;0&#125; has been delayed by &#123;1&#125; days.</pre></div><p class="paragraph"/>One further parameter we can specify when we build a StringResourceModel is the component that must be used by the lookup algorithm. Normally this parameter is not relevant, but if we need to use a particular bundle owned by a component not considered by the algorithm, we can specify this component as second parameter. If we pass all possible parameters to StringResourceModel's constructor we obtain something like this:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> StringResourceModel(<span class="java&#45;quote">"myKey"</span>, myComponent, myModel);</pre></div><p class="paragraph"/>Default value is supported as well, both as string model or as string value:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> StringResourceModel(<span class="java&#45;quote">"myKey"</span>, myComponent, myModel).setDefaultValue(<span class="java&#45;quote">"<span class="java&#45;keyword">default</span>"</span>);</pre></div><p class="paragraph"/>


<h2 id="i18n_6">15.6 Summary</h2>
<p class="paragraph"/>Internationalization is a mandatory step if we want to take our applications (and our business!) abroad. Choosing the right strategy to manage our localized resources is fundamental to avoid to make a mess of them. In this chapter we have explored the built-in support for localization provided by Wicket, and we have learnt which solutions it offers to manage resource bundles. In the final part of the chapter we have seen how to localize the options displayed by a component (such as DropDownChoice or RadioChoice) and we also introduced two new models specifically designed to localize our components without introducing in their code any detail about internationalization.



<h1 id="resources">16 Resource management with Wicket</h1>
One of the biggest challenge for a web framework is to offer an efficient and consistent mechanism to handle internal resources such as CSS/JavaScript files, picture files, pdf and so on. Resources can be static (like an icon used across the site) or dynamic (they can be generated on the fly) and they can be made available to users as a download or as a simple URL.<p class="paragraph"/>In <a href="../guide/single.html#keepControl_6" class="guide">paragraph 6.6</a> we have already seen how to add CSS and JavaScript contents to the header section of the page. In the first half of this chapter we will learn a more sophisticated technique that allows us to manage static resources directly from code and ‚Äúpack‚Äù them with our custom components.<p class="paragraph"/>Then, in the second part of the chapter we will see how to implement custom resources to enrich our web application with more complex and dynamic functionalities.



<h2 id="resources_1">16.1 Static vs dynamic resources</h2>
<p class="paragraph"/>In Wicket a resource is an entity that can interact with the current request and response and It must implement interface <code>org.apache.wicket.request.resource.IResource</code>. This interface defines just method respond(IResource.Attributes attributes) where the nested class IResource. Attributes provides access to request, response and page parameters objects.<p class="paragraph"/>Resources can be static or dynamic. Static resources don't entail any computational effort to be generated and they generally correspond to a resource on the filesystem. On the contrary dynamic resources are generated on the fly when they are requested, following a specific logic coded inside them.<p class="paragraph"/>An example of dynamic resource is the built-in class CaptchaImageResource in package <code>org.apache.wicket.extensions.markup.html.captcha</code> which generates a captcha image each time is rendered.<p class="paragraph"/>As we will see in <a href="../guide/single.html#resources_10" class="guide">paragraph 16.10</a>, developers can build custom resources extending base class <code>org.apache.wicket.request.resource.AbstractResource</code>.



<h2 id="resources_2">16.2 Resource references</h2>
<p class="paragraph"/>Most of the times in Wicket we won't directly instantiate a resource but rather we will use a reference to it. Resource references are represented by abstract class <code>org.apache.wicket.request.resource.ResourceReference</code> which returns a concrete resource with factory method getResource(). In this way we can lazy-initialize resources loading them only the first time they are requested.


<h2 id="resources_3">16.3 Package resources</h2>
<p class="paragraph"/>With HTML we use to include static resources in our pages using tags like &#60;script&#62;, &#60;link&#62; or &#60;img&#62;. This is what we have done so far writing our custom panels and pages. However, when we work with a component-oriented framework like Wicket, this classic approach becomes inadequate because it makes custom components hardly reusable. This happens when a component depends on a big number of resources. In such a case, if somebody wanted to use our custom component in his application, he would be forced to know which resources it depends on and make them available.<p class="paragraph"/>To solve this problem Wicket allows us to place static resource files into component package (like we do with markup and properties files) and load them from component code.<p class="paragraph"/>These kinds of resources are called package resources (a CSS and a JavaScript file in this screenshot):<p class="paragraph"/><img border="0" class="center" src="../img/package-resources.png"></img><p class="paragraph"/>With package resources custom components become independent and self-contained and client code can use them without worrying about their dependencies.<p class="paragraph"/>To load package resources Wicket provides class <code>org.apache.wicket.request.resource.PackageResourceReference</code>.<p class="paragraph"/>To identify a package resource we need to specify a class inside the target package and the name of the desired resource (most of the times this will be a file name).<p class="paragraph"/>In the following example taken from project ImageAsPackageRes, CustomPanel loads a picture file available as package resource and it displays it in a &#60;img&#62; tag using the built-in component <code>org.apache.wicket.markup.html.image.Image</code>:<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#60;html&#62;
&#60;head&#62;...&#60;/head&#62;
&#60;body&#62;
&#60;wicket:panel&#62;
	Package resource image: &#60;img wicket:id=<span class="java&#45;quote">"packageResPicture"</span>/&#62;
&#60;/wicket:panel&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><strong class="bold">Jave Code:</strong>
<div class="code"><pre><span class="java&#45;keyword">public</span> class CustomPanel <span class="java&#45;keyword">extends</span> Panel &#123;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> CustomPanel(<span class="java&#45;object">String</span> id) &#123;
		<span class="java&#45;keyword">super</span>(id);
		PackageResourceReference resourceReference = 
	            <span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"calendar.jpg"</span>);
		add(<span class="java&#45;keyword">new</span> Image(<span class="java&#45;quote">"packageResPicture"</span>, resourceReference));
	&#125;
&#125;</pre></div><p class="paragraph"/>Wicket will take care of generating a valid URL for file calendar.jpg. URLs for package resources have the following structure:<p class="paragraph"/><code>&#60;path to application root&#62;/wicket/resource/&#60;fully qualified classname&#62;/&#60;resource file name&#62;-&#60;ver-&#60;id&#62;&#62;(.file extension)</code><p class="paragraph"/>In our example the URL for our picture file calendar.jpg is the following:<p class="paragraph"/><code>./wicket/resource/org.wicketTutorial.CustomPanel/calendar-ver-1297887542000.jpg</code><p class="paragraph"/>The first part of the URL is the relative path to the application root. In our example our page is already at the application's root so we have only a single-dotted segment. The next two segments, wicket and resource, are respectively the namespace and the identifier for resources seen in <a href="../guide/single.html#urls_6" class="guide">paragraph 10.6.4</a>.<p class="paragraph"/>The fourth segment is the fully qualified name of the class used to locate the resource and it is the scope of the package resource. In the last segment of the URL we can find the name of the resource (the file name).<p class="paragraph"/>As you can see Wicket has automatically appended to the file name a version identifier (ver-1297887542000). When Wicket runs in DEVELOPMENT mode this identifier contains the timestamp in millisecond indicating the last time the resource file was modified. This can be useful when we are developing our application and resource files are frequently modified. Appending the timestamp to the original name we are sure that our browser will use always the last version of the file and not an old, out of date, cached version.<p class="paragraph"/>When instead Wicket is running in DEPLOYMENT mode, the version identifier will contain the MD5 digest of the file instead of the timestamp. The digest is computed only the first time the resource is requested. This perfectly makes sense as static resources don't change so often when our application runs into production environment and when this appends the application is redeployed.<p class="paragraph"/><blockquote class="note">
Package resources can be localized following the same rules seen for resource bundles and markup files:<p class="paragraph"/><img border="0" class="center" src="../img/package-resource-localization.png"></img><p class="paragraph"/>In the example illustrated in the picture above, if we try to retrieve package resource calendar.jpg when the current locale is set to French, the actual file returned will be calendar_fr.jpg.
</blockquote><p class="paragraph"/><h3>Responsive images - multiple resource references use in one component</h3><p class="paragraph"/>Since Wicket 7.0.0 the build-in component <code>org.apache.wicket.markup.html.image.Image</code> allows you to add several ResourceReferences via varargs and to provide sizes for each image so that the browser is able to pick the best image source.<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#8230;
	Package resource image: &#60;img wicket:id=<span class="java&#45;quote">"packageResPicture"</span>/&#62;
...</pre></div><p class="paragraph"/><strong class="bold">Java Code:</strong>
<div class="code"><pre>&#8230;
		Image image = <span class="java&#45;keyword">new</span> Image(<span class="java&#45;quote">"packageResPicture"</span>, 
			<span class="java&#45;keyword">new</span> PackageResourceReference(getClass(),<span class="java&#45;quote">"small.jpg"</span>), 
			<span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"large.jpg"</span>),
			<span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"medium.jpg"</span>),
			<span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"small.jpg"</span>));
		image.setXValues(<span class="java&#45;quote">"1024w"</span>, <span class="java&#45;quote">"640w"</span>, <span class="java&#45;quote">"320w"</span>);
		image.setSizes(<span class="java&#45;quote">"(min&#45;width: 36em) 33.3vw"</span>, <span class="java&#45;quote">"100vw"</span>);<p class="paragraph"/>		<span class="java&#45;keyword">this</span>.add(image);
...</pre></div><p class="paragraph"/>The component <code>org.apache.wicket.markup.html.image.Picture</code> is used to provide a fallback image <code>org.apache.wicket.markup.html.image.Image</code> and several source components <code>org.apache.wicket.markup.html.image.Source</code> which gives a developer the control as to when and if those images are presented to the user.<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#8230;
	&#60;picture wicket:id=<span class="java&#45;quote">"picture"</span>&#62;
  		&#60;source wicket:id=<span class="java&#45;quote">"big"</span> /&#62;
  		&#60;source wicket:id=<span class="java&#45;quote">"small"</span> /&#62;
  		&#60;img wicket:id=<span class="java&#45;quote">"fallback"</span> /&#62;
	&#60;/picture&#62;
...</pre></div><p class="paragraph"/><strong class="bold">Java Code:</strong>
<div class="code"><pre>&#8230;
		Picture picture = <span class="java&#45;keyword">new</span> Picture(<span class="java&#45;quote">"picture"</span>);<p class="paragraph"/>		Source big = <span class="java&#45;keyword">new</span> Source(<span class="java&#45;quote">"big"</span>, <span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"big.jpg"</span>), <span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"big&#45;hd.jpg"</span>);
		big.setXValues(<span class="java&#45;quote">"1x"</span>,<span class="java&#45;quote">"2x"</span>);
		big.setMedia(<span class="java&#45;quote">"(min&#45;width: 40em)"</span>);
		picture.add(big);<p class="paragraph"/>		Source small = <span class="java&#45;keyword">new</span> Source(<span class="java&#45;quote">"small"</span>, <span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"small.jpg"</span>), <span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"small&#45;hd.jpg"</span>);
		small.setXValues(<span class="java&#45;quote">"1x"</span>,<span class="java&#45;quote">"2x"</span>);
		picture.add(small);<p class="paragraph"/>		Image image = <span class="java&#45;keyword">new</span> Image(<span class="java&#45;quote">"fallback"</span>, <span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"fallback.jpg"</span>));
		picture.add(image);<p class="paragraph"/>		<span class="java&#45;keyword">this</span>.add(picture);
...</pre></div><p class="paragraph"/><h3>Inline Image - embedded resource reference content</h3><p class="paragraph"/>In some components like in the inline image resource references are going to be translated to other representations like base64 content.<p class="paragraph"/><strong class="bold">Java Code:</strong>
<div class="code"><pre>&#8230;
		add(<span class="java&#45;keyword">new</span> InlineImage(<span class="java&#45;quote">"inline"</span>, <span class="java&#45;keyword">new</span> PackageResourceReference(getClass(),<span class="java&#45;quote">"image2.gif"</span>)));
...</pre></div><p class="paragraph"/>
<h3>Media tags - resource references with content range support</h3><p class="paragraph"/>Since Wicket 7.0.0 the PackageResource and the PackageResourceReference support "Range" HTTP header for the request and "Content-Range" / "Accept-Range" HTTP headers for the response, which are used for videos / audio tags. The "Range" header allows the client to only request a specific byte range of the resource. The server provides the "Content-Range" and tells the client which bytes are going to be send.<p class="paragraph"/>If you want the resource not to be load into memory apply readBuffered(false) - this way the stream is written directly to the response. (<code>org.apache.wicket.resource.ITextResourceCompressor</code> will not be applied if readBuffered is set to false)<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#8230;
     &#60;video wicket:id=<span class="java&#45;quote">"video"</span> /&#62;
...</pre></div><p class="paragraph"/><strong class="bold">Java Code:</strong>
<div class="code"><pre>&#8230;
    Video video = <span class="java&#45;keyword">new</span> Video(<span class="java&#45;quote">"video"</span>, <span class="java&#45;keyword">new</span> PackageResourceReference(getClass(),<span class="java&#45;quote">"video.mp4"</span>).readBuffered(<span class="java&#45;keyword">false</span>));
...</pre></div><p class="paragraph"/><h3>Using package resources with tag &#60;wicket:link&#62;</h3><p class="paragraph"/>In <a href="../guide/single.html#urls_3" class="guide">paragraph 10.3</a> we have used tag &#60;wicket:link&#62; to automatically create links to bookmarkable pages. The same technique can be used also for package resources in order to use them directly from markup file. Let's assume for example that we have a picture file called icon.png placed in the same package of the current page. Under these conditions we can display the picture file using the following markup fragment:<p class="paragraph"/><div class="code"><pre>&#60;wicket:link&#62;
   &#60;img src=<span class="java&#45;quote">"icon.png"</span>/&#62;
&#60;/wicket:link&#62;</pre></div><p class="paragraph"/>In the example above Wicket will populate the attribute src with the URL corresponding to the package resource icon.png. &#60;wicket:link&#62; supports also tag &#60;link&#62; for CSS files and tag &#60;script&#62; for JavaScript files.



<h2 id="resources_4">16.4 Adding resources to page header section</h2>
<p class="paragraph"/>Wicket comes with interface <code>org.apache.wicket.markup.html.IHeaderContributor</code> which allows components and behaviors (which will be introduced later in <a href="../guide/single.html#advanced_1" class="guide">paragraph 18.1</a>) to contribute to the header section of their page. The only method defined in this interface is <code>renderHead(IHeaderResponse response)</code> where <code>IHeaderResponse</code> is an interface which defines method <code>render(HeaderItem item)</code> to write static resources or free-form text into the header section of the page.<p class="paragraph"/>Header entries are instances of abstract class <code>org.apache.wicket.markup.head.HeaderItem</code>. Wicket provides a set of built-in implementations of this class suited for the most common types of resources. With the exception of <code>PriorityHeaderItem</code>, every implementation of <code>HeaderItem</code> is an abstract factory class:
<ul class="star">
<li><strong class="bold">CssHeaderItem:</strong> represents a CSS resource. Factory methods provided by this class are <code>forReference</code> which takes in input a resource reference, <code>forUrl</code> which creates an CSS item from a given URL and <code>forCSS</code> which takes in input an arbitrary CSS string and an optional id value to identify the resource.</li>
<li><strong class="bold">JavaScriptHeaderItem:</strong> represents a JavaScript resource. Just like <code>CssHeaderItem</code> it provides factory methods <code>forReference</code> and <code>forUrl</code> along with method <code>forScript</code> which takes in input an arbitrary string representing the script and an optional id value to identify the resource. Method <code>forReference</code> also supports boolean parameter <code>defer</code> which renders the namesake attribute in the script tag (<code>defer</code> attribute indicates that our script must be execute only after the page has loaded).</li>
<li><strong class="bold">OnDomReadyHeaderItem:</strong> it adds JavaScript code that will be executed after the DOM has been built, but before external files (such as picture, CSS, etc...) have been loaded. The class provides a factory method <code>forScript</code> which takes in input an arbitrary string representing the script to execute.</li>
<li><strong class="bold">OnEventHeaderItem:</strong> the JavaScript code added with this class is executed when a specific JavaScript event is triggered on a given DOM element. The factory method is <code>forScript(String target, String event, CharSequence javaScript)</code>, where target is the id of a DOM element (or the element itself), event is the event that must trigger our code and javaScript is  the code to execute.</li>
<li><strong class="bold">OnLoadHeaderItem:</strong> the JavaScript code added with this class is executed after the whole page is loaded, external files included. The factory method is <code>forScript(CharSequence javaScript)</code>.</li>
<li><strong class="bold">PriorityHeaderItem:</strong> it wraps another header item and ensures that it will have the priority over the other items during rendering phase.</li>
<li><strong class="bold">StringHeaderItem:</strong> with this class we can add an arbitrary text to the header section. Factory method is <code>forString(CharSequence string)</code>.</li>
<li><strong class="bold">MetaDataHeaderItem:</strong> starting from version 6.17.0, Wicket provides this class to handle meta informations such as &#60;meta&#62; tags or <a href="http://en.wikipedia.org/wiki/Canonical_link_element" target="blank">canonical link element</a>. The available factory methods are <code>forLinkTag</code> and <code>forMetaTag</code> which can be used to create respectively a &#60;link&#62; tag or a &#60;meta&#62; one. We can add tag attribute to an existing instance of <code>MetaDataHeaderItem</code> with method <code>addTagAttribute(String attributeName, Object attributeValue)</code>. See JavaDoc for further details on this class.</li>
<li><strong class="bold">HtmlImportHeaderItem:</strong> introduced in Wicket 6.19.0, provides a HTML5 functionality to include other wicket pages (other html files) into the current generated. Factory methods provided by this class are <code>forImportLinkTag</code> which takes the page class or the url of the page / html to be included.</li>
</ul><p class="paragraph"/>In the following example our custom component loads a CSS file as a package resource (placed in the same package) and it adds it to header section.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class MyComponent <span class="java&#45;keyword">extends</span> Component&#123;<p class="paragraph"/>  @Override
  <span class="java&#45;keyword">public</span> void renderHead(IHeaderResponse response) &#123;
      PackageResourceReference cssFile = 
                            <span class="java&#45;keyword">new</span> PackageResourceReference(<span class="java&#45;keyword">this</span>.getClass(), <span class="java&#45;quote">"style.css"</span>);
    CssHeaderItem cssItem = CssHeaderItem.forReference(cssFile);<p class="paragraph"/>    response.render(cssItem);
  &#125;
&#125;</pre></div>



<h2 id="resources_5">16.5 Context-relative resources</h2>
In web applications, it's quite common to have one or more root context folders containing css/js files. These resources are normally referenced with an absolute path inside link/script tags:<p class="paragraph"/><div class="code"><pre>&#60;script src=<span class="java&#45;quote">"/misc/js/jscript.js"</span>&#62;&#60;/script&#62;
&#60;link type=<span class="java&#45;quote">"text/css"</span> rel=<span class="java&#45;quote">"stylesheet"</span> href=<span class="java&#45;quote">"/misc/css/themes/style.css"</span> /&#62;</pre></div><p class="paragraph"/>To handle this kind of resources from code we can use resource reference class <code>org.apache.wicket.request.resource.ContextRelativeResourceReference</code>. To build a new instance of this class we must specify the root context path of the resource we want to use:<p class="paragraph"/><div class="code"><pre>ContextRelativeResourceReference resource = <span class="java&#45;keyword">new</span> ContextRelativeResourceReference(<span class="java&#45;quote">"/misc/js/jscript.js"</span>);</pre></div><p class="paragraph"/>By default when our application runs in DEPLOYMENT mode <code>ContextRelativeResourceReference</code> will automatically load the minified version of the specified resource using 'min' as postfix. In the example above it will load '/misc/js/jscript.min.js'. We can force  <code>ContextRelativeResourceReference</code> to always use the not-minified resource passing an additional flag to class constructor:<p class="paragraph"/><div class="code"><pre>//it will always use '/misc/js/jscript.js'
ContextRelativeResourceReference resource = <span class="java&#45;keyword">new</span> ContextRelativeResourceReference(<span class="java&#45;quote">"/misc/js/jscript.js"</span>, <span class="java&#45;keyword">false</span>);</pre></div><p class="paragraph"/>The minified postfix can be customized with an optional string parameter:<p class="paragraph"/><div class="code"><pre>//it will use '/misc/js/jscript.minified.js' in DEPLOYMENT mode
ContextRelativeResourceReference resource = <span class="java&#45;keyword">new</span> ContextRelativeResourceReference(<span class="java&#45;quote">"/misc/js/jscript.js"</span>, <span class="java&#45;quote">"minified"</span>);</pre></div><p class="paragraph"/><code>ContextRelativeResourceReference</code> is usually used with the header item classes we have seen before in this chapter to create entries for the page header section.<p class="paragraph"/><h3>Picture files</h3><p class="paragraph"/>For picture files Wicket provides a specific component with class <code>org.apache.wicket.markup.html.image.ContextImage</code> which is meant to be used with tag &#60;img&#62;<p class="paragraph"/><div class="code"><pre>//build the component specifying its id and picture's context path
ContextImage image = <span class="java&#45;keyword">new</span> ContextImage(<span class="java&#45;quote">"myPicture"</span>, <span class="java&#45;quote">"/misc/imgs/mypic.png"</span>);</pre></div>



<h2 id="resources_6">16.6 Resource dependencies</h2>
<p class="paragraph"/>Class <code>ResourceReference</code> allows to specify the resources it depends on overriding method <code>getDependencies()</code>. The method returns a list of <code>HeaderItem</code>s that must be rendered before the resource referenced by <code>ResourceReference</code> can be used. This can be really helpful when our resources are JavaScript or CSS libraries that in turn depend on other libraries.<p class="paragraph"/>For example we can use this method to ensure that a custom reference to JQueryUI library will find JQuery already loaded in the page:<p class="paragraph"/><div class="code"><pre>Url jqueyuiUrl = Url.parse(<span class="java&#45;quote">"https://ajax.googleapis.com/ajax/libs/jqueryui/"</span> + 
                                                                 <span class="java&#45;quote">"1.10.2/jquery&#45;ui.min.js"</span>);<p class="paragraph"/>UrlResourceReference jqueryuiRef = <span class="java&#45;keyword">new</span> UrlResourceReference(jqueyuiUrl)&#123;
	@Override
	<span class="java&#45;keyword">public</span> List&#60;HeaderItem&#62; getDependencies() &#123;
		Application application = Application.get();
		ResourceReference jqueryRef = application.getJavaScriptLibrarySettings(). 
                                             getJQueryReference();<p class="paragraph"/>		<span class="java&#45;keyword">return</span> Arrays.asList(JavaScriptHeaderItem.forReference(jqueryRef));
	&#125;
&#125;;</pre></div><p class="paragraph"/>Please note that in the code above we have built a resource reference using a URL to the desired library instead of a package resource holding the physical file.<p class="paragraph"/><blockquote class="note">
Wicket already provides base class <code>org.apache.wicket.resource.JQueryPluginResourceReference</code> for those JavaScript resources that depend on JQuery. This class uses the JQuery version bundled with Wicket.
</blockquote><p class="paragraph"/><blockquote class="note">
The same method <code>getDependencies()</code> is defined also for class <code>HeaderItem</code>.
</blockquote>



<h2 id="resources_7">16.7 Aggregate multiple resources with resource bundles</h2>
One of the best practices to make our web application faster and reduce its latency is to reduce the number of requests to the server to load page resources like JavaScript or CSS files. To achieve this goal some JavaScript-based build tools (like Grunt) allow to merge multiple files used in a page into a single file that can be loaded in a single request. Wicket provides class <code>org.apache.wicket.ResourceBundles</code> to aggregate multiple resource references into a single one. A resource bundle can be declared during application initialization listing all the resources that compose it:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init() &#123;
  <span class="java&#45;keyword">super</span>.init();<p class="paragraph"/>  getResourceBundles().addJavaScriptBundle(WicketApplication.class,
                <span class="java&#45;quote">"jqueryUiJs"</span>,
                jqueryJsReference,
                jqueryUiJsReference);<p class="paragraph"/>  getResourceBundles().addCssBundle(WicketApplication.class,
                 <span class="java&#45;quote">"jqueryUiCss"</span>,
                jqueryCssReference,
                jqueryUiCssReference);<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>To declare a new resource bundle we need to provide a  <em class="italic">scope</em>  class (<code>WicketApplication.class</code> in our example) and an unique name. Now, when one of the resources included in the bundle is requested, the entire bundle is rendered instead.<p class="paragraph"/><blockquote class="note">
A specific resource reference can not be shared among different resource bundles (i.e. it can be part of only one bundle).
</blockquote>



<h2 id="resources_8">16.8 Put JavaScript inside page body</h2>
Some web developers prefer to put their &#60;script&#62; tags at the end of page body and not inside the &#60;head&#62; tags:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;<p class="paragraph"/>&#60;head&#62;
//no &#60;script&#62; tag here&#8230;
&#60;/head&#62;<p class="paragraph"/>&#60;body&#62;
&#8230;
&#60;script&#62;
//one or more &#60;script&#62; tags at the end of the body
&#60;/script&#62; 
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>
In Wicket we can achieve this result providing a custom <code>IHeaderResponseDecorator</code> to a our application and using Wicket tag &#60;wicket:container/&#62; to indicate where we want to render our scripts inside the page. Interface <code>IHeaderResponseDecorator</code> defines method <code>IHeaderResponse decorate(IHeaderResponse response)</code> which allows to decorate or add functionalities to Wicket <code>IHeaderResponse</code>. Our custom <code>IHeaderResponseDecorator</code> can be registered in the application with method <code>setHeaderResponseDecorator</code>. Anytime Wicket creates an instance of <code>IHeaderResponse</code>, it will call the registered <code>IHeaderResponseDecorator</code> to decorate the header response.<p class="paragraph"/>In the example project <code>ScriptInsideBody</code> we can find a custom <code>IHeaderResponseDecorator</code> that renders CSS into the usual &#60;head&#62; tag and put JavaScricpt header items into a specific container (tag &#60;wicket:container/&#62;)
Wicket already comes with class <code>JavaScriptFilteredIntoFooterHeaderResponse</code> which wraps a <code>IHeaderResponse</code> and renders in a given container all the instances of <code>JavaScriptHeaderItem</code>.
The following code is taken from the Application class of the project:<p class="paragraph"/><div class="code"><pre>//&#8230;
    @Override
    <span class="java&#45;keyword">public</span> void init()
    &#123;
       setHeaderResponseDecorator(<span class="java&#45;keyword">new</span> JavaScriptToBucketResponseDecorator(<span class="java&#45;quote">"footer&#45;container"</span>));
    &#125;<p class="paragraph"/>     /&#42;&#42;
     &#42; Decorates an original IHeaderResponse and renders all javascript items
     &#42; (JavaScriptHeaderItem), to a specific container in the page.
     &#42;/
    <span class="java&#45;keyword">static</span> class JavaScriptToBucketResponseDecorator <span class="java&#45;keyword">implements</span> IHeaderResponseDecorator 
    &#123;<p class="paragraph"/>        <span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> bucketName;<p class="paragraph"/>        <span class="java&#45;keyword">public</span> JavaScriptToBucketResponseDecorator(<span class="java&#45;object">String</span> bucketName) &#123;
            <span class="java&#45;keyword">this</span>.bucketName = bucketName;
        &#125;<p class="paragraph"/>        @Override
        <span class="java&#45;keyword">public</span> IHeaderResponse decorate(IHeaderResponse response) &#123;
            <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> JavaScriptFilteredIntoFooterHeaderResponse(response, bucketName);
        &#125;<p class="paragraph"/>    &#125;</pre></div><p class="paragraph"/>As you can see in the code above the "bucket" that will contain JavaScript tags is called <code>"footer-container"</code>. To make a use of it the developer have to add a special component called <code>HeaderResponseContainer</code> in his page:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> HeaderResponseContainer(<span class="java&#45;quote">"someId"</span>, <span class="java&#45;quote">"filterName"</span>));</pre></div><p class="paragraph"/>Please note that <code>HeaderResponseContainer</code>'s needs also a name for the corresponding header response's filter. The markup of our page will look like this:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;<p class="paragraph"/>&#60;header&#62;
//no &#60;script&#62; tag here&#8230;
&#60;/header&#62;<p class="paragraph"/>&#60;body&#62;
&#60;!&#45;&#45; here we will have our JavaScript tags &#45;&#45;&#62;
&#60;wicket:container wicket:id=<span class="java&#45;quote">"someId"</span>/&#62; 
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The code of the home page is the following:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
        <span class="java&#45;keyword">super</span>(parameters);<p class="paragraph"/>        add(<span class="java&#45;keyword">new</span> HeaderResponseContainer(<span class="java&#45;quote">"footer&#45;container"</span>, <span class="java&#45;quote">"footer&#45;container"</span>));
    &#125;<p class="paragraph"/>    @Override
    <span class="java&#45;keyword">public</span> void renderHead(IHeaderResponse response) &#123;
        response.render(JavaScriptHeaderItem.forReference(<span class="java&#45;keyword">new</span> PackageResourceReference(getClass(),
                <span class="java&#45;quote">"javasciptLibrary.js"</span>)));<p class="paragraph"/>        response.render(OnEventHeaderItem.forScript(<span class="java&#45;quote">"'logo'"</span>, <span class="java&#45;quote">"click"</span>, <span class="java&#45;quote">"alert('Clicked me!')"</span>));
    &#125;</pre></div><p class="paragraph"/>Looking at the code above you can note that our page adds two script to the header section: the first is an instance of <code>JavaScriptHeaderItem</code> and will be rendered in the <code>HeaderResponseContainer</code> while the second will follow the usual behavior and will be rendered inside &#60;head&#62; tag.<p class="paragraph"/><p class="paragraph"/>


<h2 id="resources_9">16.9 Header contributors positioning</h2>
Starting from version 6.15.0 we can specify where header contributors must be rendered inside &#60;head&#62; tag using the placeholder tag <code>&#60;wicket:header-items/&#62;</code>:<p class="paragraph"/><div class="code"><pre>&#60;head&#62;
  &#60;meta charset=<span class="java&#45;quote">"UTF&#45;8"</span>/&#62;
  &#60;wicket:header&#45;items/&#62;
  &#60;script src=<span class="java&#45;quote">"my&#45;monkey&#45;patch&#45;of&#45;wicket&#45;ajax.js"</span>&#62;&#60;/script&#62;
&#60;/head&#62;</pre></div><p class="paragraph"/>With the code above all header contributions done by using IHeaderResponse in your Java code or the special <code>&#60;wicket:head&#62;</code> tag will be put between the &#60;meta&#62; and &#60;script&#62; elements, i.e. in the place of <code>&#60;wicket:header-items/&#62;</code>.<p class="paragraph"/>This way you can make sure that some header item is always before or after the header items managed by Wicket.<p class="paragraph"/><code>&#60;wicket:header-items/&#62;</code> can be used only in the page's &#60;head&#62; element and there could be at most one instance of it.



<h2 id="resources_10">16.10 Custom resources</h2>
<p class="paragraph"/>In Wicket the best way to add dynamic functionalities to our application (such as csv export, a pdf generated on the fly, etc...) is implementing a custom resource. In this paragraph as example of custom resource we will build a basic RSS feeds generator which can be used to publish feeds on our site (project CustomResourceMounting). Instead of generating a RSS feed by hand we will use Rome framework and its utility classes.<p class="paragraph"/>As hinted above in <a href="../guide/single.html#resources_1" class="guide">paragraph 16.1</a>, class <code>AbstractResource</code> can be used as base class to implement new resources. This class defines abstract method <code>newResourceResponse</code> which is invoked when the resource is requested. The following is the code of our RSS feeds generator:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class RSSProducerResource <span class="java&#45;keyword">extends</span> AbstractResource &#123;<p class="paragraph"/>  @Override
  <span class="java&#45;keyword">protected</span> ResourceResponse newResourceResponse(Attributes attributes) &#123;
    ResourceResponse resourceResponse = <span class="java&#45;keyword">new</span> ResourceResponse();
    resourceResponse.setContentType(<span class="java&#45;quote">"text/xml"</span>);
    resourceResponse.setTextEncoding(<span class="java&#45;quote">"utf&#45;8"</span>);<p class="paragraph"/>    resourceResponse.setWriteCallback(<span class="java&#45;keyword">new</span> WriteCallback()
    &#123;
      @Override
      <span class="java&#45;keyword">public</span> void writeData(Attributes attributes) <span class="java&#45;keyword">throws</span> IOException
      &#123;
        OutputStream outputStream = attributes.getResponse().getOutputStream();
        Writer writer = <span class="java&#45;keyword">new</span> OutputStreamWriter(outputStream);
        SyndFeedOutput output = <span class="java&#45;keyword">new</span> SyndFeedOutput();
            <span class="java&#45;keyword">try</span> &#123;
          output.output(getFeed(), writer);
        &#125; <span class="java&#45;keyword">catch</span> (FeedException e) &#123;
          <span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> WicketRuntimeException(<span class="java&#45;quote">"Problems writing feed to response..."</span>);
        &#125;
      &#125;      
    &#125;);<p class="paragraph"/>    <span class="java&#45;keyword">return</span> resourceResponse;
  &#125;
  // method getFeed()&#8230;
&#125;</pre></div><p class="paragraph"/>Method <code>newResourceResponse</code> returns an instance of <code>ResourceResponse</code> representing the response generated by the custom resource. Since RSS feeds are based on XML, in the code above we have set the type of the response to text/xml and the text encoding to utf-8.<p class="paragraph"/>To specify the content that will be returned by our resource we must also provide an implementation of inner class <code>WriteCallback</code> which is responsible for writing content data to response's output stream. In our project we used class SyndFeedOutput from Rome framework to write our feed to response. Method <code>getFeed()</code> is just an utility method that generates a sample RSS feed (which is an instance of interface <code>com.sun.syndication.feed.synd.SyndFeed</code>).<p class="paragraph"/>Now that we have our custom resource in place, we can use it in the home page of the project. The easiest way to make a resource available to users is to expose it with link component <code>ResourceLink</code>:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> ResourceLink(<span class="java&#45;quote">"rssLink"</span>, <span class="java&#45;keyword">new</span> RSSProducerResource()));</pre></div><p class="paragraph"/>In the next paragraphs we will see how to register a resource at application-level and how to mount it to an arbitrary URL.



<h2 id="resources_11">16.11 Mounting resources</h2>
<p class="paragraph"/>Just like pages also resources can be mounted to a specific path. Class <code>WebApplication</code> provides method <code>mountResource</code> which is almost identical to <code>mountPage</code> seen in <a href="../guide/single.html#urls_6" class="guide">paragraph 10.6.1</a>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init() &#123;
  <span class="java&#45;keyword">super</span>.init();
  //resource mounted to path /foo/bar
  ResourceReference resourceReference = <span class="java&#45;keyword">new</span> ResourceReference(<span class="java&#45;quote">"rssProducer"</span>)&#123;
     RSSReaderResource rssResource = <span class="java&#45;keyword">new</span> RSSReaderResource();
     @Override
     <span class="java&#45;keyword">public</span> IResource getResource() &#123;
	<span class="java&#45;keyword">return</span> rssResource;
  &#125;&#125;;
  mountResource(<span class="java&#45;quote">"/foo/bar"</span>, resourceReference);
&#125;</pre></div><p class="paragraph"/>With the configuration above (taken from project <code>CustomResourceMounting</code>) every request to /foo/bar will be served by the custom resource built in the previous paragraph.<p class="paragraph"/>Parameter placeholders are supported as well:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init() &#123;
  <span class="java&#45;keyword">super</span>.init();
  //resource mounted to path /foo with a required indexed parameter
  ResourceReference resourceReference = <span class="java&#45;keyword">new</span> ResourceReference(<span class="java&#45;quote">"rssProducer"</span>)&#123;
     RSSReaderResource rssResource = <span class="java&#45;keyword">new</span> RSSReaderResource();
     @Override
     <span class="java&#45;keyword">public</span> IResource getResource() &#123;
	<span class="java&#45;keyword">return</span> rssResource;
  &#125;&#125;;
  mountResource(<span class="java&#45;quote">"/bar/$&#123;baz&#125;"</span>, resourceReference);
&#125;</pre></div>



<h2 id="resources_12">16.12 Shared resources</h2>
<p class="paragraph"/>Resources can be added to a global registry in order to share them at application-level. Shared resources are identified by an application-scoped key and they can be easily retrieved at a later time using reference class <code>SharedResourceReference</code>. The global registry can be accessed with <code>Application</code>'s method <code>getSharedResources</code>. In the following excerpt of code (taken again from project <code>CustomResourceMounting</code>) we register an instance of our custom RSS feeds producer as application-shared resource:<p class="paragraph"/><div class="code"><pre>//init application's method
  @Override
  <span class="java&#45;keyword">public</span> void init()&#123;
    RSSProducerResource rssResource = <span class="java&#45;keyword">new</span> RSSProducerResource();
    // &#8230;
    getSharedResources().add(<span class="java&#45;quote">"globalRSSProducer"</span>, rssResource);    
  &#125;</pre></div><p class="paragraph"/>Now to use an application-shared resource we can simply retrieve it using class <code>SharedResourceReference</code> and providing the key previously used to register the resource:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> ResourceLink(<span class="java&#45;quote">"globalRssLink"</span>, <span class="java&#45;keyword">new</span> SharedResourceReference(<span class="java&#45;quote">"globalRSSProducer"</span>)));</pre></div><p class="paragraph"/>The URL generated for application shared resources follows the same pattern seen for package resources:<p class="paragraph"/><code>./wicket/resource/org.apache.wicket.Application/globalRSSProducer</code><p class="paragraph"/>The last segment of the URL is the key of the resource while the previous segment contains the scope of the resource. For application-scoped resources the scope is always the fully qualified name of class <code>Application</code>. This should not be surprising since global resources are visible at application level (i.e. the scope is the application).<p class="paragraph"/><blockquote class="note">
Package resources are also application-shared resources but they don't need to be explicitly registered.
</blockquote><p class="paragraph"/><blockquote class="note">
Remember that we can get the URL of a resource reference using method <code>urlFor(ResourceReference resourceRef, PageParameters params )</code> available with both class <code>RequestCycle</code> and class <code>Component</code>.
</blockquote>


<h2 id="resources_13">16.13 Customizing resource loading</h2>
<p class="paragraph"/>Wicket loads application's resources delegating this task to a resource locator represented by interface <code>org.apache.wicket.core.util.resource.locator.IResourceStreamLocator</code>. To retrieve or modify the current resource locator we can use the getter and setter methods defined by setting class <code>ResourceSettings</code>:<p class="paragraph"/><div class="code"><pre>//init application's method
  @Override
  <span class="java&#45;keyword">public</span> void init()&#123;   
    //get the resource locator 
    getResourceSettings().getResourceStreamLocator();
    //set the resource locator    
    getResourceSettings().setResourceStreamLocator(myLocator);
  &#125;</pre></div><p class="paragraph"/>The default locator used by Wicket is class <code>ResourceStreamLocator</code> which in turn tries to load a requested resource using a set of implementations of interface <code>IResourceFinder</code>. This interface defines method <code>find(Class class, String pathname)</code> which tries to resolve a resource corresponding to the given class and path.<p class="paragraph"/>The default implementation of <code>IResourceFinder</code> used by Wicket is <code>ClassPathResourceFinder</code> which searches for resources into the application class path. This is the implementation we have used so far in our examples. However some developers may prefer storing markup files and other resources in a separate folder rather than placing them side by side with Java classes.<p class="paragraph"/>To customize resource loading we can add further resource finders to our application in order to extend the resource-lookup algorithm to different locations. Wicket already comes with two other implementations of IResourceFinder designed to search for resources into a specific folder on the file system. The first is class <code>Path</code> and it's defined in package <code>org.apache.wicket.util.file</code>. The constructor of this class takes in input an arbitrary folder that can be expressed as a string path or as an instance of Wicket utility class <code>Folder</code> (in package <code>org.apache.wicket.util.file</code>). The second implementation of interface <code>IResourceFinder</code> is class <code>WebApplicationPath</code> which looks into a folder placed inside webapp's root path (but not inside folder WEB-INF).<p class="paragraph"/>Project CustomFolder4MarkupExample uses <code>WebApplicationPath</code> to load the markup file and the resource bundle for its home page from a custom folder. The folder is called markupFolder and it is placed in the root path of the webapp. The following picture illustrates the file structure of the project:<p class="paragraph"/><img border="0" class="center" src="../img/package-structure-custom-folder.png"></img><p class="paragraph"/>As we can see in the picture above, we must preserve the package structure also in the custom folder used as resource container. The code used inside application class to configure  WebApplicationPath is the following:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	getResourceSettings().getResourceFinders().add(
			<span class="java&#45;keyword">new</span> WebApplicationPath(getServletContext(), <span class="java&#45;quote">"markupFolder"</span>));
&#125;</pre></div><p class="paragraph"/>Method getResourceFinders() defined by setting class ResourceSettings returns the list of  resource finders defined in our application. The constructor of WebApplicationPath takes in input also an instance of standard interface javax.servlet.ServletContext which can be retrieved with WebApplication's method getServletContext().<p class="paragraph"/><blockquote class="note">
By default, if resource files can not be found inside application classpath, Wicket will search for them inside ‚Äúresources‚Äù folder. You may have noted this folder in the previous picture. It is placed next to the folder ‚Äújava‚Äù containing our source files:<p class="paragraph"/><img border="0" class="center" src="../img/package-structure-resource-folder.png"></img><p class="paragraph"/>This folder can be used to store resource files without writing any configuration code.
</blockquote>



<h2 id="resources_14">16.14 CssHeaderItem and JavaScriptHeaderItem compression</h2>
<p class="paragraph"/>Introduced in Wicket 6.20.0 / Wicket 7.0.0 there is a default way to be used in which the output of all CssHeaderItems / JavaScriptHeaderItems is modified before they are cached and delivered to the client. You can add a so called Compressor by receiving the resource settings and invoke #setJavaScriptCompressor(...) / #setJavaScriptCompressor(...). If you want to add several Compressors use <code>org.apache.wicket.resource.CompositeCssCompressor</code> or <code>org.apache.wicket.resource.CompositeJavaScriptCompressor</code><p class="paragraph"/><strong class="bold">Java Code:</strong>
<div class="code"><pre>&#8230;
¬†¬†¬† <span class="java&#45;keyword">public</span> class WicketApplication <span class="java&#45;keyword">extends</span> WebApplication
¬†¬† ¬†&#123;
¬†¬† ¬†¬†¬† ¬†@Override
¬†¬† ¬†¬†¬† ¬†<span class="java&#45;keyword">public</span> <span class="java&#45;object">Class</span>&#60;? <span class="java&#45;keyword">extends</span> WebPage&#62; getHomePage()
¬†¬† ¬†¬†¬† ¬†&#123;
¬†¬† ¬†¬†¬† ¬†¬†¬† ¬†<span class="java&#45;keyword">return</span> HomePage.class;
¬†¬† ¬†¬†¬† ¬†&#125;
¬†¬† ¬†
¬†¬† ¬†¬†¬† ¬†@Override
¬†¬† ¬†¬†¬† ¬†<span class="java&#45;keyword">public</span> void init()
¬†¬† ¬†¬†¬† ¬†&#123;
¬†¬† ¬†¬†¬† ¬†¬†¬† ¬†<span class="java&#45;keyword">super</span>.init();
¬†¬† ¬†¬†¬† ¬†¬†¬† ¬†getResourceSettings().setCssCompressor(<span class="java&#45;keyword">new</span> CssUrlReplacer());
¬†¬† ¬†¬†¬† ¬†&#125;
¬†¬† ¬†&#125;
...</pre></div><p class="paragraph"/>In the previous example you see that a <code>org.apache.wicket.resource.CssUrlReplacer</code> is added which does not compress the content, but replaces all urls in CSS files and applies a Wicket representation for them by automatically wrapping them into PackageResourceReferences. Here is an example where you can see what Wicket does with the url representation.<p class="paragraph"/>HomePage (in package my/company/):
<strong class="bold">Java Code:</strong>
<div class="code"><pre>&#8230;
response.render(CssReferenceHeaderItem.forReference(<span class="java&#45;keyword">new</span> PackageResourceReference(HomePage.class, <span class="java&#45;quote">"res/css/mycss.css"</span>)));
...</pre></div><p class="paragraph"/>mycss.css (in package my/company/res/css/):
<strong class="bold">CSS:</strong>
<div class="code"><pre>&#8230;
body&#123;
¬†¬†¬† background&#45;image:url('../images/some.png');
&#125;
...</pre></div><p class="paragraph"/>some.png (in package my/company/res/images/):
&#60;blob&#62;<p class="paragraph"/>Output of mycss.css:
<strong class="bold">CSS:</strong>
<div class="code"><pre>&#8230;
body&#123;
¬†¬†¬† background&#45;image:url('../images/some&#45;ver&#45;1425904170000.png');
&#125;
...</pre></div><p class="paragraph"/>If you add a url which looks like this background-image:url('../images/some.png?embedBase64'); Wicket is going to embed the complete image as base64 string with its corresponding mime type into the css file. It looks like the following code block demonstrates.<p class="paragraph"/>Output of mycss.css:
<strong class="bold">CSS:</strong>
<div class="code"><pre>&#8230;
body&#123;
¬†¬†¬† background&#45;image: url(data:image/png;base64,R0lGODlh1wATAX....);
&#125;
...</pre></div>



<h2 id="resources_15">16.15 NIO resources</h2>
The FileSystemResourceRenference comes along with the FileSystemResource, FileSystemResourceStreamReference and the FileSystemResourceStream. Those classes provide a simple way to handle resources with Java's NIO API in Wicket starting from JDK version 7.0. (Available since Wicket 7.2.0 / Wicket 8.0.0)<p class="paragraph"/>Example: To include a resource which is zipped into a file and located in a specific folder in the file system you can simply write code like this:<p class="paragraph"/>Java:
<div class="code"><pre>URI uri = URI.create(<span class="java&#45;quote">"jar:file:///videosFolder/videos.zip!/folderInZip/Video.mp4"</span>);
Path path = FileSystemResourceReference.getPath(uri);
FileSystemResourceReference ref = <span class="java&#45;keyword">new</span> FileSystemResourceReference(<span class="java&#45;quote">"video"</span>,path);
Video video = <span class="java&#45;keyword">new</span> Video(<span class="java&#45;quote">"video"</span>,ref);
add(vide);</pre></div><p class="paragraph"/>HTML:
<div class="code"><pre>&#60;video wicket:id=<span class="java&#45;quote">"video"</span>/&#62;</pre></div><p class="paragraph"/>Using FileSystemResourceReference mounted:<p class="paragraph"/>Java:
<div class="code"><pre>mountResource(<span class="java&#45;quote">"/filecontent/$&#123;name&#125;"</span>, <span class="java&#45;keyword">new</span> FileSystemResourceReference(<span class="java&#45;quote">"filesystem"</span>)
&#123;
	<span class="java&#45;keyword">private</span> <span class="java&#45;keyword">static</span> <span class="java&#45;keyword">final</span> <span class="java&#45;object">long</span> serialVersionUID = 1L;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> IResource getResource()
	&#123;
		<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> FileSystemResource()
		&#123;
			<span class="java&#45;keyword">private</span> <span class="java&#45;keyword">static</span> <span class="java&#45;keyword">final</span> <span class="java&#45;object">long</span> serialVersionUID = 1L;<p class="paragraph"/>			<span class="java&#45;keyword">protected</span> ResourceResponse newResourceResponse(Attributes attributes)
			&#123;
				<span class="java&#45;keyword">try</span>
				&#123;
					<span class="java&#45;object">String</span> name = attributes.getParameters().get(<span class="java&#45;quote">"name"</span>).toString(<span class="java&#45;quote">""</span>);
					URI uri = URI.create(
						<span class="java&#45;quote">"jar:file:////folder/example.zip!/zipfolder/"</span> + name);
					<span class="java&#45;keyword">return</span> createResourceResponse(
						FileSystemResourceReference.getPath(uri));
				&#125;
				<span class="java&#45;keyword">catch</span> (IOException | URISyntaxException e)
				&#123;
					<span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> WicketRuntimeException(<span class="java&#45;quote">"Error <span class="java&#45;keyword">while</span> reading the file."</span>, e);
				&#125;
			&#125;;
		&#125;;
	&#125;
&#125;);</pre></div><p class="paragraph"/>FileSystemResourceReference.getPath(uri) uses a FileSystemPathService to setup a path the resource reference can work on.<p class="paragraph"/>So if you write a custom file system you can easily handle every path by adding a <strong class="bold">org.apache.wicket.resource.FileSystemPathService</strong> text file into <strong class="bold">META-INF/services</strong> and put in your implementation.<p class="paragraph"/>A reference implementation can be found in the java class org.apache.wicket.resource.FileSystemJarPathService.<p class="paragraph"/>Further FileSystemProviders and the corresponding FileSystems can be implemented as described here:<p class="paragraph"/><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/io/fsp/filesystemprovider.html" target="blank">http://docs.oracle.com/javase/7/docs/technotes/guides/io/fsp/filesystemprovider.html</a>


<h2 id="resources_16">16.16 Resourcen derived through models</h2>
Another way to receive external image resources is to use the corresponding component with a model which contains the target URL.<p class="paragraph"/>The ExternalImage and ExternalSource components which are available since Wicket 7.2.0 / Wicket 8.0.0 fulfill that task.<p class="paragraph"/>The following example demonstrates the usage of a CompoundPropertyModel with the model object "ImageSrc". The model object, bound to surrounding component / page, contains an attribute named "url" which is read by the component:<p class="paragraph"/>Java:
<div class="code"><pre>ImageSrc imageSrc = <span class="java&#45;keyword">new</span> ImageSrc();
imageSrc.setUrl(<span class="java&#45;quote">"http://www.google.de/test.jpg"</span>);
setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel&#60;&#62;(imageSrc));
add(<span class="java&#45;keyword">new</span> ExternalImage(<span class="java&#45;quote">"url"</span>));</pre></div><p class="paragraph"/>HTML:
<div class="code"><pre>&#60;img wicket:id=<span class="java&#45;quote">"url"</span> /&#62;</pre></div><p class="paragraph"/>The ExternalImage can also be constructed by passing in a Model (src) and Model of List (srcSet). For ExternalSource only the srcSet is available.


<h2 id="resources_17">16.17 Summary</h2>
<p class="paragraph"/>In this chapter we have learnt how to manage resources with the built-in mechanism provided by Wicket. With this mechanism we handle resources from Java code and Wicket will automatically take care of generating a valid URL for them. We have also seen how resources can be bundled as package resources with a component that depends on them to make it self-contained.<p class="paragraph"/>Then, in the second part of the chapter, we have built a custom resource and we have learnt how to mount it to an arbitrary URL and how to make it globally available as shared resource.<p class="paragraph"/>Finally, in the last part of the paragraph we took a peek at the mechanism provided by the framework to customize the locations where the resource-lookup algorithm searches for resources. 


<h1 id="jsintegration">17 An example of integration with JavaScript</h1>
It's time to put into practice what we have learnt so far in this guide. To do this we will build a custom date component consisting of a text field to edit a date value and a fancy calendar icon to open a JavaScript datepicker. This chapter will also illustrate an example of integration of Wicket with a JavaScript library like <a href="http://jquery.com/" target="blank">JQuery</a> and its child project <a href="http://jqueryui.com/" target="blank">JQuery UI</a> .


<h2 id="jsintegration_1">17.1 What we want to do...</h2>
<p class="paragraph"/>For end-users a datepicker is one of the most appreciated widget. It allows to simply edit a date value with the help of a user-friendly pop-up calendar. That's why nearly all UI frameworks provide a version of this widget.<p class="paragraph"/>Popular JavaScript libraries like YUI and JQuery come with a ready-to-use datepicker to enrich the user experience of our web applications. Wicket already provides a component which integrates a text field with a calendar widget from YUI library, but there is no built-in component that uses a datepicker based on JQuery library.<p class="paragraph"/>As both JQuery and its child project JQueryUI have gained a huge popularity in the last years, it's quite interesting to see how to integrate them in Wicket building a custom component. In this chapter we will create a custom datepicker based on the corresponding widget from JQueryUI project:<p class="paragraph"/><img border="0" class="center" src="../img/datepicker-screenshot.png"></img><p class="paragraph"/><blockquote class="warning">
On Internet you can find different libraries that already offer a strong integration between Wicket and JQuery. The goal of this chapter is to see how to integrate Wicket with a JavaScript framework building a simple homemade datepicker which is not intended to provide every feature of the original JavaScript widget.
</blockquote><p class="paragraph"/><h3>What features we want to implement</h3><p class="paragraph"/>Before starting to write code, we must clearly define what features we want to implement for our component. The new component should:
<ul class="star">
<li><strong class="bold">Be self-contained</strong>: we must be able to distribute it and use it in other projects without requiring any kind of additional configuration.</li>
<li><strong class="bold">Have a customizable date format</strong>: developer must be able to decide the date format used to display date value and to parse user input.</li>
<li><strong class="bold">Be localizable</strong>: the pop-up calendar must be localizable in order to support different languages.</li>
</ul><p class="paragraph"/>That's what we'd like to have with our custom datepicker. In the rest of the chapter we will see how to implement the features listed above and which resources must be packaged with our component.


<h2 id="jsintegration_2">17.2 ...and how we will do it</h2>
<p class="paragraph"/>Our new component will extend the a built-in text field <code>org.apache.wicket.extensions.markup.html.form.DateTextField</code> which already uses a java.util.Date as model object and already performs conversion and validation for input values. Since the component must be self-contained, we must ensure that the JavaScript libraries it relies on (JQuery and JQuery UI) will be always available.<p class="paragraph"/>Starting from version 6.0 Wicket has adopted JQuery as backing JavaScript library so we can use the  version bundled with Wicket for our custom datepicker.<p class="paragraph"/>To make JQuery UI available we should instead go to its official site, download the required artifacts and use them as package resources of our component.<p class="paragraph"/><h3>Component package resources</h3><p class="paragraph"/>JQuery UI needs the following static resources in order to work properly:
<ul class="star">
<li><strong class="bold">jquery-ui.min.js</strong>: the minified version of the library.</li>
<li><strong class="bold">jquery-ui.css</strong>: the CSS containing the style used by JQuery UI widgets.</li>
<li><strong class="bold">jquery-ui-i18n.min.js</strong>: the minified JavaScript containing the built-in support for localization.</li>
<li><strong class="bold">Folder 'images'</strong>: the folder containing picture files used by JQuery UI widgets.</li>
</ul><p class="paragraph"/>In the following picture we can see these package resources with our component class (named JQueryDateField):<p class="paragraph"/><img border="0" class="center" src="../img/datepicker-package-resources.png"></img><p class="paragraph"/>Along with the four static resources listed above, we can find also file calendar.jpg, which is the calendar icon used to open the pop up calendar, and file JQDatePicker.js which contains the following custom JavaScript code that binds our component to a JQuery UI datepicker:<p class="paragraph"/><div class="code"><pre>function initJQDatepicker(inputId, countryIsoCode, dateFormat,  calendarIcon) &#123;
	<span class="java&#45;keyword">var</span> localizedArray = $.datepicker.regional&#91;countryIsoCode&#93;;
	localizedArray&#91;'buttonImage'&#93; = calendarIcon;
	localizedArray&#91;'dateFormat'&#93; = dateFormat;
	initCalendar(localizedArray);
	$(<span class="java&#45;quote">"&#35;"</span> + inputId).datepicker(localizedArray);	
&#125;;<p class="paragraph"/>function initCalendar(localizedArray)&#123;
	 localizedArray&#91;'changeMonth'&#93;= <span class="java&#45;keyword">true</span>;
	 localizedArray&#91;'changeYear'&#93;= <span class="java&#45;keyword">true</span>;
	 localizedArray&#91;'showOn'&#93; = 'button';
	 localizedArray&#91;'buttonImageOnly'&#93; = <span class="java&#45;keyword">true</span>;
&#125;;</pre></div><p class="paragraph"/>Function initJQDatepicker takes in input the following parameters:
<ul class="star">
<li><strong class="bold">inputId</strong>: the id of the HTML text field corresponding to our custom component instance.</li>
<li><strong class="bold">countryIsoCode</strong>: a two-letter low-case ISO language code. It can contain also the two-letter upper-case ISO country code separated with a minus sign (for example en-GB)</li>
<li><strong class="bold">dateFormat</strong>: the date format to use for parsing and displaying date values.</li>
<li><strong class="bold">calendarIcon</strong>: the relative URL of the icon used as calendar icon.</li>
</ul><p class="paragraph"/>As we will see in the next paragraphs, its up to our component to generate this parameters and invoke the initJQDatepicker function.<p class="paragraph"/>Function initCalendar is a simple utility function that sets the initialization array for datepicker widget. For more details on JQuery UI datepicker usage see the documentation at http://jqueryui.com/ datepicker.<p class="paragraph"/><h3>Initialization code</h3><p class="paragraph"/>The initialization code for our component is contained inside its method onInitialize and is the following:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> void onInitialize() &#123;
	<span class="java&#45;keyword">super</span>.onInitialize();
	setOutputMarkupId(<span class="java&#45;keyword">true</span>);<p class="paragraph"/>	datePattern =  <span class="java&#45;keyword">new</span> ResourceModel(<span class="java&#45;quote">"jqueryDateField.shortDatePattern"</span>, <span class="java&#45;quote">"mm/dd/yy"</span>)
                                          .getObject();		
	countryIsoCode = <span class="java&#45;keyword">new</span> ResourceModel(<span class="java&#45;quote">"jqueryDateField.countryIsoCode"</span>, <span class="java&#45;quote">"en&#45;GB"</span>)                                                             
                                          .getObject();<p class="paragraph"/>	PackageResourceReference resourceReference = 
                            <span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"calendar.jpg"</span>);<p class="paragraph"/>	urlForIcon = urlFor(resourceReference, <span class="java&#45;keyword">new</span> PageParameters());
	dateConverter = <span class="java&#45;keyword">new</span> PatternDateConverter(datePattern, <span class="java&#45;keyword">false</span>);	
&#125;<p class="paragraph"/>@Override
<span class="java&#45;keyword">public</span> &#60;Date&#62; IConverter&#60;Date&#62; getConverter(<span class="java&#45;object">Class</span>&#60;Date&#62; type) &#123;
	<span class="java&#45;keyword">return</span> (IConverter&#60;Date&#62;) dateConverter;
&#125;</pre></div><p class="paragraph"/>The first thing to do inside onInitialize is to ensure that our component will have a markup id for its related text field. This is done invoking setOutputMarkupId(true).<p class="paragraph"/>Next, JQueryDateField tries to retrieve the date format and the ISO language code that must be used as initialization parameters. This is done using class <code>ResourceModel</code> which searches for a given resource in the available bundles. If no value is found for date format or for ISO language code, default values will be used ('mm/dd/yy' and 'en-GB').<p class="paragraph"/>To generate the relative URL for calendar icon, we load it as package resource reference and then we use <code>Component</code>'s method urlFor to get the URL value (we have seen this method in <a href="../guide/single.html#requestProcessing_3" class="guide">paragraph 9.3.2</a>).<p class="paragraph"/>The last configuration instruction executed inside onInitialize is the instantiation of the custom converter used by our component. This converter is an instance of the built-in class <code>org.apache.wicket.datetime.PatternDateConvert</code> and must use the previously retrieved date format to perform conversion operations. Now to tell our component to use this converter we must return it overriding <code>FormComponent</code>'s method <code>getConverter</code>.<p class="paragraph"/><h3>Header contributor code</h3><p class="paragraph"/>The rest of the code of our custom component is inside method <code>renderHeader</code>, which is responsible for adding to page header the bundled JQuery library, the three files from JQuery UI distribution, the custom file JQDatePicker.js and the invocation of function <code>initJQDatepicker</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void renderHead(IHeaderResponse response) &#123;
	<span class="java&#45;keyword">super</span>.renderHead(response);<p class="paragraph"/>	//<span class="java&#45;keyword">if</span> component is disabled we don't have to load the JQueryUI datepicker
	<span class="java&#45;keyword">if</span>(!isEnabledInHierarchy())
		<span class="java&#45;keyword">return</span>;
	//add bundled JQuery
	JavaScriptLibrarySettings javaScriptSettings =          
                      getApplication().getJavaScriptLibrarySettings();
	response.render(JavaScriptHeaderItem.
			forReference(javaScriptSettings.getJQueryReference()));
	//add <span class="java&#45;keyword">package</span> resources
	response.render(JavaScriptHeaderItem.
	      forReference(<span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"jquery&#45;ui.min.js"</span>)));
	response.render(JavaScriptHeaderItem.
	      forReference(<span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"jquery&#45;ui&#45;i18n.min.js"</span>)));
	response.render(CssHeaderItem.
	      forReference(<span class="java&#45;keyword">new</span> PackageResourceReference(getClass(), <span class="java&#45;quote">"jquery&#45;ui.css"</span>)));
	//add custom file JQDatePicker.js. Reference JQDatePickerRef is a <span class="java&#45;keyword">static</span> field
	response.render(JavaScriptHeaderItem.forReference(JQDatePickerRef));<p class="paragraph"/>	//add the init script <span class="java&#45;keyword">for</span> datepicker
	<span class="java&#45;object">String</span> jqueryDateFormat = datePattern.replace(<span class="java&#45;quote">"yyyy"</span>, <span class="java&#45;quote">"yy"</span>).toLowerCase();
	<span class="java&#45;object">String</span> initScript = <span class="java&#45;quote">";initJQDatepicker('"</span> + getMarkupId() + <span class="java&#45;quote">"', '"</span> + countryIsoCode +
                            <span class="java&#45;quote">"', '"</span> + jqueryDateFormat + <span class="java&#45;quote">"', "</span> + <span class="java&#45;quote">"'"</span> + urlForIcon +<span class="java&#45;quote">"');"</span>;
	response.render(OnLoadHeaderItem.forScript(initScript));
&#125;</pre></div><p class="paragraph"/>If component is disabled the calendar icon must be hidden and no datepicker must be displayed. That's why <code>renderHeader</code> is skipped if component is not enabled.<p class="paragraph"/>To get a reference to the bundled JQuery library we used the JavaScript setting class <code>JavaScriptLibrarySettings</code> and its method <code>getJQueryReference</code>.<p class="paragraph"/>In the last part of <code>renderHeader</code> we build the string to invoke function <code>initJQDatepicker</code> using the values obtained inside onInitialize. Unfortunately the date format used by JQuery UI is different from the one adopted in Java so we have to convert it before building the JavaScript code. This init script is rendered into header section using a <code>OnLoadHeaderItem</code> to ensure that it will be executed after all the other scripts have been loaded.<p class="paragraph"/><blockquote class="note">
If we add more than one instance of our custom component to a single page, static resources are rendered to the header section just once. Wicket automatically checks if a static resource is already referenced by a page and if so, it will not render it again.<p class="paragraph"/>This does not apply to the init script which is dynamically generated and is rendered for every instance of the component.
</blockquote><p class="paragraph"/><blockquote class="warning">
Our datepicker is not ready yet to be used with AJAX. In <a href="../guide/single.html#ajax" class="guide">chapter 19</a> we will see how to modify it to make it AJAX-compatible.
</blockquote>



<h2 id="jsintegration_3">17.3 Summary</h2>
<p class="paragraph"/>In this brief chapter we have seen how custom components can be integrated with <a href="http://en.wikipedia.org/wiki/Dynamic_HTML" target="blank">DHTML</a> technologies. To do so we have used most of what we have learnt in this guide. Now we are able to build complex components with a rich user experience. However this is not enough yet to develop <a href="http://en.wikipedia.org/wiki/Web_2.0" target="blank">Web 2.0</a> applications. We still have to cover a fundamental technology like AJAX and some other Wicket-related topics that will help us building our application in more modular and efficient way.<p class="paragraph"/><p class="paragraph"/>


<h1 id="advanced">18 Wicket advanced topics</h1>
In this chapter we will learn some advanced topics which have not been covered yet in the previous chapters but which are nonetheless essential to make the most of Wicket and to build sophisticated web applications.


<h2 id="advanced_1">18.1 Enriching components with behaviors</h2>
<p class="paragraph"/>With class <code>org.apache.wicket.behavior.Behavior</code> Wicket provides a very flexible mechanism to share common features across different components and to enrich existing components with further functionalities. As the class name suggests, <code>Behavior</code> adds a generic behavior to a component modifying its markup and/or contributing to the header section of the page (<code>Behavior</code> implements the interface <code>IHeaderContributor</code>).<p class="paragraph"/>One or more behaviors can be added to a component with <code>Component</code>'s method <code>add(Behavior...)</code>, while to remove a behavior we must use method <code>remove(Behavior)</code>.<p class="paragraph"/>Here is a partial list of methods defined inside class <code>Behavior</code> along with a brief description of what they do:
<ul class="star">
<li><strong class="bold">beforeRender(Component component)</strong>: called when a component is about to be rendered.</li>
<li><strong class="bold">afterRender(Component component)</strong>: called after a component has been rendered.</li>
<li><strong class="bold">onComponentTag(Component component, ComponentTag tag)</strong>: called when component tag is being rendered.</li>
<li><strong class="bold">getStatelessHint(Component component)</strong>: returns if a behavior is stateless or not.</li>
<li><strong class="bold">bind(Component component)</strong>: called after a behavior has been added to a component.</li>
<li><strong class="bold">unbind(Component component)</strong>: called when a behavior has been removed from a component.</li>
<li><strong class="bold">detach(Component component)</strong>: overriding this method a behavior can detach its state before being serialized.</li>
<li><strong class="bold">isEnabled(Component component)</strong>: tells if the current behavior is enabled for a given component. When a behavior is disabled it will be simply ignored and not executed.</li>
<li><strong class="bold">isTemporary(Component component)</strong>: tells component if the current behavior is temporary. A temporary behavior is discarded at the end of the current request (i.e it's executed only once).</li>
<li><strong class="bold">onConfigure(Component component)</strong>: called right after the owner component has been configured.</li>
<li><strong class="bold">onRemove(Component component)</strong>: called when the owner component has been removed from its container.</li>
<li><strong class="bold">renderHead(Component component, IHeaderResponse response)</strong>: overriding this method behaviors can render resources to the header section of the page.</li>
</ul><p class="paragraph"/>For example the following behavior prepends a red asterisk to the tag of a form component if this one  is required:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class RedAsteriskBehavior <span class="java&#45;keyword">extends</span> Behavior &#123;<p class="paragraph"/>  @Override
  <span class="java&#45;keyword">public</span> void beforeRender(Component component) &#123;
      Response response = component.getResponse();
      <span class="java&#45;object">StringBuffer</span> asterisktHtml = <span class="java&#45;keyword">new</span> <span class="java&#45;object">StringBuffer</span>(200);<p class="paragraph"/>      <span class="java&#45;keyword">if</span>(component <span class="java&#45;keyword">instanceof</span> FormComponent 
            &#38;&#38; ((FormComponent)component).isRequired())&#123;
        asteriskHtml.append(<span class="java&#45;quote">" &#60;b style=&#34;color:red;font&#45;size:medium&#34;&#62;&#42;&#60;/b&#62;"</span>);
      &#125;  
      response.write(asteriskHtml);
  &#125;
&#125;</pre></div><p class="paragraph"/>Since method <code>beforeRender</code> is called before the coupled component is rendered, we can use it to prepend custom markup to component tag. This can be done writing our markup directly to the current  Response object, as we did in the example above.<p class="paragraph"/>Please note that we could achieve the same result overriding component method <code>onBeforeRender</code>. However using a behavior we can easily reuse our custom code with any other kind of component without modifying its source code. As general best practice we should always consider to implement a new functionality using a behavior if it can be shared among different kinds of component.<p class="paragraph"/>Behaviors play also a strategic role in the built-in AJAX support provided by Wicket, as we will see in the next chapter. 



<h2 id="advanced_2">18.2 Generating callback URLs with IRequestListener</h2>
<p class="paragraph"/>With Wicket it's quite easy to build a callback URL that executes a specific method on server side. This method must be defined in a functional interface (i.e. an an interface that defines just one method) that inherits from built-in <code>org.apache.wicket.IRequestListener</code> and it must be a void method with no parameters in input:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">interface</span> IMyListener <span class="java&#45;keyword">extends</span> IRequestListener
&#123;
	/&#42;&#42;
	 &#42; Called when the relative callback URL is requested.
	 &#42;/
	void myCallbackMethod();
&#125;</pre></div><p class="paragraph"/>To control how the method will be invoked we must use class <code>org.apache.wicket.RequestListenerInterface</code>. In Wicket is a common practice to instantiate this class as a public static field inside the relative callback interface:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">interface</span> IMyListener <span class="java&#45;keyword">extends</span> IRequestListener
&#123;
	/&#42;&#42;RequestListenerInterface instance&#42;/
	<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> <span class="java&#45;keyword">final</span> RequestListenerInterface INTERFACE = <span class="java&#45;keyword">new</span> 
                               RequestListenerInterface(IMyListener.class);
	/&#42;&#42;
	 &#42; Called when the relative callback URL is requested.
	 &#42;/
	void myCallbackMethod();
&#125;</pre></div><p class="paragraph"/>By default <code>RequestListenerInterface</code> will respond rendering the current page after the callback method has been executed (if we have a non-AJAX request). To change this behavior we can use setter method <code>setRenderPageAfterInvocation(boolean)</code>.<p class="paragraph"/>Now that our callback interface is complete we can generate a callback URL with <code>Component</code>'s method <code>urlFor(RequestListenerInterface, PageParameters)</code> or with method <code>urlFor (Behavior, RequestListenerInterface, PageParameters)</code> if we are using a callback interface with a behavior (see the following example).<p class="paragraph"/>Project CallbackURLExample contains a behavior (class <code>OnChangeSingleChoiceBehavior</code>) that implements a callback interface to update the model of an <code>AbstractSingleSelectChoice</code> component when user changes the selected option (it provides the same functionality of method <code>wantOnSelectionChangedNotifications</code>).<p class="paragraph"/>Instead of a custom callback interface, <code>OnChangeSingleChoiceBehavior</code> implements built-in interface <code>org.apache.wicket.behavior.IBehaviorListener</code> which is designed to generate a callback URL for behaviors. The callback method defined in this interface is <code>onRequest()</code> and the following is the implementation provided by <code>OnSelectionChangedNotifications</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void onRequest() &#123;	
	Request request = RequestCycle.get().getRequest();
	IRequestParameters requestParameters = request.getRequestParameters();
	StringValue choiceId = requestParameters.getParameterValue(<span class="java&#45;quote">"choiceId"</span>);
	//boundComponent is the component that the behavior it is bound to.
	boundComponent.setDefaultModelObject( convertChoiceIdToChoice(choiceId.toString()));
&#125;</pre></div><p class="paragraph"/>When invoked via URL, the behavior expects to find a request parameter (choiceId) containing the id of the selected choice. This value is used to obtain the corresponding choice object that must be used to set the model of the component that the behavior is bound to (boundComponent). Method <code>convertChoiceIdToChoice</code> is in charge of retrieving the choice object given its id and it has been copied from class <code>AbstractSingleSelectChoice</code>.<p class="paragraph"/>Another interesting part of <code>OnChangeSingleChoiceBehavior</code> is its method <code>onComponentTag</code> where some JavaScript ‚Äúmagic‚Äù is used to move user's browser to the callback URL when event ‚Äúchange‚Äù occurs on bound component:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void onComponentTag(Component component, ComponentTag tag) &#123;
	<span class="java&#45;keyword">super</span>.onComponentTag(component, tag);<p class="paragraph"/>	CharSequence callBackURL = getCallbackUrl();
	<span class="java&#45;object">String</span> separatorChar = (callBackURL.toString().indexOf('?') &#62; &#45;1 ? <span class="java&#45;quote">"&#38;"</span> : <span class="java&#45;quote">"?"</span>);<p class="paragraph"/>	<span class="java&#45;object">String</span> finalScript = <span class="java&#45;quote">"<span class="java&#45;keyword">var</span> isSelect = $(<span class="java&#45;keyword">this</span>).is('select');&#110;"</span> +
				 <span class="java&#45;quote">"<span class="java&#45;keyword">var</span> component;&#110;"</span> +	
				 <span class="java&#45;quote">"<span class="java&#45;keyword">if</span>(isSelect)&#110;"</span> +
				 <span class="java&#45;quote">"	component = $(<span class="java&#45;keyword">this</span>);&#110;"</span> +
				 <span class="java&#45;quote">"<span class="java&#45;keyword">else</span> &#110;"</span> +
				 <span class="java&#45;quote">"	component = $(<span class="java&#45;keyword">this</span>).find('input:radio:checked');&#110;"</span> +
				 <span class="java&#45;quote">"window.location.href='"</span> + callBackURL +  separatorChar + 
				 <span class="java&#45;quote">"choiceId=' + "</span> + <span class="java&#45;quote">"component.val()"</span>;<p class="paragraph"/>	tag.put(<span class="java&#45;quote">"onchange"</span>, finalScript);
&#125;</pre></div><p class="paragraph"/>The goal of <code>onComponentTag</code> is to build an onchange handler that forces user's browser to move to the callback URL (modifing standard property window.location.href). Please note that we have appended the expected parameter (choiceId) to the URL retrieving its value with a JQuery selector suited for the current type of component (a drop-down menu or a radio group). Since we are using JQuery in our JavaScript code, the behavior comes also with method <code>renderHead</code> that adds the bundled JQuery library to the current page.<p class="paragraph"/>Method <code>getCallbackUrl()</code> is used to generate the callback URL for our custom behavior and it has been copied from built-in class <code>AbstractAjaxBehavior</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> CharSequence getCallbackUrl()&#123;
	<span class="java&#45;keyword">if</span> (boundComponent == <span class="java&#45;keyword">null</span>)&#123;
		<span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> IllegalArgumentException(
			<span class="java&#45;quote">"Behavior must be bound to a component to create the URL"</span>);
	&#125;<p class="paragraph"/>	<span class="java&#45;keyword">final</span> RequestListenerInterface rli;<p class="paragraph"/>	rli = IBehaviorListener.INTERFACE;<p class="paragraph"/>	<span class="java&#45;keyword">return</span> boundComponent.urlFor(<span class="java&#45;keyword">this</span>, rli, <span class="java&#45;keyword">new</span> PageParameters());
&#125;</pre></div><p class="paragraph"/>Static field <code>IBehaviorListener.INTERFACE</code> is the implementation of <code>RequestListenerInterface</code> defined inside callback interface <code>IBehaviorListener</code>.<p class="paragraph"/>The home page of project <code>CallbackURLExample</code> contains a <code>DropDownChoice</code> and a <code>RadioChoice</code> which use our custom behavior. There are also two labels to display the content of the models of the two components:<p class="paragraph"/><img border="0" class="center" src="../img/CallbackURLExample-screenshot.png"></img><p class="paragraph"/><blockquote class="note">
Implementing interface <code>IBehaviorListener</code> makes a behavior stateful because its callback URL is specific for a given instance of component.
</blockquote><p class="paragraph"/>As final note it's interesting to see how Wicket internally uses callback URLs for its standard link component. Class <code>org.apache.wicket.markup.html.link.Link</code> implements interface <code>org.apache.wicket.markup.html.link.ILinkListener</code> which in turn extends <code>IRequestListener</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">interface</span> ILinkListener <span class="java&#45;keyword">extends</span> IRequestListener
&#123;
	/&#42;&#42; Listener <span class="java&#45;keyword">interface</span> &#42;/
	<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> <span class="java&#45;keyword">final</span> RequestListenerInterface INTERFACE = <span class="java&#45;keyword">new</span> RequestListenerInterface(
		ILinkListener.class);<p class="paragraph"/>	/&#42;&#42;
	 &#42; Called when a link is clicked.
	 &#42;/
	void onLinkClicked();
&#125;</pre></div><p class="paragraph"/>The implementation of method <code>onLinkClicked</code> simply delegates event handling to our custom version of <code>onClick</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">final</span> void onLinkClicked()
&#123;
	// Invoke subclass handler
	onClick();
&#125;</pre></div><p class="paragraph"/><h3>Wicket events infrastructure</h3><p class="paragraph"/>Starting from version 1.5 Wicket offers an event-based infrastructure for inter-component communication. The infrastructure is based on two simple interfaces (both in package <code>org.apache.wicket.event</code>) : <code>IEventSource</code> and <code>IEventSink</code>.<p class="paragraph"/>The first interface must be implemented by those entities that want to broadcast en event while the second interface must be implemented by those entities that want to receive a broadcast event.<p class="paragraph"/>The following entities already implement both these two interfaces (i.e. they can be either sender or receiver): <code>Component</code>, <code>Session</code>, <code>RequestCycle</code> and <code>Application</code>.
<code>IEventSource</code> exposes a single method named send which takes in input three parameters:
<ul class="star">
<li><strong class="bold">sink</strong>: an implementation of <code>IEventSink</code> that will be the receiver of the event.</li>
<li><strong class="bold">broadcast</strong>: a <code>Broadcast</code> enum which defines the broadcast method used to dispatch the event to the sink and to other entities such as sink children, sink containers, session object, application object and the current request cycle. It has four possible values:</li>
</ul><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Value</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>BREADTH</td><td>The event is sent first to the specified sink and then to all its children components following a breadth-first order.</td></tr><tr class="table-even"><td>DEPTH</td><td>The event is sent to the specified sink only after it has been dispatched to all its children components following a depth-first order.</td></tr><tr class="table-odd"><td>BUBBLE</td><td>The event is sent first to the specified sink and then to its parent containers.</td></tr><tr class="table-even"><td>EXACT</td><td>The event is sent only to the specified sink.</td></tr></table>
<ul class="star">
<li><strong class="bold">payload</strong>: a generic object representing the data sent with the event.</li>
</ul><p class="paragraph"/>Each broadcast mode has its own traversal order for <code>Session</code>, <code>RequestCycle</code> and <code>Application</code>. See JavaDoc of class <code>Broadcast</code> for further details about this order.<p class="paragraph"/>Interface <code>IEventSink</code> exposes callback method <code>onEvent(IEvent&#60;?&#62; event)</code> which is triggered when a sink receives an event. The interface <code>IEvent</code> represents the received event and provides getter methods to retrieve the event broadcast type, the source of the event and its payload. Typically the received event is used checking the type of its payload object:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void onEvent(IEvent event) &#123;
  //<span class="java&#45;keyword">if</span> the type of payload is MyPayloadClass perform some actions 
  <span class="java&#45;keyword">if</span>(event.getPayload() <span class="java&#45;keyword">instanceof</span> MyPayloadClass) &#123;
     //execute some business code.
  &#125;<span class="java&#45;keyword">else</span>&#123;
     //other business code
  &#125;   		
&#125;</pre></div><p class="paragraph"/>Project <code>InterComponetsEventsExample</code> provides a concrete example of sending an event to a component (named 'container in the middle') using all the available broadcast methods:<p class="paragraph"/><img border="0" class="center" src="../img/InterComponentsEventsExample-screenshot.png"></img>



<h2 id="advanced_3">18.3 Initializers</h2>
<p class="paragraph"/>Some components or resources may need to be configured before being used in our applications. While so far we used Application's init method to initialize these kinds of entities, Wicket offers a more flexible and modular way to configure our classes.<p class="paragraph"/>During application's bootstrap Wicket searches for any properties file placed in one of the '/META-INF/wicket/' folder visible to the application classpath. When one of these files is found, the initializer defined inside it will be executed. An initializer is an implementation of interface <code>org.apache.wicket.IInitializer</code> and is defined inside a properties with a line like this:<p class="paragraph"/><div class="code"><pre>initializer=org.wicketTutorial.MyInitializer</pre></div><p class="paragraph"/>The fully qualified class name corresponds to the initializer that must be executed. Interface <code>IInitializer</code> defines method init(Application) which should contain our initialization code, and method <code>destroy(Application)</code> which is invoked when application is terminated:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class MyInitializer <span class="java&#45;keyword">implements</span> IInitializer&#123;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> void init(Application application) &#123;
		//initialization code 
	&#125;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> void destroy(Application application) &#123;
		//code to execute when application is terminated
	&#125;	
&#125;</pre></div><p class="paragraph"/>Only one initializer can be defined in a single properties file. To overcome this limit we can create a main initializer that in turn executes every initializer we need:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class MainInitializer <span class="java&#45;keyword">implements</span> IInitializer&#123;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> void init(Application application) &#123;
		<span class="java&#45;keyword">new</span> AnotherInitializer().init(application);
		<span class="java&#45;keyword">new</span> YetAnotherInitializer().init(application);
		//&#8230; 
	&#125;
	//destroy&#8230; 
&#125;</pre></div>



<h2 id="advanced_4">18.4 Using JMX with Wicket</h2>
<p class="paragraph"/>JMX (Java Management Extensions) is the standard technology adopted in Java for managing and monitoring running applications or Java Virtual Machines. Wicket offers support for JMX through module wicket-jmx. In this paragraph we will see how we can connect to a Wicket application using JMX. In our example we will use JConsole as JMX client. This program is bundled with Java SE since version 5 and we can run it typing jconsole in our OS shell.<p class="paragraph"/>Once JConsole has started it will ask us to establish a new connection to a Java process, choosing between a local process or a remote one. In the following picture we have selected the process corresponding to the local instance of Jetty server we used to run one of our example projects:<p class="paragraph"/><img border="0" class="center" src="../img/JMX-new-connection.png"></img><p class="paragraph"/>After we have established a JMX connection, JConsole will show us the following set of tabs:<p class="paragraph"/><img border="0" class="center" src="../img/JMX-console.png"></img><p class="paragraph"/>JMX exposes application-specific informations using special objects called MBeans (Manageable Beans), hence if we want to control our application we must open the corresponding tab. The MBeans containing the application's informations is named <code>org.apache.wicket.app.&#60;filter/servlet name&#62;</code>.<p class="paragraph"/>In our example we have used wicket.test as filter name for our application:<p class="paragraph"/><img border="0" class="center" src="../img/JMX-console2.png"></img><p class="paragraph"/>As we can see in the picture above, every MBean exposes a node containing its attributes and another node showing the possible operations that can be performed on the object. In the case of a Wicket application the available operations are clearMarkupCache and clearLocalizerCache:<p class="paragraph"/><img border="0" class="center" src="../img/JMX-console3.png"></img><p class="paragraph"/>With these two operations we can force Wicket to clear the internal caches used to load components markup and resource bundles. This can be particularly useful if we have our application running in DEPLOYMENT mode and we want to publish minor fixes for markup or bundle files (like spelling or typo corrections) without restarting the entire application. Without cleaning these two caches Wicket would continue to use cached values ignoring any change made to markup or bundle files.<p class="paragraph"/>Some of the exposed properties are editable, hence we can tune their values while the application is running. For example if we look at the properties of <code>ApplicationSettings</code> we can set the maximum size allowed for an upload modifying the attribute DefaultMaximumUploadSize:<p class="paragraph"/><img border="0" class="center" src="../img/JMX-console4.png"></img>


<h2 id="advanced_5">18.5 Generating HTML markup from code</h2>
<p class="paragraph"/>So far, as markup source for our pages/panels we have used a static markup file, no matter if it was inherited or directly associated to the component. Now we want to investigate a more complex use case where we want to dynamical generate the markup directly inside component code.<p class="paragraph"/>To become a markup producer, a component must simply implement interface <code>org.apache.wicket.markup.IMarkupResourceStreamProvider</code>. The only method defined in this interface is <code>getMarkupResourceStream(MarkupContainer, Class&#60;?&#62;)</code> which returns an utility interface called <code>IResourceStream</code> representing the actual markup.<p class="paragraph"/>In the following example we have a custom panel without a related markup file that generates a simple &#60;div&#62; tag as markup:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class AutoMarkupGenPanel <span class="java&#45;keyword">extends</span> Panel <span class="java&#45;keyword">implements</span> IMarkupResourceStreamProvider &#123;
	<span class="java&#45;keyword">public</span> AutoMarkupGenPanel(<span class="java&#45;object">String</span> id, IModel&#60;?&#62; model) &#123;
		<span class="java&#45;keyword">super</span>(id, model);		
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> IResourceStream getMarkupResourceStream(MarkupContainer container,
			<span class="java&#45;object">Class</span>&#60;?&#62; containerClass) &#123;
		<span class="java&#45;object">String</span> markup = <span class="java&#45;quote">"&#60;wicket:panel&#62;&#60;div&#62;Panel markup&#60;/div&#62;&#60;/wicket:panel&#62;"</span>;
		StringResourceStream resourceStream = <span class="java&#45;keyword">new</span> StringResourceStream(markup);<p class="paragraph"/>		<span class="java&#45;keyword">return</span> resourceStream;
	&#125;
&#125;</pre></div><p class="paragraph"/>Class StringResourceStream is a resource stream that uses a String instance as backing object.<p class="paragraph"/><h3>Avoiding markup caching</h3><p class="paragraph"/>As we have seen in the previous paragraph, Wicket uses an internal cache for components markup. This can be a problem if our component dynamical generates its markup when it is rendered because once the markup has been cached, Wicket will always use the cached version for the specific component. To overwrite this default caching policy, a component can implement interface <code>IMarkupCacheKeyProvider</code>.<p class="paragraph"/>This interface defines method <code>getCacheKey(MarkupContainer, Class&#60;?&#62;)</code> which returns a string value representing the key used by Wicket to retrieve the markup of the component from the cache. If this value is null the markup will not be cached, allowing the component to display the last generated markup each time it is rendered:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class NoCacheMarkupPanel <span class="java&#45;keyword">extends</span> Panel <span class="java&#45;keyword">implements</span> IMarkupCacheKeyProvider &#123;
	<span class="java&#45;keyword">public</span> NoCacheMarkupPanel(<span class="java&#45;object">String</span> id, IModel&#60;?&#62; model) &#123;
		<span class="java&#45;keyword">super</span>(id, model);		
	&#125;<p class="paragraph"/>	/&#42;&#42;
	&#42; Generate a dynamic HTML markup that changes every time
	&#42; the component is rendered
	&#42;/
	@Override
	<span class="java&#45;keyword">public</span> IResourceStream getMarkupResourceStream(MarkupContainer container,
			<span class="java&#45;object">Class</span>&#60;?&#62; containerClass) &#123;
		<span class="java&#45;object">String</span> markup = <span class="java&#45;quote">"&#60;wicket:panel&#62;&#60;div&#62;Panel with current nanotime: "</span> + <span class="java&#45;object">System</span>.nanoTime() +
				 <span class="java&#45;quote">"&#60;/div&#62;&#60;/wicket:panel&#62;"</span>;
		StringResourceStream resourceStream = <span class="java&#45;keyword">new</span> StringResourceStream(markup);<p class="paragraph"/>		<span class="java&#45;keyword">return</span> resourceStream;
	&#125;<p class="paragraph"/>	/&#42;&#42;
	&#42; Avoid markup caching <span class="java&#45;keyword">for</span> <span class="java&#45;keyword">this</span> component
	&#42;/
	@Override
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getCacheKey(MarkupContainer arg0, <span class="java&#45;object">Class</span>&#60;?&#62; arg1) &#123;
		<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>;
	&#125;
&#125;</pre></div>



<h2 id="advanced_6">18.6 Summary</h2>
<p class="paragraph"/>In this chapter we have introduced some advanced topics we didn't have the chance to cover yet. We have started talking about behaviors and we have seen how they can be used to enrich existing components (promoting a component-oriented approach). Behaviors are also fundamental to work with AJAX in Wicket, as we will see in the next chapter.<p class="paragraph"/>After behaviors we have learnt how to generate callback URLs to execute a custom method on server side defined inside a specific callback interface.<p class="paragraph"/>The third topic of the chapter has been the event infrastructure provided in Wicket for inter-component communication which brings to our components a desktop-like event-driven architecture.<p class="paragraph"/>Then, we have introduced a new entity called initializer which can be used to configure resources and component in a modular and self-contained way.<p class="paragraph"/>We have also looked at Wicket support for JMX and we have seen how to use this technology for monitoring and managing our running applications.<p class="paragraph"/>Finally we have introduced a new technique to generate the markup of a component from its Java code.<p class="paragraph"/><p class="paragraph"/>



<h1 id="ajax">19 Working with AJAX</h1>
AJAX has become a must-have for nearly all kinds of web application. This technology does not only help to achieve a better user experience but it also allows to improve the bandwidth performance of web applications. Using AJAX usually means writing tons of JavaScript code to handle asynchronous requests and to update user interface, but with Wicket we can leave all this boilerplate code to the framework and we don't even need to write a single line of JavaScript to start using AJAX.<p class="paragraph"/>In this chapter we will learn how to leverage the AJAX support provided by Wicket to make our applications fully <a href="http://en.wikipedia.org/wiki/Web_2.0" target="blank">Web 2.0</a> compliant.


<h2 id="ajax_1">19.1 How to use AJAX components and behaviors</h2>
<p class="paragraph"/>Wicket support for AJAX is implemented in file wicket-ajax-jquery.js which makes complete transparent to Java code any detail about AJAX communication.<p class="paragraph"/>AJAX components and behaviors shipped with Wicket expose one or more callback methods which are executed when they receive an AJAX request. One of the arguments of these methods is an instance of interface <code>org.apache.wicket.ajax.AjaxRequestTarget</code>.<p class="paragraph"/>For example component AjaxLink (in package <code>org.apache.wicket.ajax.markup.html</code>) defines abstract method <code>onClick(AjaxRequestTarget target)</code> which is executed when user clicks on the component:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> AjaxLink(<span class="java&#45;quote">"ajaxLink"</span>)&#123;
	@Override
	<span class="java&#45;keyword">public</span> void onClick(AjaxRequestTarget target) &#123;
	    //some server side code&#8230;
	&#125;  	
&#125;;</pre></div><p class="paragraph"/>Using AjaxRequestTarget we can specify the content that must be sent back to the client as response to the current AJAX request. The most commonly used method of this interface is probably <code>add(Component&#8230; components)</code>. With this method we tell Wicket to render again the specified components and refresh their markup via AJAX:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> AjaxLink(<span class="java&#45;quote">"ajaxLink"</span>)&#123;
	@Override
	<span class="java&#45;keyword">public</span> void onClick(AjaxRequestTarget target) &#123;
	    //modify the model of a label and refresh it on browser
	    label.setDefaultModelObject(<span class="java&#45;quote">"Another value 4 label."</span>);
	    target.add(label);
	&#125;  	
&#125;;</pre></div><p class="paragraph"/>Components can be refreshed via Ajax only if they have rendered a markup id for their related tag. As a consequence, we must remember to set a valid id value on every component we want to add to <code>AjaxRequestTarget</code>. This can be done using one of the two methods seen in <a href="../guide/single.html#keepControl_3" class="guide">paragraph 6.3</a>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">final</span> Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"labelComponent"</span>, <span class="java&#45;quote">"Initial value."</span>);
//autogenerate a markup id
label.setOutputMarkupId(<span class="java&#45;keyword">true</span>);
add(label);
//&#8230;
<span class="java&#45;keyword">new</span> AjaxLink(<span class="java&#45;quote">"ajaxLink"</span>)&#123;
	@Override
	<span class="java&#45;keyword">public</span> void onClick(AjaxRequestTarget target) &#123;
	    //modify the model of a label and refresh it on client side
	    label.setDefaultModelObject(<span class="java&#45;quote">"Another value 4 label."</span>);
	    target.add(label);
	&#125;  	
&#125;;</pre></div><p class="paragraph"/>Another common use of AjaxRequestTarget is to prepend or append some JavaScript code to the generated response. For example the following AJAX link displays an alert box as response to user's click:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> AjaxLink(<span class="java&#45;quote">"ajaxLink"</span>)&#123;
	@Override
	<span class="java&#45;keyword">public</span> void onClick(AjaxRequestTarget target) &#123;
	    target.appendJavaScript(<span class="java&#45;quote">";alert('Hello!!');"</span>);
	&#125;  	
&#125;;</pre></div><p class="paragraph"/><blockquote class="warning">
Repeaters component that have <code>org.apache.wicket.markup.repeater.AbstractRepeater</code> as base class (like <code>ListView</code>, <code>RepeatingView</code>, etc...) can not be directly updated via AJAX.<p class="paragraph"/>If we want to refresh their markup via AJAX we must add one of their parent containers to the <code>AjaxRequestTarget</code>.
</blockquote><p class="paragraph"/>The standard implementation of <code>AjaxRequestTarget</code> used by Wicket is class <code>org.apache.wicket.ajax.AjaxRequestHandler</code>. To create new instances of <code>AjaxRequestTarget</code> a Wicket application uses the provider object registered with method <code>setAjaxRequestTargetProvider</code>:<p class="paragraph"/><div class="code"><pre>setAjaxRequestTargetProvider(
		IContextProvider&#60;AjaxRequestTarget, Page&#62; ajaxRequestTargetProvider)</pre></div><p class="paragraph"/>The provider is an implementation of interface <code>org.apache.wicket.util.IContextProvider</code>, hence to use custom implementations of <code>AjaxRequestTarget</code> we must register a custom provider that returns the desired implementation:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">private</span> <span class="java&#45;keyword">static</span> class MyCustomAjaxRequestTargetProvider <span class="java&#45;keyword">implements</span>
		IContextProvider&#60;AjaxRequestTarget, Page&#62;
	&#123;
		@Override
		<span class="java&#45;keyword">public</span> AjaxRequestTarget get(Page page)
		&#123;
			<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> MyCustomAjaxRequestTarget();
		&#125;
	&#125;</pre></div><p class="paragraph"/><blockquote class="note">
During request handling <code>AjaxRequestHandler</code> sends an event to its application to notify the entire component hierarchy of the current page:<p class="paragraph"/><div class="code"><pre>//'page' is the associated Page instance
   page.send(app, Broadcast.BREADTH, <span class="java&#45;keyword">this</span>);</pre></div><p class="paragraph"/>The payload of the event is the <code>AjaxRequestHandler</code> itself.
</blockquote>



<h2 id="ajax_2">19.2 Build-in AJAX components</h2>
<p class="paragraph"/>Wicket distribution comes with a number of built-in AJAX components ready to be used. Some of them are the ajaxified version of common components like links and buttons, while others are AJAX-specific components.<p class="paragraph"/>AJAX components are not different from any other component seen so far and they don't require any additional configuration to be used. As we will shortly see, switching from a classic link or button to the ajaxified version is just a matter of prepending ‚ÄúAjax‚Äù to the component class name.<p class="paragraph"/>This paragraph provides an overview of what we can find in Wicket to start writing AJAX-enhanced web applications.<p class="paragraph"/><h3>Links and buttons</h3><p class="paragraph"/>In the previous paragraph we have already introduced component AjaxLink. Wicket provides also the ajaxified versions of submitting components SubmitLink and Button which are simply called AjaxSubmitLink and AjaxButton. These components come with a version of methods onSubmit, onError and onAfterSubmit that takes in input also an instance of <code>AjaxRequestTarget</code>.<p class="paragraph"/>Both components are in package <code>org.apache.wicket.ajax.markup.html.form</code>.<p class="paragraph"/><h3>Fallback components</h3><p class="paragraph"/>Building an entire site using AJAX can be risky as some clients may not support this technology. In order to provide an usable version of our site also to these clients, we can use components <code>AjaxFallbackLink</code> and <code>AjaxFallbackButton</code> which are able to automatically degrade to a standard link or to a standard button if client doesn't support AJAX.<p class="paragraph"/><h3>AJAX Checkbox</h3><p class="paragraph"/>Class <code>org.apache.wicket.ajax.markup.html.form.AjaxCheckBox</code> is a checkbox component that updates its model via AJAX when user changes its value. Its AJAX callback method is <code>onUpdate(AjaxRequestTarget target)</code>. The component extends standard checkbox component <code>CheckBox</code> adding an <code>AjaxFormComponentUpdatingBehavior</code> to itself (we will see this behavior later in <a href="../guide/single.html#ajax_3" class="guide">paragraph 19.3.3</a>).<p class="paragraph"/><h3>AJAX editable labels</h3><p class="paragraph"/>An editable label is a special label that can be edited by the user when she/he clicks on it. Wicket ships three different implementations for this component (all inside package <code>org.apache.wicket.extensions.ajax.markup.html</code>):
<ul class="star">
<li><strong class="bold">AjaxEditableLabel</strong>: it's a basic version of editable label. User can edit the content of the label with a text field. This is also the base class for the other two editable labels.</li>
<li><strong class="bold">AjaxEditableMultiLineLabel</strong>: this label supports multi-line values and uses a text area as editor component.</li>
<li><strong class="bold">AjaxEditableChoiceLabel</strong>: this label uses a drop-down menu to edit its value.</li>
</ul><p class="paragraph"/>Base component AjaxEditableLabel exposes the following set of AJAX-aware methods that can be overriden:
<ul class="star">
<li><strong class="bold">onEdit(AjaxRequestTarget target)</strong>: called when user clicks on component. The default implementation shows the component used to edit the value of the label.</li>
<li><strong class="bold">onSubmit(AjaxRequestTarget target)</strong>: called when the value has been successfully updated with the new input.</li>
<li><strong class="bold">onError(AjaxRequestTarget target)</strong>: called when the new inserted input has failed validation.</li>
<li><strong class="bold">onCancel(AjaxRequestTarget target)</strong>: called when user has exited from editing mode pressing escape key. The default implementation brings back the label to its initial state hiding the editor component.</li>
</ul><p class="paragraph"/>Wicket module wicket-examples contains page class <code>EditableLabelPage.java</code> which shows all these three components together. You can see this page in action at <a href="http://www.wicket-library.com/wicket-examples-6.0.x/ajax/editable-label" target="blank">http://www.wicket-library.com/wicket-examples-6.0.x/ajax/editable-label</a> :<p class="paragraph"/><img border="0" class="center" src="../img/edit-label-example-screenshot.png"></img><p class="paragraph"/><h3>Autocomplete text field</h3><p class="paragraph"/>On Internet we can find many examples of text fields that display a list of suggestions (or options) while the user types a text inside them. This feature is known as autocomplete functionality.<p class="paragraph"/>Wicket offers an out-of-the-box implementation of an autocomplete text field with component <code>org.apache.wicket.extensions.ajax.markup.html.autocomplete.AutoCompleteTextField</code>.<p class="paragraph"/>When using AutoCompleteTextField we are required to implement its abstract method getChoices(String input) where the input parameter is the current input of the component. This method returns an iterator over the suggestions that will be displayed as a drop-down menu:<p class="paragraph"/><img border="0" class="center" src="../img/autocomplete-example-screenshot.png"></img><p class="paragraph"/>Suggestions are rendered using a render which implements interface <code>IAutoCompleteRenderer</code>. The default implementation simply calls toString() on each suggestion object. If we need to work with a custom render we can specify it via component constructor.<p class="paragraph"/>AutoCompleteTextField supports a wide range of settings that are passed to its constructor with class <code>AutoCompleteSettings</code>.<p class="paragraph"/>One of the most interesting parameter we can specify for <code>AutoCompleteTextField</code> is the throttle delay which is the amount of time (in milliseconds) that must elapse between a change of input value and the transmission of a new Ajax request to display suggestions. This parameter can be set with method <code>setThrottleDelay(int)</code>:<p class="paragraph"/><div class="code"><pre>AutoCompleteSettings settings = <span class="java&#45;keyword">new</span> AutoCompleteSettings();
//set throttle to 400 ms: component will wait 400ms before displaying the options		
settings.setThrottleDelay(400);
//...		
AutoCompleteTextField field = <span class="java&#45;keyword">new</span> AutoCompleteTextField&#60;T&#62;(<span class="java&#45;quote">"field"</span>, model) &#123;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> Iterator getChoices(<span class="java&#45;object">String</span> arg0) &#123;
		//<span class="java&#45;keyword">return</span> an iterator over the options 
	&#125;
&#125;;</pre></div><p class="paragraph"/>Wicket module wicket-examples contains page class <code>AutoCompletePagePage.java</code> which shows an example of autocomplete text field. The running example is available at <a href="http://www.wicket-library.com/wicket-examples-6.0.x/ajax/autocomplete" target="blank">http://www.wicket-library.com/wicket-examples-6.0.x/ajax/autocomplete</a> .<p class="paragraph"/><h3>Modal window</h3><p class="paragraph"/>Class <code>org.apache.wicket.extensions.ajax.markup.html.modal.ModalWindow</code> is an implementation of a <a href="http://en.wikipedia.org/wiki/Modal_window" target="blank">modal window</a> based on AJAX:<p class="paragraph"/><img border="0" class="center" src="../img/modal-window-example-screenshot.png"></img><p class="paragraph"/>The content of a modal window can be either another component or a page. In the first case the id of the  component used as content must be retrieved with method getContentId().<p class="paragraph"/>If instead we want to use a page as window content, we must implement the inner interface <code>ModalWindow.PageCreator</code> and pass it to method <code>setPageCreator</code>. The page used as content will be embedded in a &#60;iframe&#62; tag.<p class="paragraph"/>To display a modal window we must call its method <code>show(AjaxRequestTarget target)</code>. This is  usually done inside the AJAX callback method of another component (like an <code>AjaxLink</code>). The following markup and code are taken from project <code>BasicModalWindowExample</code> and illustrate a basic usage of a modal window:<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#60;body&#62;
	&#60;h2&#62;Modal Windod example&#60;/h2&#62;
	&#60;a wicket:id=<span class="java&#45;quote">"openWindow"</span>&#62;Open the window!&#60;/a&#62;
	&#60;div wicket:id=<span class="java&#45;quote">"modalWindow"</span>&#62;&#60;/div&#62;
&#60;/body&#62;</pre></div><p class="paragraph"/><strong class="bold">Java Code:</strong>
<div class="code"><pre><span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
   	<span class="java&#45;keyword">super</span>(parameters);
   	<span class="java&#45;keyword">final</span> ModalWindow modalWindow = <span class="java&#45;keyword">new</span> ModalWindow(<span class="java&#45;quote">"modalWindow"</span>);
   	Label label = <span class="java&#45;keyword">new</span> Label(modalWindow.getContentId(), <span class="java&#45;quote">"I'm a modal window!"</span>);<p class="paragraph"/>   	modalWindow.setContent(label);
   	modalWindow.setTitle(<span class="java&#45;quote">"Modal window"</span>);<p class="paragraph"/>   	add(modalWindow);
   	add(<span class="java&#45;keyword">new</span> AjaxLink(<span class="java&#45;quote">"openWindow"</span>) &#123;
	  @Override
	  <span class="java&#45;keyword">public</span> void onClick(AjaxRequestTarget target) &#123;
		modalWindow.show(target);				
	  &#125;    		
	&#125;);
&#125;</pre></div><p class="paragraph"/>Just like any other component also <code>ModalWindow</code> must be added to a markup tag, like we did in our example using a &#60;div&#62; tag. Wicket will automatically hide this tag in the final markup appending the style value display:none. 
The component provides different setter methods to customize the appearance of the window:
<ul class="star">
<li><strong class="bold">setTitle(String)</strong>: specifies the title of the window</li>
<li><strong class="bold">setResizable(boolean)</strong>: by default the window is resizeable. If we need to make its size fixed we can use this method to turn off this feature.</li>
<li><strong class="bold">setInitialWidth(int) and setInitialHeight(int)</strong>: set the initial dimensions of the window.</li>
<li><strong class="bold">setMinimalWidth(int) and setMinimalHeight(int)</strong>: specify the minimal dimensions of the window.</li>
<li><strong class="bold">setCookieName(String)</strong>: this method can be used to specify the name of the cookie used on  client side to store size and position of the window when it is closed. The component will use this cookie to restore these two parameters the next time the window will be opened. If no cookie name is provided, the component will not remember its last position and size.</li>
<li><strong class="bold">setCssClassName(String)</strong>: specifies the CSS class used for the window.</li>
<li><strong class="bold">setAutoSize(boolean)</strong>: when this flag is set to true the window will automatically adjust its size to fit content width and height. By default it is false.</li>
</ul><p class="paragraph"/>The modal window can be closed from code using its method <code>close(AjaxRequestTarget target)</code>. The currently opened window can be closed also with the following JavaScript instruction:<p class="paragraph"/><div class="code"><pre>Wicket.Window.get().close();</pre></div><p class="paragraph"/><code>ModalWindow</code> gives the opportunity to perform custom actions when window is closing. Inner interface <code>ModalWindow.WindowClosedCallback</code> can be implemented and passed to window's method <code>setWindowClosedCallback</code> to specify the callback that must be executed after window has been closed:<p class="paragraph"/><div class="code"><pre>modalWindow.setWindowClosedCallback(<span class="java&#45;keyword">new</span> ModalWindow.WindowClosedCallback() &#123;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> void onClose(AjaxRequestTarget target) &#123;
	  //custom code&#8230;
	&#125;			
&#125;);</pre></div><p class="paragraph"/><h3>Tree repeaters</h3><p class="paragraph"/>Class <code>org.apache.wicket.extensions.markup.html.repeater.tree.AbstractTree</code> is the base class of another family of repeaters called tree repeaters and designed to display a data hierarchy as a tree, resembling the behavior and the look &#38; feel of desktop tree components. A classic example of tree component on desktop is the tree used by nearly all file managers to navigate file system:<p class="paragraph"/><img border="0" class="center" src="../img/file-system-trees.png"></img><p class="paragraph"/>Because of their highly interactive nature, tree repeaters are implemented as AJAX components,  meaning that they are updated via AJAX when we expand or collapse their nodes.<p class="paragraph"/>The basic implementation of a tree repeater shipped with Wicket is component <code>NestedTree</code>. In order to use a tree repeater we must provide an implementation of interface <code>ITreeProvider</code> which is in charge of returning the nodes that compose the tree.<p class="paragraph"/>Wicket comes with a built-in implementation of ITreeProvider called TreeModelProvider that works with the same tree model and nodes used by Swing component <code>javax.swing.JTree</code>. These Swing entities should be familiar to you if you have previously worked with the old tree repeaters (components <code>Tree</code> and <code>TreeTable</code>) that have been deprecated with Wicket 6 and that are strongly dependent on Swing-based model and nodes. <code>TreeModelProvider</code> can be used to migrate your code to the new tree repeaters.<p class="paragraph"/>In the next example (project <code>CheckBoxAjaxTree</code>) we will build a tree that displays some of the main cities of three European countries: Italy, Germany and France. The cities are sub-nodes of a main node representing the relative county. The nodes of the final tree will be also selectable with a checkbox control. The whole tree will have the classic look &#38; feel of Windows XP. This is how our tree will look like:<p class="paragraph"/><img border="0" class="center" src="../img/AJAX-tree-repeater.png"></img><p class="paragraph"/>We will start to explore the code of this example from the home page. The first portion of code we will see is where we build the nodes and the <code>TreeModelProvider</code> for the three. As tree node we will use Swing class <code>javax.swing.tree.DefaultMutableTreeNode</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
    <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
     <span class="java&#45;keyword">super</span>(parameters);
     DefaultMutableTreeNode root = <span class="java&#45;keyword">new</span> DefaultMutableTreeNode(<span class="java&#45;quote">"Cities of Europe"</span>);<p class="paragraph"/>     addNodes(addNodes(root, <span class="java&#45;quote">"Italy"</span>), <span class="java&#45;quote">"Rome"</span>, <span class="java&#45;quote">"Venice"</span>, <span class="java&#45;quote">"Milan"</span>, <span class="java&#45;quote">"Florence"</span>);
     addNodes(addNodes(root, <span class="java&#45;quote">"Germany"</span>),<span class="java&#45;quote">"Stuttgart"</span>,<span class="java&#45;quote">"Munich"</span>, <span class="java&#45;quote">"Berlin"</span>,<span class="java&#45;quote">"Dusseldorf"</span>, <span class="java&#45;quote">"Dresden"</span>);
     addNodes(addNodes(root, <span class="java&#45;quote">"France"</span>), <span class="java&#45;quote">"Paris"</span>,<span class="java&#45;quote">"Toulouse"</span>, <span class="java&#45;quote">"Strasbourg"</span>,<span class="java&#45;quote">"Bordeaux"</span>, <span class="java&#45;quote">"Lyon"</span>);<p class="paragraph"/>     DefaultTreeModel treeModel = <span class="java&#45;keyword">new</span> DefaultTreeModel(root);
     TreeModelProvider&#60;DefaultMutableTreeNode&#62; modelProvider = <span class="java&#45;keyword">new</span> 
                            TreeModelProvider&#60;DefaultMutableTreeNode&#62;( treeModel )&#123;
       @Override
       <span class="java&#45;keyword">public</span> IModel&#60;DefaultMutableTreeNode&#62; model(DefaultMutableTreeNode object)&#123;
          <span class="java&#45;keyword">return</span> Model.of(object);
       &#125;
     &#125;;
     //To be continued...</pre></div><p class="paragraph"/>Nodes have been built using simple strings as data objects and invoking custom utility method addNodes which converts string parameters into children nodes for a given parent node. Once we have our tree of <code>DefaultMutableTreeNodes</code> we can build the Swing tree model (<code>DefaultTreeModel</code>) that will be the backing object for a <code>TreeModelProvider</code>. This provider wraps each node in a model invoking its abstract method model. In our example we have used a simple <code>Model</code> as wrapper model.<p class="paragraph"/>Scrolling down the code we can see how the tree component is instantiated and configured before being added to the home page:<p class="paragraph"/><div class="code"><pre>//Continued from previous snippet&#8230;
 NestedTree&#60;DefaultMutableTreeNode&#62; tree = <span class="java&#45;keyword">new</span> NestedTree&#60;DefaultMutableTreeNode&#62;(<span class="java&#45;quote">"tree"</span>, 
                                                      modelProvider)
  &#123;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">protected</span> Component newContentComponent(<span class="java&#45;object">String</span> id, IModel&#60;DefaultMutableTreeNode&#62;model)
   &#123;
     <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> CheckedFolder&#60;DefaultMutableTreeNode&#62;(id, <span class="java&#45;keyword">this</span>, model);
   &#125;
  &#125;;
  //select Windows theme
  tree.add(<span class="java&#45;keyword">new</span> WindowsTheme());<p class="paragraph"/>  add(tree);
  &#125;
  //implementation of addNodes
  //&#8230;
&#125;</pre></div><p class="paragraph"/>To use tree repeaters we must implement their abstract method <code>newContentComponent</code> which is called internally by base class <code>AbstractTree</code> when a new node must be built. As content component we have used built-in class <code>CheckedFolder</code> which combines a <code>Folder</code> component with a <code>CheckBox</code> form control.<p class="paragraph"/>The final step before adding the tree to its page is to apply a theme to it. Wicket comes with two behaviors, WindowsTheme and HumanTheme, which correspond to the classic Windows XP theme and to the Human theme from Ubuntu.<p class="paragraph"/>Our checkable tree is finished but our work is not over yet because the component doesn't offer many functionalities as it is. Unfortunately neither NestedTree nor CheckedFolder provide a means for collecting checked nodes and returning them to client code. It's up to us to implement a way to keep track of checked nodes.<p class="paragraph"/>Another nice feature we would like to implement for our tree is the following user-friendly behavior that should occur when a user checks/unchecks a node:
<ul class="star">
<li>When a node is checked also all its children nodes (if any) must be checked. We must also ensure that all the ancestors of the checked node (root included) are checked, otherwise we would get an inconsistent selection.</li>
<li>When a node is unchecked also all its children nodes (if any) must be unchecked and we must also ensure that ancestors get unchecked if they have no more checked children.</li>
</ul><p class="paragraph"/>The first goal (keeping track of checked node) can be accomplished building a custom version of <code>CheckedFolder</code> that uses a shared Java Set to store checked node and to verify if its node has been  checked. This kind of solution requires a custom model for checkbox component in order to reflect its checked status when its container node is rendered. This model must implement typed interface <code>IModel&#60;Boolean&#62;</code> and must be returned by <code>CheckedFolder</code>'s method <code>newCheckBoxModel</code>.<p class="paragraph"/>For the second goal (auto select/unselect children and ancestor nodes) we can use <code>CheckedFolder</code>'s callback method onUpdate(AjaxRequestTarget) that is invoked after a checkbox is clicked and its value has been updated. Overriding this method we can handle user click adding/removing nodes to/from the Java Set.<p class="paragraph"/>Following this implementation plan we can start coding our custom <code>CheckedFolder</code> (named <code>AutocheckedFolder</code>):<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class AutocheckedFolder&#60;T&#62; <span class="java&#45;keyword">extends</span> CheckedFolder&#60;T&#62; &#123;<p class="paragraph"/>   <span class="java&#45;keyword">private</span> ITreeProvider&#60;T&#62; treeProvider;
   <span class="java&#45;keyword">private</span> IModel&#60;Set&#60;T&#62;&#62; checkedNodes;
   <span class="java&#45;keyword">private</span> IModel&#60;<span class="java&#45;object">Boolean</span>&#62; checkboxModel;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> AutocheckedFolder(<span class="java&#45;object">String</span> id, AbstractTree&#60;T&#62; tree, 
                        IModel&#60;T&#62; model, IModel&#60;Set&#60;T&#62;&#62; checkedNodes) &#123;
      <span class="java&#45;keyword">super</span>(id, tree, model);   
      <span class="java&#45;keyword">this</span>.treeProvider = tree.getProvider();
      <span class="java&#45;keyword">this</span>.checkedNodes = checkedNodes;            
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">protected</span> IModel&#60;<span class="java&#45;object">Boolean</span>&#62; newCheckBoxModel(IModel&#60;T&#62; model) &#123;
      checkboxModel =  <span class="java&#45;keyword">new</span> CheckModel();
      <span class="java&#45;keyword">return</span> checkboxModel;
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">protected</span> void onUpdate(AjaxRequestTarget target) &#123;
      <span class="java&#45;keyword">super</span>.onUpdate(target);
      T node = getModelObject();
      <span class="java&#45;object">boolean</span> nodeChecked = checkboxModel.getObject();<p class="paragraph"/>      addRemoveSubNodes(node, nodeChecked);            
      addRemoveAncestorNodes(node, nodeChecked);            
   &#125;<p class="paragraph"/>  class CheckModel <span class="java&#45;keyword">extends</span> AbstractCheckBoxModel&#123;
      @Override
      <span class="java&#45;keyword">public</span> <span class="java&#45;object">boolean</span> isSelected() &#123;
         <span class="java&#45;keyword">return</span> checkedNodes.getObject().contains(getModelObject());
      &#125;<p class="paragraph"/>      @Override
      <span class="java&#45;keyword">public</span> void select() &#123;
         checkedNodes.getObject().add(getModelObject());
      &#125;<p class="paragraph"/>      @Override
      <span class="java&#45;keyword">public</span> void unselect() &#123;
         checkedNodes.getObject().remove(getModelObject());
      &#125;				
  &#125;
&#125;</pre></div><p class="paragraph"/>The constructor of this new component takes in input a further parameter which is the set containing checked nodes.<p class="paragraph"/>Class CheckModel is the custom model we have implemented for checkbox control. As base class for this model we have used <code>AbstractCheckBoxModel</code> which is provided to implement custom models for checkbox controls.<p class="paragraph"/>Methods <code>addRemoveSubNodes</code> and <code>addRemoveAncestorNodes</code> are called to automatically add/remove children and ancestor nodes to/from the current Set. Their implementation is mainly focused on the navigation of tree nodes and it heavily depends on the internal implementation of the tree, so we won't dwell on their code.<p class="paragraph"/>Now we are just one step away from completing our tree as we still have to find a way to update the checked status of both children and ancestors nodes on client side. Although we could easily accomplish this task by simply refreshing the whole tree via AJAX, we would like to find a better and more performant solution for this task.<p class="paragraph"/>When we modify the checked status of a node we don't expand/collapse any node of the three so we can simply update the desired checkboxes rather than updating the entire tree component. This alternative approach could lead to a more responsive interface and to a strong reduction of bandwidth consumption.<p class="paragraph"/>With the help of JQuery we can code a couple of JavaScript functions that can be used to check/ uncheck all the children and ancestors of a given node. Then, we can append these functions to the current <code>AjaxRequest</code> at the end of method onUpdate:<p class="paragraph"/><div class="code"><pre>@Override
   <span class="java&#45;keyword">protected</span> void onUpdate(AjaxRequestTarget target) &#123;
      <span class="java&#45;keyword">super</span>.onUpdate(target);
      T node = getModelObject();
      <span class="java&#45;object">boolean</span> nodeChecked = checkboxModel.getObject();<p class="paragraph"/>      addRemoveSubNodes(node, nodeChecked);            
      addRemoveAncestorNodes(node, nodeChecked);    
      updateNodeOnClientSide(target, nodeChecked);		
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">protected</span> void updateNodeOnClientSide(AjaxRequestTarget target,
			<span class="java&#45;object">boolean</span> nodeChecked) &#123;
      target.appendJavaScript(<span class="java&#45;quote">";CheckAncestorsAndChildren.checkChildren('"</span> + getMarkupId() + 
                              <span class="java&#45;quote">"',"</span> + nodeChecked + <span class="java&#45;quote">");"</span>);<p class="paragraph"/>      target.appendJavaScript(<span class="java&#45;quote">";CheckAncestorsAndChildren.checkAncestors('"</span> + getMarkupId() + 
                              <span class="java&#45;quote">"',"</span> + nodeChecked + <span class="java&#45;quote">");"</span>);
   &#125;</pre></div><p class="paragraph"/>The JavaScript code can be found inside file autocheckedFolder.js which is added to the header section as package resource:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void renderHead(IHeaderResponse response) &#123;
	PackageResourceReference scriptFile = <span class="java&#45;keyword">new</span> PackageResourceReference(<span class="java&#45;keyword">this</span>.getClass(), 
                                                      <span class="java&#45;quote">"autocheckedFolder.js"</span>);
	response.render(JavaScriptHeaderItem.forReference(scriptFile));
&#125;</pre></div><p class="paragraph"/><h3>Working with hidden components</h3><p class="paragraph"/>When a component is not visible its markup and the related id attribute are not rendered in the final page, hence it can not be updated via AJAX. To overcome this problem we must use Component's method <code>setOutputMarkupPlaceholderTag(true)</code> which has the effect of rendering a hidden &#60;span&#62; tag containing the markup id of the hidden component:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">final</span> Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"labelComponent"</span>, <span class="java&#45;quote">"Initial value."</span>);
//make label invisible
label.setVisible(<span class="java&#45;keyword">false</span>);
//ensure that label will leave a placeholder <span class="java&#45;keyword">for</span> its markup id
label.setOutputMarkupPlaceholderTag(<span class="java&#45;keyword">true</span>);
add(label);
//&#8230;
<span class="java&#45;keyword">new</span> AjaxLink(<span class="java&#45;quote">"ajaxLink"</span>)&#123;
	@Override
	<span class="java&#45;keyword">public</span> void onClick(AjaxRequestTarget target) &#123;
	    //turn label to visible
	    label.setVisible(<span class="java&#45;keyword">true</span>);
	    target.add(label);
	&#125;  	
&#125;;</pre></div><p class="paragraph"/>Please note that in the code above we didn't invoked method <code>setOutputMarkupId(true)</code> as <code>setOutputMarkupPlaceholderTag</code> already does it internally.



<h2 id="ajax_3">19.3 Built-in AJAX behaviors</h2>
<p class="paragraph"/>In addition to specific components, Wicket offers also a set of built in AJAX behaviors that can be used to easily add AJAX functionalities to existing components. As we will see in this paragraph AJAX behaviors can be used also to ajaxify components that weren't initially designed to work with this technology. All the following behaviors are inside package <code>org.apache.wicket.ajax</code>.<p class="paragraph"/><h3>AjaxEventBehavior</h3><p class="paragraph"/>AjaxEventBehavior allows to handle a JavaScript event (like click, change, etc...) on server side via AJAX. Its constructor takes in input the name of the event that must be handled. Every time this event is fired for a given component on client side, the callback method <code>onEvent(AjaxRequestTarget target)</code> is executed. onEvent is abstract, hence we must implement it to tell <code>AjaxEventBehavior</code> what to do when the specified event occurs.<p class="paragraph"/>In project <code>AjaxEventBehaviorExample</code> we used this behavior to build a ‚Äúclickable‚Äù Label component that counts the number of clicks. Here is the code from the home page of the project:<p class="paragraph"/><strong class="bold">HTML:</strong>
<div class="code"><pre>&#60;body&#62;
  &#60;div wicket:id=<span class="java&#45;quote">"clickCounterLabel"</span>&#62;&#60;/div&#62;
  User has clicked &#60;span wicket:id=<span class="java&#45;quote">"clickCounter"</span>&#62;&#60;/span&#62; time/s on the label above.
&#60;/body&#62;</pre></div><p class="paragraph"/><strong class="bold">Java Code:</strong>
<div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
   <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
      <span class="java&#45;keyword">super</span>(parameters);<p class="paragraph"/>      <span class="java&#45;keyword">final</span> ClickCounterLabel clickCounterLabel = 
         <span class="java&#45;keyword">new</span> ClickCounterLabel(<span class="java&#45;quote">"clickCounterLabel"</span>, <span class="java&#45;quote">"Click on me!"</span>);
      <span class="java&#45;keyword">final</span> Label clickCounter =
         <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"clickCounter"</span>, <span class="java&#45;keyword">new</span> PropertyModel(clickCounterLabel, <span class="java&#45;quote">"clickCounter"</span>));<p class="paragraph"/>      
      clickCounterLabel.setOutputMarkupId(<span class="java&#45;keyword">true</span>);
      clickCounterLabel.add(<span class="java&#45;keyword">new</span> AjaxEventBehavior(<span class="java&#45;quote">"click"</span>)&#123;<p class="paragraph"/>         @Override
         <span class="java&#45;keyword">protected</span> void onEvent(AjaxRequestTarget target) &#123;
            clickCounterLabel.clickCounter++;
            target.add(clickCounter);
         &#125;         
      &#125;);<p class="paragraph"/>      add(clickCounterLabel);
      add(clickCounter.setOutputMarkupId(<span class="java&#45;keyword">true</span>));      
    &#125;
&#125;<p class="paragraph"/>class ClickCounterLabel <span class="java&#45;keyword">extends</span> Label&#123;
   <span class="java&#45;keyword">public</span> <span class="java&#45;object">int</span> clickCounter;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> ClickCounterLabel(<span class="java&#45;object">String</span> id) &#123;
      <span class="java&#45;keyword">super</span>(id);
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> ClickCounterLabel(<span class="java&#45;object">String</span> id, IModel&#60;?&#62; model) &#123;
      <span class="java&#45;keyword">super</span>(id, model);
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> ClickCounterLabel(<span class="java&#45;object">String</span> id, <span class="java&#45;object">String</span> label) &#123;
      <span class="java&#45;keyword">super</span>(id, label);      
   &#125;
&#125;</pre></div><p class="paragraph"/>In the code above we have declared a custom label class named <code>ClickCounterLabel</code> that exposes a public integer field called clickCounter. Then, in the home page we have attached a <code>AjaxEventBehavior</code> to our custom label to increment clickCounter every time it receives a click event.<p class="paragraph"/>The number of clicks is displayed with another standard label named <code>clickCounter</code>.<p class="paragraph"/><h3>AjaxFormSubmitBehavior</h3><p class="paragraph"/>This behavior allows to send a form via AJAX when the component it is attached to receives the specified event. The component doesn't need to be inside the form if we use the constructor version that, in addition to the name of the event, takes in input also the target form:<p class="paragraph"/><div class="code"><pre>Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>);		
Button submitButton = <span class="java&#45;keyword">new</span> Button(<span class="java&#45;quote">"submitButton"</span>);
//submit form when button is clicked		
submitButton.add(<span class="java&#45;keyword">new</span> AjaxFormSubmitBehavior(form, <span class="java&#45;quote">"click"</span>)&#123;&#125;);
add(form);
add(submitButton);</pre></div><p class="paragraph"/><blockquote class="note">
<code>AjaxFormSubmitBehavior</code> does not prevent JavaScript default event handling. For <code>&#60;input type="submit"&#62;</code> you'll have to call <code>AjaxRequestAttributes#setPreventDefault(true)</code> to prevent the form from being submitted twice.
</blockquote><p class="paragraph"/><h3>AjaxFormComponentUpdatingBehavior</h3><p class="paragraph"/>This behavior updates the model of the form component it is attached to when a given event occurs. The standard form submitting process is skipped and the behavior validates only its form component.<p class="paragraph"/>The behavior doesn't work with radio buttons and checkboxes. For these kinds of components we must use <code>AjaxFormChoiceComponentUpdatingBehavior</code>:<p class="paragraph"/><div class="code"><pre>Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>);		
TextField textField = <span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"textField"</span>, Model.of(<span class="java&#45;quote">""</span>));
//update the model of the text field each time event <span class="java&#45;quote">"change"</span> occurs
textField.add(<span class="java&#45;keyword">new</span> AjaxFormComponentUpdatingBehavior(<span class="java&#45;quote">"change"</span>)&#123;
	@Override
	<span class="java&#45;keyword">protected</span> void onUpdate(AjaxRequestTarget target) &#123;
		//...				
	&#125;
&#125;);
add(form.add(textField));</pre></div><p class="paragraph"/><h3>AbstractAjaxTimerBehavior</h3><p class="paragraph"/><code>AbstractAjaxTimerBehavior</code> executes callback method <code>onTimer(AjaxRequestTarget target)</code> at a specified interval. The behavior can be stopped and restarted at a later time with methods <code>stop(AjaxRequestTarget target)</code> and <code>restart(AjaxRequestTarget target)</code>:<p class="paragraph"/><div class="code"><pre>Label dynamicLabel = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"dynamicLabel"</span>);
//trigger an AJAX request every three seconds		
dynamicLabel.add(<span class="java&#45;keyword">new</span> AbstractAjaxTimerBehavior(Duration.seconds(3)) &#123;			
	@Override
	<span class="java&#45;keyword">protected</span> void onTimer(AjaxRequestTarget target) &#123;
		//...				
	&#125;
&#125;);
add(dynamicLabel);</pre></div><p class="paragraph"/><blockquote class="note">
As side effect AJAX components and behaviors make their hosting page stateful. As a consequence they are unfit for those pages that must stay stateless. Project WicketStuff provides a module with a stateless version of the most common AJAX components and behaviors. You can find more informations on this module in Appendix B. 
</blockquote>



<h2 id="ajax_4">19.4 Using an activity indicator</h2>
<p class="paragraph"/>One of the things we must take care of when we use AJAX is to notify user when an AJAX request is already in progress. This is usually done displaying an animated picture as activity indicator while the AJAX request is running.<p class="paragraph"/>Wicket comes with a variant of components <code>AjaxButton</code>, <code>AjaxLink</code> and <code>AjaxFallbackLink</code> that display a default activity indicator during AJAX request processing. These components are respectively <code>IndicatingAjaxButton</code>, <code>IndicatingAjaxLink</code> and <code>IndicatingAjaxFallbackLink</code>.<p class="paragraph"/>The default activity indicator used in Wicket can be easily integrated in our components using behavior AjaxIndicatorAppender (available in package <code>org.apache.wicket.extensions.ajax.markup.html</code>) and implementing the interface <code>IAjaxIndicatorAware</code> (in package <code>org.apache.wicket.ajax</code>).<p class="paragraph"/><code>IAjaxIndicatorAware</code> declares method <code>getAjaxIndicatorMarkupId()</code> which returns the id of the markup element used to display the activity indicator. This id can be obtained from the AjaxIndicatorAppender behavior that has been added to the current component. The following code snippet summarizes the steps needed to integrate the default activity indicator with an ajaxified component:<p class="paragraph"/><div class="code"><pre>//1&#45;Implement <span class="java&#45;keyword">interface</span> IAjaxIndicatorAware
<span class="java&#45;keyword">public</span> class MyComponent <span class="java&#45;keyword">extends</span> Component <span class="java&#45;keyword">implements</span> IAjaxIndicatorAware &#123;
	//2&#45;Instantiate an AjaxIndicatorAppender
	<span class="java&#45;keyword">private</span> AjaxIndicatorAppender indicatorAppender =
			<span class="java&#45;keyword">new</span> AjaxIndicatorAppender();<p class="paragraph"/>	<span class="java&#45;keyword">public</span> MyComponent(<span class="java&#45;object">String</span> id, IModel&#60;?&#62; model) &#123;
		<span class="java&#45;keyword">super</span>(id, model);
		//3&#45;Add the AjaxIndicatorAppender to the component
		add(indicatorAppender);
	&#125;
	//4&#45;Return the markup id obtained from AjaxIndicatorAppender
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getAjaxIndicatorMarkupId() &#123;		
		<span class="java&#45;keyword">return</span> indicatorAppender.getMarkupId();
	&#125;
//&#8230;
&#125;</pre></div><p class="paragraph"/>If we need to change the default picture used as activity indicator, we can override method <code>getIndicatorUrl()</code> of <code>AjaxIndicatorAppender</code> and return the URL to the desired picture.


<h2 id="ajax_5">19.5 AJAX request attributes and call listeners</h2>
<p class="paragraph"/>Starting from version 6.0 Wicket has introduced two entities which allow us to control how an AJAX request is generated on client side and to specify the custom JavaScript code we want to execute during request handling. These entities are class <code>AjaxRequestAttributes</code> and interface <code>IAjaxCallListener</code>, both placed in package <code>org.apache.wicket.ajax.attributes</code>.<p class="paragraph"/>AjaxRequestAttributes exposes the attributes used to generate the JavaScript call invoked on client side to start an AJAX request. Each attribute will be passed as a <a href="http://en.wikipedia.org/wiki/JSON" target="blank">JSON</a> parameter to the JavaScript function <code>Wicket.Ajax.ajax</code> which is responsible for sending the concrete AJAX request. Every JSON parameter is identified by a short name. Here is a partial list of the available parameters:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Short name</strong></th><th><strong class="bold">Description</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td>u</td><td>The callback URL used to serve the AJAX request that will be sent.</td><td>&#160;</td></tr><tr class="table-even"><td>c</td><td>The id of the component that wants to start the AJAX call.</td><td>&#160;</td></tr><tr class="table-odd"><td>e</td><td>A list of event (click, change, etc...) that can trigger the AJAX call.</td><td>domready</td></tr><tr class="table-even"><td>m</td><td>The request method that must be used (GET or POST).</td><td>GET</td></tr><tr class="table-odd"><td>f</td><td>The id of the form that must be submitted with the AJAX call.</td><td>&#160;</td></tr><tr class="table-even"><td>mp</td><td>If the AJAX call involves the submission of a form, this flag indicates whether the data must be encoded using the encoding mode ‚Äúmultipart/form-data‚Äù.</td><td>false</td></tr><tr class="table-odd"><td>sc</td><td>The input name of the submitting component of the form</td><td>&#160;</td></tr><tr class="table-even"><td>async</td><td>A boolean parameter that indicates if the AJAX call is asynchronous (true) or not.</td><td>true</td></tr><tr class="table-odd"><td>wr</td><td>Specifies the type of data returned by the AJAX call (XML, HTML, JSON, etc...).</td><td>XML</td></tr><tr class="table-even"><td>ih, bh, pre, bsh, ah, sh, fh, coh, dh</td><td>This is a list of the listeners that are executed on client side (they are JavaScript scripts) during the lifecycle of an AJAX request. Each short name is the abbreviation of one of the methods defined in the interface IAjaxCallListener (see below).</td><td>An empty list</td></tr></table><p class="paragraph"/><blockquote class="note">
A full list of the available request parameters as well as more details on the related JavaScript code can be found at <a href="https://cwiki.apache.org/confluence/display/WICKET/Wicket+Ajax" target="blank">https://cwiki.apache.org/confluence/display/WICKET/Wicket+Ajax</a> .
</blockquote><p class="paragraph"/>Parameters 'u' (callback URL) and 'c' (the id of the component) are generated by the AJAX behavior that will serve the AJAX call and they are not accessible through <code>AjaxRequestAttributes</code>.<p class="paragraph"/>Here is the final AJAX function generate for the behavior used in example project <code>AjaxEventBehavior</code> Example:<p class="paragraph"/><div class="code"><pre>Wicket.Ajax.ajax(&#123;<span class="java&#45;quote">"u"</span>:<span class="java&#45;quote">"./?0&#45;1.IBehaviorListener.0&#45;clickCounterLabel"</span>, <span class="java&#45;quote">"e"</span>:<span class="java&#45;quote">"click"</span>,               
                  <span class="java&#45;quote">"c"</span>:<span class="java&#45;quote">"clickCounterLabel1"</span>&#125;);</pre></div><p class="paragraph"/>Even if most of the times we will let Wicket generate request attributes for us, both AJAX components and behaviors give us the chance to modify them overriding their method <code>updateAjaxAttributes (AjaxRequestAttributes attributes)</code>.<p class="paragraph"/>One of the attribute we may need to modify is the list of <code>IAjaxCallListeners</code> returned by method <code>getAjaxCallListeners()</code>.<p class="paragraph"/><code>IAjaxCallListener</code> defines a set of methods which return the JavaScript code (as a <code>CharSequence</code>) that must be executed on client side when the AJAX request handling reaches a given stage:
<ul class="star">
<li><strong class="bold">getInitHandler(Component)</strong>: returns the JavaScript code that will be executed on initialization of the Ajax call, immediately after the causing event. The code is executed in a scope where it can use variable attrs, which is an array containing the JSON parameters passed to Wicket.Ajax.ajax.</li>
<li><strong class="bold">getBeforeHandler(Component)</strong>: returns the JavaScript code that will be executed before any other handlers returned by IAjaxCallListener. The code is executed in a scope where it can use variable attrs, which is an array containing the JSON parameters passed to Wicket.Ajax.ajax.</li>
<li><strong class="bold">getPrecondition(Component)</strong>: returns the JavaScript code that will be used as precondition for the AJAX call. If the script returns false then neither the Ajax call nor the other handlers will be executed. The code is executed in a scope where it can use variable attrs, which is the same variable seen for getBeforeHandler.</li>
<li><strong class="bold">getBeforeSendHandler(Component)</strong>: returns the JavaScript code that will be executed just before the AJAX call is performed. The code is executed in a scope where it can use variables attrs, jqXHR and settings:</li>
<ul class="star">
<li>attrs is the same variable seen for getBeforeHandler.</li>
<li>jqXHR is the the jQuery XMLHttpRequest object used to make the AJAX call.</li>
<li>settings contains the settings used for calling jQuery.ajax().</li>
</ul>
<li><strong class="bold">getAfterHandler(Component)</strong>: returns the JavaScript code that will be executed after the AJAX call. The code is executed in a scope where it can use variable attrs, which is the same variable seen before for getBeforeHandler.</li>
<li><strong class="bold">getSuccessHandler(Component)</strong>: returns the JavaScript code that will be executed if the AJAX call has successfully returned. The code is executed in a scope where it can use variables attrs, jqXHR, data and textStatus:</li>
<ul class="star">
<li>attrs and jqXHR are same variables seen for getBeforeSendHandler:</li>
<li>data is the data returned by the AJAX call. Its type depends on parameter wr (Wicket AJAX response).</li>
<li>textStatus it's the status returned as text.</li>
</ul>
<li><strong class="bold">getFailureHandler(Component)</strong>: returns the JavaScript code that will be executed if the AJAX call has returned with a failure. The code is executed in a scope where it can use variable attrs, which is the same variable seen for getBeforeHandler.</li>
<li><strong class="bold">getCompleteHandler(Component)</strong>: returns the JavaScript that will be invoked after success or failure handler has been executed. The code is executed in a scope where it can use variables attrs, jqXHR and textStatus which are the same variables seen for getSuccessHandler.</li>
<li><strong class="bold">getDoneHandler(Component)</strong>: returns the JavaScript code that will be executed after the Ajax call is done, regardless whether it was sent or not. The code is executed in a scope where it can use variable attrs, which is an array containing the JSON parameters passed to Wicket.Ajax.ajax.</li>
</ul><p class="paragraph"/>In the next paragraph we will see an example of custom <code>IAjaxCallListener</code> designed to disable a component during AJAX request processing.



<h2 id="ajax_6">19.6 Creating custom AJAX call listener</h2>
<p class="paragraph"/>Displaying an activity indicator is a nice way to notify user that an AJAX request is already running, but sometimes is not enough. In some situations we may need to completely disable a component during AJAX request processing, for example when we want to avoid that impatient users submit a form multiple times. In this paragraph we will see how to accomplish this goal building a custom and reusable <code>IAjaxCallListener</code>. The code used in this example is from project <code>CustomAjaxListenerExample</code>.<p class="paragraph"/><h3>What we want for our listener</h3><p class="paragraph"/>The listener should execute some JavaScript code to disable a given component when the component it is attached to is about to make an AJAX call. Then, when the AJAX request has been completed, the listener should bring back the disabled component to an active state.<p class="paragraph"/>When a component is disabled it must be clear to user that an AJAX request is running and that he/she must wait for it to complete. To achieve this result we want to disable a given component covering it with a semi-transparent overlay area with an activity indicator in the middle.<p class="paragraph"/>The final result will look like this:<p class="paragraph"/><img border="0" class="center" src="../img/custom-ajax-call-listener.png"></img><p class="paragraph"/><h3>How to implement the listener</h3><p class="paragraph"/>The listener will implement methods <code>getBeforeHandler</code> and <code>getAfterHandler</code>: the first will return the code needed to place an overlay &#60;div&#62; on the desired component while the second must remove this overlay when the AJAX call has completed.<p class="paragraph"/>To move and resize the overlay area we will use another module from <a href="http://jqueryui.com/position/" target="blank">JQueryUI library</a> that allows us to position DOM elements on our page relative to another element.<p class="paragraph"/>So our listener will depend on four static resources: the JQuery library, the position module of JQuery UI, the custom code used to move the overlay &#60;div&#62; and the picture used as activity indicator. Except for the activity indicator, all these resources must be added to page header section in order to be used.<p class="paragraph"/>Ajax call listeners can contribute to header section by simply implementing interface <code>IComponentAwareHeaderContributor</code>. Wicket provides adapter class <code>AjaxCallListener</code> that implements both <code>IAjaxCallListener</code> and <code>IComponentAwareHeaderContributor</code>. We will use this class as base class for our listener.<p class="paragraph"/><h3>JavaScript code</h3><p class="paragraph"/>Now that we know what to do on the Java side, let's have a look at the custom JavaScript code that must be returned by our listener (file moveHiderAndIndicator.js):<p class="paragraph"/><div class="code"><pre>DisableComponentListener = &#123;
   disableElement: function(elementId, activeIconUrl)&#123;
      <span class="java&#45;keyword">var</span> hiderId = elementId + <span class="java&#45;quote">"&#45;disable&#45;layer"</span>;
      <span class="java&#45;keyword">var</span> indicatorId = elementId + <span class="java&#45;quote">"&#45;indicator&#45;picture"</span>;<p class="paragraph"/>      elementId = <span class="java&#45;quote">"&#35;"</span> + elementId;
      //create the overlay &#60;div&#62;
      $(elementId).after('&#60;div id=<span class="java&#45;quote">"' + hiderId 
         + '"</span> style=<span class="java&#45;quote">"position:absolute;"</span>&#62;'
         + '&#60;img id=<span class="java&#45;quote">"' + indicatorId +  '"</span> src=<span class="java&#45;quote">"' + activeIconUrl + '"</span>/&#62;'
         + '&#60;/div&#62;');<p class="paragraph"/>      hiderId = <span class="java&#45;quote">"&#35;"</span> + hiderId;
      //set the style properties of the overlay &#60;div&#62;
      $(hiderId).css('opacity', '0.8');               
      $(hiderId).css('text&#45;align', 'center');
      $(hiderId).css('background&#45;color', 'WhiteSmoke');
      $(hiderId).css('border', '1px solid DarkGray');
      //set the dimention of the overlay &#60;div&#62;
      $(hiderId).width($(elementId).outerWidth());
      $(hiderId).height($(elementId).outerHeight());       	 
      //positioning the overlay &#60;div&#62; on the component that must be disabled.     
      $(hiderId).position(&#123;of: $(elementId),at: 'top left', my: 'top left'&#125;);<p class="paragraph"/>      //positioning the activity indicator in the middle of the overlay &#60;div&#62;
      $(<span class="java&#45;quote">"&#35;"</span> + indicatorId).position(&#123;of: $(hiderId), at: 'center center',
                                     my: 'center center'&#125;);
   &#125;,
   //function hideComponent</pre></div><p class="paragraph"/>Function DisableComponentListener.disableElement places the overlay &#60;div&#62; an the activity indicator on the desired component. The parameters in input are the markup id of the component we want to disable and the URL of the activity indicator picture. These two parameters must be provided by our custom listener.<p class="paragraph"/>The rest of custom JavaScript contains function DisableComponentListener.hideComponent which is just a wrapper around the JQuery function remove():<p class="paragraph"/><div class="code"><pre>hideComponent: function(elementId)&#123;
	<span class="java&#45;keyword">var</span> hiderId = elementId + <span class="java&#45;quote">"&#45;disable&#45;layer"</span>;
	$('&#35;' + hiderId).remove();
	&#125;
&#125;;</pre></div><p class="paragraph"/><h3>Java class code</h3><p class="paragraph"/>The code of our custom listener is the following:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class DisableComponentListener <span class="java&#45;keyword">extends</span> AjaxCallListener &#123;
   <span class="java&#45;keyword">private</span> <span class="java&#45;keyword">static</span> PackageResourceReference customScriptReference = <span class="java&#45;keyword">new</span>   
   PackageResourceReference(DisableComponentListener.class, <span class="java&#45;quote">"moveHiderAndIndicator.js"</span>);<p class="paragraph"/>   <span class="java&#45;keyword">private</span> <span class="java&#45;keyword">static</span> PackageResourceReference jqueryUiPositionRef = <span class="java&#45;keyword">new</span>    
   PackageResourceReference(DisableComponentListener.class, <span class="java&#45;quote">"jquery&#45;ui&#45;position.min.js"</span>);<p class="paragraph"/>   <span class="java&#45;keyword">private</span> <span class="java&#45;keyword">static</span> PackageResourceReference indicatorReference = 
         <span class="java&#45;keyword">new</span> PackageResourceReference(DisableComponentListener.class, <span class="java&#45;quote">"ajax&#45;loader.gif"</span>);<p class="paragraph"/>   <span class="java&#45;keyword">private</span> Component targetComponent;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> DisableComponentListener(Component targetComponent)&#123;
      <span class="java&#45;keyword">this</span>.targetComponent = targetComponent;
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">public</span> CharSequence getBeforeHandler(Component component) &#123;   
      CharSequence indicatorUrl = getIndicatorUrl(component);
      <span class="java&#45;keyword">return</span> <span class="java&#45;quote">";DisableComponentListener.disableElement('"</span> + targetComponent.getMarkupId() 
              + <span class="java&#45;quote">"',"</span> + <span class="java&#45;quote">"'"</span> + indicatorUrl + <span class="java&#45;quote">"');"</span>;
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">public</span> CharSequence getCompleteHandler(Component component) &#123;
      <span class="java&#45;keyword">return</span> <span class="java&#45;quote">";DisableComponentListener.hideComponent('"</span> 
		+ targetComponent.getMarkupId() + <span class="java&#45;quote">"');"</span>;
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">protected</span> CharSequence getIndicatorUrl(Component component) &#123;
      <span class="java&#45;keyword">return</span> component.urlFor(indicatorReference, <span class="java&#45;keyword">null</span>);
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">public</span> void renderHead(Component component, IHeaderResponse response) &#123;   
      ResourceReference jqueryReference = 
      Application.get().getJavaScriptLibrarySettings().getJQueryReference();
      response.render(JavaScriptHeaderItem.forReference(jqueryReference));      
      response.render(JavaScriptHeaderItem.forReference(jqueryUiPositionRef));
      response.render(JavaScriptHeaderItem.forReference(customScriptReference) );
   &#125;
&#125;</pre></div><p class="paragraph"/>As you can see in the code above we have created a function (<code>getIndicatorUrl</code>) to retrieve the URL of the indicator picture. This was done in order to make the picture customizable by overriding this method.<p class="paragraph"/>Once we have our listener in place, we can finally use it in our example overwriting method <code>updateAjaxAttributes</code> of the AJAX button that submits the form:<p class="paragraph"/><div class="code"><pre>//&#8230;
<span class="java&#45;keyword">new</span> AjaxButton(<span class="java&#45;quote">"ajaxButton"</span>)&#123;
	@Override
	<span class="java&#45;keyword">protected</span> void updateAjaxAttributes(AjaxRequestAttributes attributes) &#123;
	  <span class="java&#45;keyword">super</span>.updateAjaxAttributes(attributes);
	  attributes.getAjaxCallListeners().add(<span class="java&#45;keyword">new</span> DisableComponentListener(form));
	&#125;
&#125;
//...</pre></div><p class="paragraph"/><h3>Global listeners</h3><p class="paragraph"/>So far we have seen how to use an AJAX call listener to track the AJAX activity of a single component. In addition to these kinds of listeners, Wicket provides also global listeners which are triggered for any AJAX request sent from a page.<p class="paragraph"/>Global AJAX call events are handled with JavaScript. We can register a callback function for a specific event of the AJAX call lifecycle with function <code>Wicket.Event.subscribe('&#60;eventName&#62;', &#60;callback Function&#62;)</code>. The first parameter of this function is the name of the event we want to handle. The possible names are:
<ul class="star">
<li>'/ajax/call/init': called on initialization of an ajax call</li>
<li>'/ajax/call/before': called before any other event handler.</li>
<li>'/ajax/call/beforeSend': called just before the AJAX call.</li>
<li>'/ajax/call/after': called after the AJAX request has been sent.</li>
<li>'/ajax/call/success': called if the AJAX call has successfully returned.</li>
<li>'/ajax/call/failure': called if the AJAX call has returned with a failure.</li>
<li>'/ajax/call/complete': called when the AJAX call has completed.</li>
<li>'/ajax/call/done': called when the AJAX call is done.</li>
<li>'/dom/node/removing': called when a component is about to be removed via AJAX. This  happens when component markup is updated via AJAX (i.e. the component itself or one of its containers has been added to <code>AjaxRequestTarget</code>)</li>
<li>'/dom/node/added': called when a component has been added via AJAX. Just like '/dom/node/removing', this event is triggered when a component is added to <code>AjaxRequestTarget</code>.</li>
</ul><p class="paragraph"/>The callback function takes in input the following parameters:  attrs, jqXHR, textStatus, jqEvent and errorThrown. The first three parameters are the same seen before with <code>IAjaxCallListener</code> while jqEvent is an event internally fired by Wicket. The last parameter errorThrown indicates if an error has occurred during the AJAX call.<p class="paragraph"/>To see a basic example of use of a global AJAX call listener, let's go back to our custom datepicker created in <a href="../guide/single.html#jsintegration" class="guide">chapter 19</a>. When we built it we didn't think about a possible use of the component with AJAX.  When a complex component like our datepicker is refreshed via AJAX, the following two side effects can occur: 
<ul class="star">
<li>After been refreshed, the component loses every JavaScript handler set on it. This is not a problem for our datepicker as it sets a new JQuery datepicker every time is rendered (inside method renderHead).</li>
<li>The markup previously created with JavaScript is not removed. For our datepicker this means that the icon used to open the calendar won't be removed while a new one will be added each time the component is refreshed.</li>
</ul><p class="paragraph"/>To solve the second unwanted side effect we can register a global AJAX call listener that completely removes the datepicker functionality from our component before it is removed due to an AJAX refresh (which fires event '/dom/node/removing').<p class="paragraph"/>Project <code>CustomDatepickerAjax</code> contains a new version of our datepicker which adds to its JavaScript file JQDatePicker.js the code needed to register a callback function that gets rid of the JQuery datepicker before the component is removed from the DOM:<p class="paragraph"/><div class="code"><pre>Wicket.Event.subscribe('/dom/node/removing', 
    function(jqEvent, attributes, jqXHR, errorThrown, textStatus) &#123;
	<span class="java&#45;keyword">var</span> componentId = '&#35;' + attributes&#91;'id'&#93;;
	<span class="java&#45;keyword">if</span>($(componentId).datepicker !== undefined)
	      $(componentId).datepicker('destroy');
     &#125;
);</pre></div><p class="paragraph"/>The code above retrieves the id of the component that is about to be removed using parameter attributes. Then it checks if a JQuery datepicker was defined for the given component and if so, it removes the widget calling function destroy.



<h2 id="ajax_7">19.7 Summary</h2>
<p class="paragraph"/>AJAX is another example of how Wicket can simplify web technologies providing a good component and object oriented abstraction of them.<p class="paragraph"/>In this chapter we have seen how to take advantage of the AJAX support provided by Wicket to write AJAX-enhanced applications. Most of the chapter has been dedicated to the built-in components and behaviors that let us adopt AJAX without almost any effort.<p class="paragraph"/>In the final part of the chapter we have seen how Wicket physically implements an AJAX call on client side using AJAX request attributes. Then, we have learnt how to use call listeners to execute custom JavaScript during AJAX request lifecycle.



<h1 id="jee">20 Integration with enterprise containers</h1>
Writing a web application is not just about producing a good layout and a bunch of ‚Äúcool‚Äù pages. We must also integrate our presentation code with enterprise resources like data sources, message queues, business objects, etc...<p class="paragraph"/>The first decade of 2000s has seen the rising of new frameworks (like <a href="http://spring.io/" target="blank">Spring</a> ) and new specifications (like <a href="http://en.wikipedia.org/wiki/Enterprise_JavaBeans" target="blank">EJB 3.1</a> ) aimed to simplify the management of enterprise resources and (among other things) their integration with presentation code.<p class="paragraph"/>All these new technologies are based on the concepts of container and dependency injection. Container is the environment where our enterprise resources are created and configured while  <a href="http://en.wikipedia.org/wiki/Dependency_Injection" target="blank">dependency injection</a> is a pattern implemented by containers to inject into an object the resources it depends on.<p class="paragraph"/>Wicket can be easily integrated with enterprise containers using component instantiation listeners. These entities are instances of interface <code>org.apache.wicket.application.IComponentInstantiationListener</code> and can be registered during application's initialization.   IComponentInstantiationListener defines callback method onInstantiation(Component component) which can be used to provide custom instantiation logic for Wicket components.<p class="paragraph"/>Wicket distribution and project <a href="https://github.com/wicketstuff" target="blank">WicketStuff</a> already provide a set of built-in listeners to integrate our applications with EJB 3.1 compliant containers (like JBoss Seam) or with some of the most popular enterprise frameworks like <a href="http://code.google.com/p/google-guice/" target="blank">Guice</a> or Spring.<p class="paragraph"/>In this chapter we will see two basic examples of injecting a container-defined object into a page using first an implementation of the EJB 3.1 specifications (project <a href="http://openejb.apache.org/" target="blank">OpenEJB</a> ) and then using Spring.


<h2 id="jee_1">20.1 Integrating Wicket with EJB</h2>
<p class="paragraph"/>WicketStuff provides a module called wicketstuff-javaee-inject that contains component instantiation listener <code>JavaEEComponentInjector</code>. If we register this listener in our application we can use standard EJB annotations to inject dependencies into our Wicket components.<p class="paragraph"/>To register a component instantiation listener in Wicket we must use <code>Application</code>'s method <code>getComponentInstantiationListeners</code> which returns a typed collection of <code>IComponentInstantiationListeners</code>.<p class="paragraph"/>The following initialization code is taken from project <code>EjbInjectionExample</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class WicketApplication <span class="java&#45;keyword">extends</span> WebApplication
&#123;    	
       //Constructor...<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> void init()
	&#123;
		<span class="java&#45;keyword">super</span>.init();
		getComponentInstantiationListeners().add(<span class="java&#45;keyword">new</span> JavaEEComponentInjector(<span class="java&#45;keyword">this</span>));		
	&#125;	
&#125;</pre></div><p class="paragraph"/>In this example the object that we want to inject is a simple class containing a greeting message:<p class="paragraph"/><div class="code"><pre>@ManagedBean
<span class="java&#45;keyword">public</span> class EnterpriseMessage &#123;
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> message = <span class="java&#45;quote">"Welcome to the EJB world!"</span>;
&#125;</pre></div><p class="paragraph"/>Please note that we have used annotation ManagedBean to decorate our object. Now to inject it into the home page we must add a field of type EnterpriseMessage and annotate it with annotation @EJB:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;<p class="paragraph"/>	@EJB
	<span class="java&#45;keyword">private</span> EnterpriseMessage enterpriseMessage;
	//getter and setter <span class="java&#45;keyword">for</span> enterpriseMessage...<p class="paragraph"/>	<span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
		<span class="java&#45;keyword">super</span>(parameters);<p class="paragraph"/>		add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"message"</span>, enterpriseMessage.message));
	&#125;
&#125;</pre></div><p class="paragraph"/>That is all. We can point the browser to the home page of the project and see the greeting message injected into the page:<p class="paragraph"/><img border="0" class="center" src="../img/EjbInjectionExample.png"></img>


<h2 id="jee_2">20.2 Integrating Wicket with Spring</h2>
<p class="paragraph"/>If we need to inject dependencies with Spring we can use listener <code>org.apache.wicket.spring.injection.annot.SpringComponentInjector</code> provided by module wicket-spring.<p class="paragraph"/>For the sake of simplicity in the example project <code>SpringInjectionExample</code> we have used Spring class <code>AnnotationConfigApplicationContext</code> to avoid any XML file and create a Spring context directly from code:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class WicketApplication <span class="java&#45;keyword">extends</span> WebApplication
&#123;      
  //Constructor...<p class="paragraph"/>  @Override
  <span class="java&#45;keyword">public</span> void init()
  &#123;
    <span class="java&#45;keyword">super</span>.init();<p class="paragraph"/>    AnnotationConfigApplicationContext ctx = <span class="java&#45;keyword">new</span> AnnotationConfigApplicationContext();
    //Scan <span class="java&#45;keyword">package</span> <span class="java&#45;keyword">for</span> annotated beans
    ctx.scan(<span class="java&#45;quote">"org.wicketTutorial.ejbBean"</span>);
    ctx.refresh();<p class="paragraph"/>    getComponentInstantiationListeners().add(<span class="java&#45;keyword">new</span> SpringComponentInjector(<span class="java&#45;keyword">this</span>, ctx));
  &#125;	
&#125;</pre></div><p class="paragraph"/>As we can see in the code above, the constructor of <code>SpringComponentInjector</code> takes in input also an instance of Spring context.<p class="paragraph"/>The injected object is the same used in the previous project <code>EjbInjectionExample</code>, it differs only for the greeting message:<p class="paragraph"/><div class="code"><pre>@ManagedBean
<span class="java&#45;keyword">public</span> class EnterpriseMessage &#123;
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> message = <span class="java&#45;quote">"Welcome to the Spring world!"</span>;
&#125;</pre></div><p class="paragraph"/>In the home page of the project the object is injected using Wicket annotation @SpringBean:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
  @SpringBean
  <span class="java&#45;keyword">private</span> EnterpriseMessage enterpriseMessage;
  //getter and setter <span class="java&#45;keyword">for</span> enterpriseMessage...<p class="paragraph"/>  <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
  	<span class="java&#45;keyword">super</span>(parameters);<p class="paragraph"/>	add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"message"</span>, enterpriseMessage.message));
  &#125;
&#125;</pre></div><p class="paragraph"/>By default <code>SpringBean</code> searches into Spring context for a bean having the same type of the annotated field. If we want we can specify also the name of the bean to use as injected object and we can declare if the dependency is required or not. By default dependencies are required and if they can not be resolved to a compatible bean, Wicket will throw an <code>IllegalStateException</code>:<p class="paragraph"/><div class="code"><pre>//set the dependency as not required, i.e the field can be left <span class="java&#45;keyword">null</span>
  @SpringBean(name=<span class="java&#45;quote">"anotherName"</span>, required=<span class="java&#45;keyword">false</span>)
  <span class="java&#45;keyword">private</span> EnterpriseMessage enterpriseMessage;</pre></div>



<h2 id="jee_3">20.3 JSR-330 annotations</h2>
<p class="paragraph"/>Spring (and Guice) users can use standard <a href="http://jcp.org/en/jsr/detail?id=330" target="blank">JSR-330</a> annotations to wire their dependencies. This will make their code more interoperable with other containers that support this standard:<p class="paragraph"/><div class="code"><pre>//inject a bean specifying its name with JSR&#45;330 annotations
  @Inject 
  @Named(<span class="java&#45;quote">"anotherName"</span>)
  <span class="java&#45;keyword">private</span> EnterpriseMessage enterpriseMessage;</pre></div>



<h2 id="jee_4">20.4 Summary</h2>
<p class="paragraph"/>In this chapter we have seen how to integrate Wicket applications with Spring and with an EJB container. Module wicket-examples contains also an example of integration with Guice (see application class <code>org.apache.wicket.examples.guice.GuiceApplication</code>).<p class="paragraph"/>



<h1 id="nativewebsockets">21 Native WebSockets</h1>
<a href="http://en.wikipedia.org/wiki/WebSocket" target="blank">WebSockets</a> is a technology that provides full-duplex communications channels over a single TCP connection.
This means that once the browser establish a web socket connection to the server the server can push data back to the browser without the browser explicitly asking again and again whether there is something new for it.<p class="paragraph"/>Wicket Native WebSockets modules provide functionality to integrate with the non-standard APIs provided by different web containers (like <a href="http://tomcat.apache.org/" target="blank">Apache Tomcat</a> and <a href="http://www.eclipse.org/jetty/" target="blank">Jetty</a>) and standard <a href="https://www.jcp.org/en/jsr/detail?id=356" target="blank">JSR356</a> implementations.<p class="paragraph"/><blockquote class="warning">
Native WebSocket works only when both the browser and the web containers support WebSocket technology. There are no plans to add support to fallback to long-polling, streaming or any other technology that simulates two way communication. Use it only if you really know that you will run your application in an environment that supports WebSockets.
Currently supported web containers are Jetty 7.5+ , Tomcat 7.0.27+ and JBoss WildFly 8.0.0+.
Supported browsers can be found at <a href="http://caniuse.com/#search=websocket" target="blank">caniuse.com</a>.
</blockquote>



<h2 id="nativewebsockets_1">21.1 How does it work ?</h2>
Each of the modules provide a specialization of <code>org.apache.wicket.protocol.http.WicketFilter</code> that registers implementation specific endpoint when an HTTP request is <a href="http://en.wikipedia.org/wiki/WebSocket#WebSocket_protocol_handshake" target="blank">upgraded</a> to WebSocket one. Later Wicket uses this endpoint to write data back to the browser and read data sent by it.<p class="paragraph"/>WebSockets communication can be used in a Wicket page by using <code>org.apache.wicket.protocol.ws.api.WebSocketBehavior</code> or in a IResource by exteding <code>org.apache.wicket.protocol.ws.api.WebSocketResource</code>.
When a client is connected it is being registered in a application scoped registry using as a key the application name, the client http session id, and the id of the page or the resource name that registered it. Later when the server needs to push a message it can use this registry to filter out which clients need to receive the message.<p class="paragraph"/>When a message is received from the client Wicket wraps it in <code>IWebSocketMessage</code> and calls WebSocketBehavior#<strong class="bold">onMessage()</strong> or WebSocketResource#<strong class="bold">onMessage()</strong> where the application logic can react on it.
The server can push plain text and binary data to the client, but it can also add components for re-render, prepend/append JavaScript as it can do with <a href="../guide/single.html#ajax" class="guide">Ajax</a>.



<h2 id="nativewebsockets_2">21.2 How to use</h2>
<ul class="star">
<li><strong class="bold">Classpath dependency</strong></li>
</ul><p class="paragraph"/>Depending on the web container that is used the application has to add a dependency to either:
<ul class="minus">
<li>for Jetty 9.0.x</li>
</ul><p class="paragraph"/><div class="code"><pre>&#60;dependency&#62;
  &#60;groupId&#62;org.apache.wicket&#60;/groupId&#62;
  &#60;artifactId&#62;wicket&#45;<span class="java&#45;keyword">native</span>&#45;websocket&#45;jetty9&#60;/artifactId&#62;
  &#60;version&#62;...&#60;/version&#62;
&#60;/dependency&#62;</pre></div>
<ul class="minus">
<li>for Jetty 7.x and 8.x</li>
</ul><p class="paragraph"/><div class="code"><pre>&#60;dependency&#62;
  &#60;groupId&#62;org.apache.wicket&#60;/groupId&#62;
  &#60;artifactId&#62;wicket&#45;<span class="java&#45;keyword">native</span>&#45;websocket&#45;jetty&#60;/artifactId&#62;
  &#60;version&#62;...&#60;/version&#62;
&#60;/dependency&#62;</pre></div>
<ul class="minus">
<li>for Tomcat 7.0.27+ (the old, non-JSR356 implementation)</li>
</ul><p class="paragraph"/><div class="code"><pre>&#60;dependency&#62;
  &#60;groupId&#62;org.apache.wicket&#60;/groupId&#62;
  &#60;artifactId&#62;wicket&#45;<span class="java&#45;keyword">native</span>&#45;websocket&#45;tomcat&#60;/artifactId&#62;
  &#60;version&#62;...&#60;/version&#62;
&#60;/dependency&#62;</pre></div>
<ul class="minus">
<li>for JSR356 complaint implementations (at the moment are supported: Tomcat 8.0+, Tomcat 7.0.47+, Jetty 9.1.0+ and JBoss Wildfly 8.0.0+)</li>
</ul><p class="paragraph"/><div class="code"><pre>&#60;dependency&#62;
  &#60;groupId&#62;org.apache.wicket&#60;/groupId&#62;
  &#60;artifactId&#62;wicket&#45;<span class="java&#45;keyword">native</span>&#45;websocket&#45;javax&#60;/artifactId&#62;
  &#60;version&#62;...&#60;/version&#62;
&#60;/dependency&#62;</pre></div><p class="paragraph"/><blockquote class="note">
All web containers providing JSR356 implementation are built with Java 7. This is the reason why <code>wicket-native-websocket-javax</code> module is available only with Wicket 7.x. If your application runs with JRE 7.x then you can
use <code>wicket-native-websocket-javax</code> together with the latest version of Wicket 6.x. Beware that the API/implementation of <code>wicket-native-websocket-javax</code> may change before Wicket 7.0.0 is released!
</blockquote><p class="paragraph"/><blockquote class="note">
The examples above show snippets for Maven's pom.xml but the application can use any other dependency management tool like <a href="http://www.gradle.org/" target="blank">Gradle</a>, <a href="http://www.scala-sbt.org/" target="blank">SBT</a>, &#8230;
</blockquote>
<ul class="star">
<li><strong class="bold">web.xml</strong></li>
</ul><p class="paragraph"/>In <code>WEB-INF/web.xml</code> replace the usage of <strong class="bold">WicketFilter</strong> with any of the following depending on the web container that is used:<p class="paragraph"/>For Jetty 9.0.x:
<div class="code"><pre>&#60;filter&#45;class&#62;org.apache.wicket.protocol.ws.jetty9.Jetty9WebSocketFilter&#60;/filter&#45;class&#62;</pre></div><p class="paragraph"/>For Jetty 7.5+ and 8.x:
<div class="code"><pre>&#60;filter&#45;class&#62;org.apache.wicket.protocol.ws.jetty7.Jetty7WebSocketFilter&#60;/filter&#45;class&#62;</pre></div><p class="paragraph"/>For Tomcat 7.0.27+ (old implementation):
<div class="code"><pre>&#60;filter&#45;class&#62;org.apache.wicket.protocol.ws.tomcat7.Tomcat7WebSocketFilter&#60;/filter&#45;class&#62;</pre></div><p class="paragraph"/>For JSR356 complaint web containers (at the moment: Tomcat 7.0.47+, Tomcat 8.x and Jetty 9.1.x):
<div class="code"><pre>&#60;filter&#45;class&#62;org.apache.wicket.protocol.ws.javax.JavaxWebSocketFilter&#60;/filter&#45;class&#62;</pre></div>
<ul class="star">
<li><strong class="bold">WebSocketBehavior</strong></li>
</ul><p class="paragraph"/><code>org.apache.wicket.protocol.ws.api.WebSocketBehavior</code> is similar to Wicket Ajax behaviors that you may have used.
Add WebSocketBehavior to the page (or to any component in the page) that will use web socket communication:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class MyPage <span class="java&#45;keyword">extends</span> WebPage &#123;<p class="paragraph"/>  <span class="java&#45;keyword">public</span> MyPage()
  &#123;
    add(<span class="java&#45;keyword">new</span> WebSocketBehavior() &#123;
      @Override
      <span class="java&#45;keyword">protected</span> void onMessage(WebSocketRequestHandler handler, TextMessage message)
      &#123;
        <span class="java&#45;object">String</span> msg = message.getText();
        // <span class="java&#45;keyword">do</span> something with msg
      &#125;
    &#125;);
  &#125;
&#125;</pre></div><p class="paragraph"/>Use <code>message.getText()</code> to read the message sent by the client and use <code>handler.push(String)</code> to push a text message to the connected client. Additionally you can use <code>handler.add(Component...)</code> to add Wicket components for re-render, <code>handler#prependJavaScript(CharSequence)</code> and <code>handler#appendJavaScript(CharSequence)</code> as you do with <code>AjaxRequestTarget</code>.
<ul class="star">
<li><strong class="bold">WebSocketResource</strong></li>
</ul><p class="paragraph"/>Wicket allows one thread at a time to use a page instance to simplify the usage of the pages in multithreaded enviroment. When a WebSocket message is sent to a page Wicket needs to acquire the lock to that page to be able to pass the <code>IWebSocketMessage</code> to the <code>WebSocketBehavior</code>. This may be problematic when the application needs to send many messages from the client to the server.
For this reason Wicket provides <code>WebSocketResource</code> - an IResource implemetation that provides the same APIs as <code>WebSocketBehavior</code>. The benefit is that there is no need of synchronization as with the pages and the drawback is that <code>WebSocketRequesthandler#add(Component...)</code> method cannot be used because there is no access to the components in an <code>IResource</code>.<p class="paragraph"/>To register such WebSocket resource add such line to <code>YourApplication#init()</code> method:
<div class="code"><pre>getSharedResources().add(<span class="java&#45;quote">"someName"</span>, <span class="java&#45;keyword">new</span> MyWebSocketResource());</pre></div><p class="paragraph"/>and 
<div class="code"><pre>page.add(<span class="java&#45;keyword">new</span> BaseWebSocketBehavior(<span class="java&#45;quote">"someName"</span>));</pre></div>
to any page. This will prepare the JavaScript connection for you.
<ul class="star">
<li><strong class="bold">WebSocket connection registry</strong></li>
</ul><p class="paragraph"/>To push data to one or more clients the application can use the <code>IWebSocketConnectionRegistry</code> to find all registered connections and send data to all/any of them:<p class="paragraph"/><div class="code"><pre>Application application = Application.get(applicationName);
WebSocketSettings webSocketSettings = WebSocketSettings.Holder.get(application);
IWebSocketConnectionRegistry webSocketConnectionRegistry = webSocketSettings.getConnectionRegistry();
IWebSocketConnection connection = webSocketConnectionRegistry.getConnection(application, sessionId, key);</pre></div>


<h2 id="nativewebsockets_3">21.3 Client-side APIs</h2>
By adding a <code>(Base)WebSocketBehavior</code> to your component(s) Wicket will contribute <code>wicket-websocket-jquery.js</code> library which provides some helper functions to write your client side code. There is a default websocket connection per Wicket Page opened for you which you can use like:
<div class="code"><pre>Wicket.WebSocket.send('&#123;msg: <span class="java&#45;quote">"my message"</span>&#125;').</pre></div><p class="paragraph"/>To close the default connection:
<div class="code"><pre>Wicket.WebSocket.close()</pre></div><p class="paragraph"/>Wicket.WebSocket is a simple wrapper around the native window.WebSocket API which is used to intercept the calls and to fire special JavaScript events (Wicket.Event PubSub).
Once a page that contributes <code>(Base)WebSocketBehavior</code> is rendered the client may react on messages pushed by the server by subscribing to the <code>'/websocket/message'</code> event:<p class="paragraph"/><div class="code"><pre>Wicket.Event.subscribe(<span class="java&#45;quote">"/websocket/message"</span>, function(jqEvent, message) &#123;
  <span class="java&#45;keyword">var</span> data = JSON.parse(message);
  processData(data); // does something with the pushed message
&#125;);</pre></div><p class="paragraph"/>Here is a table of all events that the application can subscribe to:
<table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th>Event name</th><th>Arguments</th><th>Description</th></tr><tr class="table-odd"><td>/websocket/open</td><td>jqEvent</td><td>A WebSocket connection has been just opened</td></tr><tr class="table-even"><td>/websocket/message</td><td>jqEvent, message</td><td>A message has been received from the server</td></tr><tr class="table-odd"><td>/websocket/closed</td><td>jqEvent</td><td>A WebSocket connection has been closed</td></tr><tr class="table-even"><td>/websocket/error</td><td>jqEvent</td><td>An error occurred in the communication. The connection will be closed</td></tr></table><p class="paragraph"/>


<h2 id="nativewebsockets_4">21.4 Testing</h2>
The module provides <code>org.apache.wicket.protocol.ws.util.tester.WebSocketTester</code> which gives you the possibility to emulate sending and receiving messages without the need to run in a real web container, as WicketTester does this for HTTP requests.
Check <a href="https://github.com/apache/wicket/blob/master/wicket-native-websocket/wicket-native-websocket-core/src/test/java/org/apache/wicket/protocol/ws/util/tester/WebSocketTesterBehaviorTest.java?source=c" target="blank">WebSocketTesterBehaviorTest</a>  and <a href="https://github.com/apache/wicket/blob/master/wicket-native-websocket/wicket-native-websocket-core/src/test/java/org/apache/wicket/protocol/ws/util/tester/WebSocketTesterResourceTest.java" target="blank">WebSocketTesterResourceTest</a> for examples.



<h2 id="nativewebsockets_5">21.5 Differences with Wicket-Atmosphere module.</h2>
Wicket-Atmosphere experimental module provides integration with <a href="https://github.com/Atmosphere/atmosphere" target="blank">Atmosphere</a> and let it handle the inconsistencies in WebSocket protocol support in different browsers and web containers. If either the browser or the web container do not support WebSockets then Atmosphere will downgrade (depending on the configuration) to either long-polling, streaming, server-side events, jsonp, &#8230; to simulate the long running connection.



<h2 id="nativewebsockets_6">21.6 FAQ</h2>
<ol>
<li>Request and session scoped beans do not work.</li>
</ol><p class="paragraph"/>The Web Socket communication is not processed by Servlet Filters and Listeners and thus the Dependency Injection libraries have no chance to export the request and session bean proxies.


<h1 id="security">22 Security with Wicket</h1>
Security is one of the most important non-functional requirements we must implement in our applications. This is particularly true for enterprise applications as they usually support multiple concurrent users, and therefore they need to have an access control policy.<p class="paragraph"/>In this chapter we will explore the security infrastructure provided by Wicket and we will learn how to use it to implement authentication and authorizations in our web applications.


<h2 id="security_1">22.1 Authentication</h2>
<p class="paragraph"/>The first step in implementing a security policy is assigning a trusted identity to our users, which means that we must authenticate them. Web applications usually adopt a form-based authentication with a login form that asks user for a unique username and the relative password:<p class="paragraph"/><img border="0" class="center" src="../img/wikipedia-login-form.png"></img><p class="paragraph"/>Wicket supports form-based authentication with session class <code>AuthenticatedWebSession</code> and application class <code>AuthenticatedWebApplication</code>, both placed inside package <code>org.apache.wicket.authroles.authentication</code>.<p class="paragraph"/><h3>AuthenticatedWebSession</h3><p class="paragraph"/>Class AuthenticatedWebSession comes with the following set of public methods to manage user authentication:
<ul class="star">
<li><strong class="bold">authenticate(String username, String password)</strong>: this is an abstract method that must be implemented by every subclass of <code>AuthenticatedWebSession</code>. It should contain the actual code that checks for user's identity. It returns a boolean value which is true if authentication has succeeded or false otherwise.</li>
<li><strong class="bold">signIn(String username, String password)</strong>: this method internally calls authenticate and set the flag signedIn to true if authentication succeeds.</li>
<li><strong class="bold">isSignedIn()</strong>:getter method for flag signedIn.</li>
<li><strong class="bold">signOut()</strong>: sets the flag signedIn to false.</li>
<li><strong class="bold">invalidate()</strong>: calls signOut and invalidates session.</li>
</ul><p class="paragraph"/><blockquote class="warning">
Remember that signOut does not discard any session-relative data. If we want to get rid of these data, we must invoke method invalidate instead of signOut.
</blockquote><p class="paragraph"/>Another abstract method we must implement when we use <code>AuthenticatedWebSession</code> is  getRoles which is inherited from parent class <code>AbstractAuthenticatedWebSession</code>. This method can be ignored for now as it will be discussed later when we will talk about role-based authorization.<p class="paragraph"/><h3>AuthenticatedWebApplication</h3><p class="paragraph"/>Class AuthenticatedWebApplication provides the following methods to support form-based authentication:
<ul class="star">
<li><strong class="bold">getWebSessionClass()</strong>: abstract method that returns the session class to use for this application. The returned class must be a subclass of <code>AbstractAuthenticatedWebSession</code>.</li>
<li><strong class="bold">getSignInPageClass()</strong>: abstract method that returns the page to use as sign in page when a user must be authenticated.</li>
<li><strong class="bold">restartResponseAtSignInPage()</strong>: forces the current response to restart at the sign in page. After we have used this method to redirect a user, we can make her/him return to the original page calling <code>Componet</code>'s method <code>continueToOriginalDestination()</code>.</li>
</ul><p class="paragraph"/>The other methods implemented inside <code>AuthenticatedWebApplication</code> will be introduced when we will talk about authorizations.<p class="paragraph"/><h3>A basic example of authentication</h3><p class="paragraph"/>Project <code>BasicAuthenticationExample</code> is a basic example of form-based authentication implemented with classes <code>AuthenticatedWebSession</code> and <code>AuthenticatedWebApplication</code>.<p class="paragraph"/>The homepage of the project contains only a link to page <code>AuthenticatedPage</code> which can be accessed only if user is signed in. The code of <code>AuthenticatedPage</code> is this following:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class AuthenticatedPage <span class="java&#45;keyword">extends</span> WebPage &#123;
   @Override
   <span class="java&#45;keyword">protected</span> void onConfigure() &#123;
      <span class="java&#45;keyword">super</span>.onConfigure();
      AuthenticatedWebApplication app = (AuthenticatedWebApplication)Application.get();
      //<span class="java&#45;keyword">if</span> user is not signed in, redirect him to sign in page
      <span class="java&#45;keyword">if</span>(!AuthenticatedWebSession.get().isSignedIn())
         app.restartResponseAtSignInPage();
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">protected</span> void onInitialize() &#123;
      <span class="java&#45;keyword">super</span>.onInitialize();
      add(<span class="java&#45;keyword">new</span> Link(<span class="java&#45;quote">"goToHomePage"</span>) &#123;<p class="paragraph"/>         @Override
         <span class="java&#45;keyword">public</span> void onClick() &#123;
            setResponsePage(getApplication().getHomePage());
         &#125;
      &#125;);<p class="paragraph"/>      add(<span class="java&#45;keyword">new</span> Link(<span class="java&#45;quote">"logOut"</span>) &#123;<p class="paragraph"/>         @Override
         <span class="java&#45;keyword">public</span> void onClick() &#123;
            AuthenticatedWebSession.get().invalidate();
            setResponsePage(getApplication().getHomePage());
         &#125;
      &#125;);
   &#125;
&#125;</pre></div><p class="paragraph"/>Page <code>AuthenticatedPage</code> checks inside onConfigure if user is signed in and if not, it redirects her/him to the sign in page with method <code>restartResponseAtSignInPage</code>. The page contains also a link to the homepage and another link that signs out user.<p class="paragraph"/>The sign in page is implemented in class <code>SignInPage</code> and contains the form used to authenticate users:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class SignInPage <span class="java&#45;keyword">extends</span> WebPage &#123;
   <span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> username;
   <span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> password;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">protected</span> void onInitialize() &#123;
      <span class="java&#45;keyword">super</span>.onInitialize();<p class="paragraph"/>      StatelessForm form = <span class="java&#45;keyword">new</span> StatelessForm(<span class="java&#45;quote">"form"</span>)&#123;
         @Override
         <span class="java&#45;keyword">protected</span> void onSubmit() &#123;
            <span class="java&#45;keyword">if</span>(Strings.isEmpty(username))
               <span class="java&#45;keyword">return</span>;<p class="paragraph"/>            <span class="java&#45;object">boolean</span> authResult = AuthenticatedWebSession.get().signIn(username, password);
            //<span class="java&#45;keyword">if</span> authentication succeeds redirect user to the requested page
            <span class="java&#45;keyword">if</span>(authResult)
               continueToOriginalDestination();
         &#125;
      &#125;;<p class="paragraph"/>      form.setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(<span class="java&#45;keyword">this</span>));<p class="paragraph"/>      form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>));
      form.add(<span class="java&#45;keyword">new</span> PasswordTextField(<span class="java&#45;quote">"password"</span>));<p class="paragraph"/>      add(form);
   &#125;
&#125;</pre></div><p class="paragraph"/>The form is responsible for handling user authentication inside its method onSubmit. The username and password are passed to <code>AuthenticatedWebSession</code>'s method <code>signIn(username, password)</code> and if authentication succeeds, the user is redirected to the original page with method <code>continueToOriginalDestination</code>.<p class="paragraph"/>The session class and the application class used in the project are reported here:<p class="paragraph"/><strong class="bold">Session class:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class BasicAuthenticationSession <span class="java&#45;keyword">extends</span> AuthenticatedWebSession &#123;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> BasicAuthenticationSession(Request request) &#123;
		<span class="java&#45;keyword">super</span>(request);		
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">boolean</span> authenticate(<span class="java&#45;object">String</span> username, <span class="java&#45;object">String</span> password) &#123;
	      //user is authenticated <span class="java&#45;keyword">if</span> both username and password are equal to 'wicketer'
		<span class="java&#45;keyword">return</span> username.equals(password) &#38;&#38; username.equals(<span class="java&#45;quote">"wicketer"</span>);
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> Roles getRoles() &#123;
		<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>;
	&#125;
&#125;</pre></div><p class="paragraph"/><strong class="bold">Application class:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class WicketApplication <span class="java&#45;keyword">extends</span> AuthenticatedWebApplication&#123;    	
	@Override
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">Class</span>&#60;HomePage&#62; getHomePage()&#123;
		<span class="java&#45;keyword">return</span> HomePage.class;
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> <span class="java&#45;object">Class</span>&#60;? <span class="java&#45;keyword">extends</span> AbstractAuthenticatedWebSession&#62; getWebSessionClass()&#123;
		<span class="java&#45;keyword">return</span> BasicAuthenticationSession.class;
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> <span class="java&#45;object">Class</span>&#60;? <span class="java&#45;keyword">extends</span> WebPage&#62; getSignInPageClass() &#123;
		<span class="java&#45;keyword">return</span> SignInPage.class;
	&#125;
&#125;</pre></div><p class="paragraph"/>The authentication logic inside authenticate has been kept quite trivial in order to make the code as clean as possible. Please note also that session class must have a constructor that accepts an instance of class <code>Request</code>.<p class="paragraph"/><h3>Redirecting user to an intermediate page</h3><p class="paragraph"/>Method <code>restartResponseAtSignInPage</code> is an example of redirecting user to an intermediate page before allowing him to access to the requested page. This method internally throws exception <code>org.apache.wicket.RestartResponseAtInterceptPageException</code> which saves the URL of the requested page into session metadata and then redirects user to the page passed as constructor parameter (the sign in page).<p class="paragraph"/>Component's method <code>redirectToInterceptPage(Page)</code> works in much the same way as <code>restartResponseAtSignInPage</code> but it allows us to specify which page to use as intermediate page:<p class="paragraph"/><div class="code"><pre>redirectToInterceptPage(intermediatePage);</pre></div><p class="paragraph"/><blockquote class="note">
Since both <code>restartResponseAtSignInPage</code> and <code>redirectToInterceptPage</code> internally throw an exception, the code placed after them will not be executed.
</blockquote>



<h2 id="security_2">22.2 Authorizations</h2>
<p class="paragraph"/>The authorization support provided by Wicket is built around the concept of authorization strategy which is represented by interface <code>IAuthorizationStrategy</code> (in package <code>org.apache.wicket.authorization</code>):<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">interface</span> IAuthorizationStrategy
&#123;
  //<span class="java&#45;keyword">interface</span> methods 
 &#60;T <span class="java&#45;keyword">extends</span> IRequestableComponent&#62; <span class="java&#45;object">boolean</span> isInstantiationAuthorized(<span class="java&#45;object">Class</span>&#60;T&#62; componentClass);
 <span class="java&#45;object">boolean</span> isActionAuthorized(Component component, Action action);<p class="paragraph"/> //<span class="java&#45;keyword">default</span> authorization strategy that allows everything
 <span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> <span class="java&#45;keyword">final</span> IAuthorizationStrategy ALLOW_ALL = <span class="java&#45;keyword">new</span> IAuthorizationStrategy()
 &#123;
  @Override
  <span class="java&#45;keyword">public</span> &#60;T <span class="java&#45;keyword">extends</span> IRequestableComponent&#62; <span class="java&#45;object">boolean</span> isInstantiationAuthorized(<span class="java&#45;keyword">final</span> <span class="java&#45;object">Class</span>&#60;T&#62; c)
  &#123;
    <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">true</span>;
  &#125;
  @Override
  <span class="java&#45;keyword">public</span> <span class="java&#45;object">boolean</span> isActionAuthorized(Component c, Action action)
  &#123;
    <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">true</span>;
  &#125;
 &#125;;
&#125;</pre></div><p class="paragraph"/>This interface defines two methods:
<ul class="star">
<li>isInstantiationAuthorized checks if user is allowed to instantiate a given component.</li>
<li>isActionAuthorized checks if user is authorized to perform a given action on a component's instance. The standard actions checked by this method are defined into class Action and are Action.ENABLE and Action.RENDER.</li>
</ul><p class="paragraph"/>Inside <code>IAuthorizationStrategy</code> we can also find a default implementation of the interface (called ALLOW_ALL) that allows everyone to instantiate every component and perform every possible action on it. This is the default strategy adopted by class <code>Application</code>.<p class="paragraph"/>To change the authorization strategy in use we must register the desired implementation into security settings (class <code>SecuritySettings</code>) during initialization phase with method setAuthorization Strategy:<p class="paragraph"/><div class="code"><pre>//Application class code&#8230; 
  @Override
  <span class="java&#45;keyword">public</span> void init()
  &#123;
    <span class="java&#45;keyword">super</span>.init();
    getSecuritySettings().
	setAuthorizationStrategy(myAuthorizationStrategy);
  &#125;	
//...</pre></div><p class="paragraph"/>If we want to combine the action of two or more authorization strategies we can chain them with strategy <code>CompoundAuthorizationStrategy</code> which implements composite pattern for authorization strategies.<p class="paragraph"/>Most of the times we won't need to implement an <code>IAuthorizationStrategy</code> from scratch as Wicket already comes with a set of built-in strategies. In the next paragraphs we will see some of these strategies that can be used to implement an effective and flexible security policy.<p class="paragraph"/><h3>SimplePageAuthorizationStrategy</h3><p class="paragraph"/>Abstract class SimplePageAuthorizationStrategy (in package <code>org.apache.wicket.authorization.strategies.page</code>) is a strategy that checks user authorizations calling abstract method <code>isAuthorized</code> only for those pages that are subclasses of a given supertype. If <code>isAuthorized</code> returns false, the user is redirected to the sign in page specified as second constructor parameter:<p class="paragraph"/><div class="code"><pre>SimplePageAuthorizationStrategy authorizationStrategy = <span class="java&#45;keyword">new</span> SimplePageAuthorizationStrategy( 
                                                  PageClassToCheck.class, SignInPage.class)
&#123;
  <span class="java&#45;keyword">protected</span> <span class="java&#45;object">boolean</span> isAuthorized()
  &#123;		                
    //Authentication code&#8230;
  &#125;
&#125;;</pre></div><p class="paragraph"/>By default <code>SimplePageAuthorizationStrategy</code> checks for permissions only on pages. If we want to change this behavior and check also other kinds of components, we must override method <code>isActionAuthorized</code> and implement our custom logic inside it.<p class="paragraph"/><h3>Role-based strategies</h3><p class="paragraph"/>At the end of <a href="../guide/single.html#security_1" class="guide">paragraph 22.1</a> we have introduced AbstractAuthenticatedWebSession's method getRoles which is provided to support role-based authorization returning the set of roles granted to the current user.<p class="paragraph"/>In Wicket roles are simple strings like ‚ÄúBASIC_USER‚Äù or ‚ÄúADMIN‚Äù (they don't need to be capitalized) and they are handled with class <code>org.apache.wicket.authroles.authorization.strategies.role.Roles</code>. This class extends standard HashSet collection adding some functionalities to check whether the set contains one or more roles. Class <code>Roles</code> already defines roles Roles.USER and Roles.ADMIN.<p class="paragraph"/>The session class in the following example returns a custom ‚ÄúSIGNED_IN‚Äù role for every authenticated user and it adds an Roles.ADMIN role if username is equal to superuser:<p class="paragraph"/><div class="code"><pre>class BasicAuthenticationRolesSession <span class="java&#45;keyword">extends</span> AuthenticatedWebSession &#123;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> userName;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> BasicAuthenticationRolesSession(Request request) &#123;
		<span class="java&#45;keyword">super</span>(request);		
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">boolean</span> authenticate(<span class="java&#45;object">String</span> username, <span class="java&#45;object">String</span> password) &#123;
		<span class="java&#45;object">boolean</span> authResult= <span class="java&#45;keyword">false</span>;<p class="paragraph"/>		authResult = //some authentication logic...<p class="paragraph"/>		<span class="java&#45;keyword">if</span>(authResult)
			userName = username;<p class="paragraph"/>		<span class="java&#45;keyword">return</span> authResult;
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> Roles getRoles() &#123;
		Roles resultRoles = <span class="java&#45;keyword">new</span> Roles();<p class="paragraph"/>		<span class="java&#45;keyword">if</span>(isSignedIn())
			resultRoles.add(<span class="java&#45;quote">"SIGNED_IN"</span>);<p class="paragraph"/>		<span class="java&#45;keyword">if</span>(userName.equals(<span class="java&#45;quote">"superuser"</span>))
			resultRoles.add(Roles.ADMIN);<p class="paragraph"/>		<span class="java&#45;keyword">return</span> resultRoles;
	&#125;
&#125;</pre></div><p class="paragraph"/>Roles can be adopted to apply security restrictions on our pages and components. This can be done  using one of the two built-in authorization strategies that extend super class <code>AbstractRoleAuthorizationStrategyWicket</code>: <code>MetaDataRoleAuthorizationStrategy</code> and <code>AnnotationsRoleAuthorizationStrategy</code><p class="paragraph"/>The difference between these two strategies is that <code>MetaDataRoleAuthorizationStrategy</code> handles role-based authorizations with Wicket metadata while <code>AnnotationsRoleAuthorizationStrategy</code> uses Java annotations.<p class="paragraph"/><blockquote class="note">
Application class <code>AuthenticatedWebApplication</code> already sets <code>MetaDataRoleAuthorizationStrategy</code> and <code>AnnotationsRoleAuthorizationStrategy</code> as its own authorization strategies (it uses a compound strategy as we will see in <a href="../guide/single.html#security_2" class="guide">paragraph 22.2</a>).<p class="paragraph"/>The code that we will see in the next examples is for illustrative purpose only. If our application class inherits from <code>AuthenticatedWebApplication</code> we won't need to configure anything to use these two strategies.
</blockquote><p class="paragraph"/><h4>Using roles with metadata</h4><p class="paragraph"/>Strategy <code>MetaDataRoleAuthorizationStrategy</code> uses application and components metadata to implement role-based authorizations. The class defines a set of static methods authorize that can be used to specify which roles are allowed to instantiate a component and which roles can perform a given action on a component.<p class="paragraph"/>The following code snippet reports both application and session classes from project <code>MetaDataRolesStrategyExample</code> and illustrates how to use <code>MetaDataRoleAuthorizationStrategy</code> to allow access to a given page (AdminOnlyPage) only to ADMIN role:<p class="paragraph"/><strong class="bold">Application class:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class WicketApplication <span class="java&#45;keyword">extends</span> AuthenticatedWebApplication&#123;    		
   @Override
   <span class="java&#45;keyword">public</span> <span class="java&#45;object">Class</span>&#60;? <span class="java&#45;keyword">extends</span> WebPage&#62; getHomePage()&#123;
      <span class="java&#45;keyword">return</span> HomePage.class;
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">protected</span> <span class="java&#45;object">Class</span>&#60;? <span class="java&#45;keyword">extends</span> AbstractAuthenticatedWebSession&#62; getWebSessionClass() &#123;
      <span class="java&#45;keyword">return</span> BasicAuthenticationSession.class;
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">protected</span> <span class="java&#45;object">Class</span>&#60;? <span class="java&#45;keyword">extends</span> WebPage&#62; getSignInPageClass() &#123;
      <span class="java&#45;keyword">return</span> SignInPage.class;
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">public</span> void init()&#123;   
      getSecuritySettings().setAuthorizationStrategy(<span class="java&#45;keyword">new</span> MetaDataRoleAuthorizationStrategy(<span class="java&#45;keyword">this</span>));
      MetaDataRoleAuthorizationStrategy.authorize(AdminOnlyPage.class, Roles.ADMIN);
   &#125;
&#125;</pre></div><p class="paragraph"/><strong class="bold">Session class:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class BasicAuthenticationSession <span class="java&#45;keyword">extends</span> AuthenticatedWebSession &#123;<p class="paragraph"/>   <span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> username;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> BasicAuthenticationSession(Request request) &#123;
      <span class="java&#45;keyword">super</span>(request);      
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">public</span> <span class="java&#45;object">boolean</span> authenticate(<span class="java&#45;object">String</span> username, <span class="java&#45;object">String</span> password) &#123;
      //user is authenticated <span class="java&#45;keyword">if</span> username and password are equal
     <span class="java&#45;object">boolean</span> authResult = username.equals(password);<p class="paragraph"/>      <span class="java&#45;keyword">if</span>(authResult)
         <span class="java&#45;keyword">this</span>.username = username;<p class="paragraph"/>      <span class="java&#45;keyword">return</span> authResult;
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> Roles getRoles() &#123;
      Roles resultRoles = <span class="java&#45;keyword">new</span> Roles();
      //<span class="java&#45;keyword">if</span> user is signed in add the relative role
      <span class="java&#45;keyword">if</span>(isSignedIn())
         resultRoles.add(<span class="java&#45;quote">"SIGNED_IN"</span>);
      //<span class="java&#45;keyword">if</span> username is equal to 'superuser' add the ADMIN role
      <span class="java&#45;keyword">if</span>(username!= <span class="java&#45;keyword">null</span> &#38;&#38; username.equals(<span class="java&#45;quote">"superuser"</span>))
         resultRoles.add(Roles.ADMIN);<p class="paragraph"/>      <span class="java&#45;keyword">return</span> resultRoles;
   &#125;<p class="paragraph"/>   @Override
   <span class="java&#45;keyword">public</span> void signOut() &#123;
      <span class="java&#45;keyword">super</span>.signOut();
      username = <span class="java&#45;keyword">null</span>;
   &#125;
&#125;</pre></div><p class="paragraph"/>The code that instantiates <code>MetaDataRoleAuthorizationStrategy</code> and set it as application's strategy is inside application class method init.<p class="paragraph"/>Any subclass of <code>AbstractRoleAuthorizationStrategyWicket</code> needs an implementation of interface <code>IRoleCheckingStrategy</code> to be instantiated. For this purpose in the code above we used the application class itself because its base class <code>AuthenticatedWebApplication</code> already implements interface <code>IRoleCheckingStrategy</code>. By default <code>AuthenticatedWebApplication</code> checks for authorizations using the roles returned by the current <code>AbstractAuthenticatedWebSession</code>. As final step inside init we grant the access to page <code>AdminOnlyPage</code> to ADMIN role calling method authorize.<p class="paragraph"/>The code from session class has three interesting methods. The first is authenticate which considers as valid credentials every pair of username and password having the same value. The second notable method is getRoles which returns role SIGNED_IN if user is authenticated and it adds role ADMIN if username is equal to superuser. Finally, we have method signOut which has been overridden in order to clean the username field used internally to generate roles.<p class="paragraph"/>Now if we run the project and we try to access to <code>AdminOnlyPage</code> from the home page without having the ADMIN role, we will be redirected to the default access-denied page used by Wicket:<p class="paragraph"/><img border="0" class="center" src="../img/authorization-access-denied.png"></img><p class="paragraph"/>The access-denied page can be customized using method <code>setAccessDeniedPage(Class&#60;? extends Page&#62;)</code> of setting class <code>ApplicationSettings</code>:<p class="paragraph"/><div class="code"><pre>//Application class code&#8230;
   @Override
   <span class="java&#45;keyword">public</span> void init()&#123;   
      getApplicationSettings().setAccessDeniedPage(
			MyCustomAccessDeniedPage.class); 
   &#125;</pre></div><p class="paragraph"/>Just like custom ‚ÄúPage expired‚Äù page (see <a href="../guide/single.html#versioningCaching_2" class="guide">chapter 8.2.5</a>), also custom ‚ÄúAccess denied‚Äù page must be bookmarkable.<p class="paragraph"/><h4>Using roles with annotations</h4><p class="paragraph"/>Strategy <code>AnnotationsRoleAuthorizationStrategy</code> relies on two built-in annotations to handle role-based authorizations. These annotations are <code>AuthorizeInstantiation</code> and <code>AuthorizeAction</code>. As their names suggest the first annotation specifies which roles are allowed to instantiate the annotated component while the second must be used to indicate which roles are allowed to perform a specific action on the annotated component.<p class="paragraph"/>In the following example we use annotations to make a page accessible only to signed-in users and to enable it only if user has the ADMIN role:<p class="paragraph"/><div class="code"><pre>@AuthorizeInstantiation(<span class="java&#45;quote">"SIGNED_IN"</span>)
@AuthorizeAction(action = <span class="java&#45;quote">"ENABLE"</span>, roles = &#123;<span class="java&#45;quote">"ADMIN"</span>&#125;)
<span class="java&#45;keyword">public</span> class MyPage <span class="java&#45;keyword">extends</span> WebPage &#123;
   //Page class code&#8230;
&#125;</pre></div><p class="paragraph"/>Remember that when a component is not enabled, user can render it but he can neither click on its links nor interact with its forms.<p class="paragraph"/>Example project <code>AnnotationsRolesStrategyExample</code> is a revisited version of <code>MetaDataRolesStrategyExample</code> where we use <code>AnnotationsRoleAuthorizationStrategy</code> as authorization strategy. To ensure that page <code>AdminOnlyPage</code> is accessible only to ADMIN role we have used the following annotation:<p class="paragraph"/><div class="code"><pre>@AuthorizeInstantiation(<span class="java&#45;quote">"ADMIN"</span>)
<span class="java&#45;keyword">public</span> class AdminOnlyPage <span class="java&#45;keyword">extends</span> WebPage &#123;
    //Page class code&#8230;
&#125;</pre></div><p class="paragraph"/><h3>Catching an unauthorized component instantiation</h3><p class="paragraph"/>Interface IUnauthorizedComponentInstantiationListener (in package <code>org.apache.wicket.authorization</code>) is provided to give the chance to handle the case in which a user tries to instantiate a component without having the permissions to do it. The method defined inside this interface is <code>onUnauthorizedInstantiation(Component)</code> and it is executed whenever a user attempts to execute an unauthorized instantiation.<p class="paragraph"/>This listener must be registered into application's security settings with method <code>setUnauthorizedComponentInstantiationListener</code> defined by setting class <code>SecuritySettings</code>. In the following code snippet we register a listener that redirect user to a warning page if he tries to do a not-allowed instantiation:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class WicketApplication <span class="java&#45;keyword">extends</span> AuthenticatedWebApplication&#123;   
     //Application code&#8230;
     @Override
     <span class="java&#45;keyword">public</span> void init()&#123;    
        getSecuritySettings().setUnauthorizedComponentInstantiationListener(
			<span class="java&#45;keyword">new</span> IUnauthorizedComponentInstantiationListener() &#123;<p class="paragraph"/>	    @Override
	    <span class="java&#45;keyword">public</span> void onUnauthorizedInstantiation(Component component) &#123;
	        component.setResponsePage(AuthWarningPage.class);
	    &#125;
        &#125;);
     &#125;
&#125;</pre></div><p class="paragraph"/>In addition to interface <code>IRoleCheckingStrategy</code>, class <code>AuthenticatedWebApplication</code> implements also <code>IUnauthorizedComponentInstantiationListener</code> and registers itself as listener for unauthorized instantiations.<p class="paragraph"/>By default <code>AuthenticatedWebApplication</code> redirects users to sign-in page if they are not signed-in and they try to instantiate a restricted component. Otherwise, if users are already signed in but they are not allowed to instantiate a given component, an <code>UnauthorizedInstantiationException</code> will be thrown.<p class="paragraph"/><h3>Strategy RoleAuthorizationStrategy</h3><p class="paragraph"/>Class <code>RoleAuthorizationStrategy</code> is a compound strategy that combines both <code>MetaDataRoleAuthorizationStrategy</code> and <code>AnnotationsRoleAuthorizationStrategy</code>.<p class="paragraph"/>This is the strategy used internally by <code>AuthenticatedWebApplication</code>.



<h2 id="security_3">22.3 Using HTTPS protocol</h2>
<p class="paragraph"/>HTTPS is the standard technology adopted on Internet to create a secure communication channel between web applications and their users.<p class="paragraph"/>In Wicket we can easily protect our pages with HTTPS mounting a special request mapper called <code>HttpsMapper</code> and using annotation RequireHttps with those pages we want to serve over this protocol. Both these two entities are in package <code>org.apache.wicket.protocol.https</code>.<p class="paragraph"/>HttpsMapper wraps an existing mapper and redirects incoming requests to HTTPS if the related response must render a page containing annotation <code>RequireHttps</code>. Most of the times the wrapped mapper will be the root one, just like we saw before for <code>CryptoMapper</code> in <a href="../guide/single.html#urls_6" class="guide">paragraph 10.6</a>.<p class="paragraph"/>Another parameter needed to build a <code>HttpsMapper</code> is an instance of class <code>HttpsConfi</code>g. This class allows us to specify which ports must be used for HTTPS and HTTP. By default the port numbers used by these two protocols are respectively 443 and 80.<p class="paragraph"/>The following code is taken from project <code>HttpsProtocolExample</code> and illustrates how to enable HTTPS  in our applications:<p class="paragraph"/><div class="code"><pre>//Application class code&#8230;
@Override
<span class="java&#45;keyword">public</span> void init()&#123;   
   setRootRequestMapper(<span class="java&#45;keyword">new</span> HttpsMapper(getRootRequestMapper(), 
                                       <span class="java&#45;keyword">new</span> HttpsConfig(8080, 443))); 
&#125;</pre></div><p class="paragraph"/>Now we can use annotation RequireHttps to specify which pages must be served using HTTPS:<p class="paragraph"/><div class="code"><pre>@RequireHttps
<span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
    <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
    	<span class="java&#45;keyword">super</span>(parameters);	
    &#125;
&#125;</pre></div><p class="paragraph"/>If we want to protect many pages with HTTPS without adding annotation <code>RequireHttps</code> to each of them, we can annotate a marker interface or a base page class and implement/extend it in any page we want to make secure:<p class="paragraph"/><div class="code"><pre>// Marker <span class="java&#45;keyword">interface</span>:
@RequireHttps
<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">interface</span> IMarker&#123;
&#125;<p class="paragraph"/>// Base class:
@RequireHttps
<span class="java&#45;keyword">public</span> class BaseClass <span class="java&#45;keyword">extends</span> WebPage&#123;
//Page code&#8230;
&#125;<p class="paragraph"/>// Secure page inheriting from BaseClass:
<span class="java&#45;keyword">public</span> class HttpsPage <span class="java&#45;keyword">extends</span> BaseClass&#123;
//Page code&#8230;
&#125;<p class="paragraph"/>// Secure page implementing IMarker:
<span class="java&#45;keyword">public</span> class HttpsPage <span class="java&#45;keyword">implements</span> IMarker&#123;
//Page code&#8230;
&#125;</pre></div>



<h2 id="security_4">22.4 URLs encryption in detail</h2>
In chapter <a href="../guide/single.html#urls_6" class="guide">10.6</a> we have seen how to encrypt URLs using <code>CryptoMapper</code> request mapper. To encrypt/decrypt page URLs <code>CryptoMapper</code> uses an instance of <code>org.apache.wicket.util.crypt.ICrypt</code> interface:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">interface</span> ICrypt
&#123;
	<span class="java&#45;object">String</span> encryptUrlSafe(<span class="java&#45;keyword">final</span> <span class="java&#45;object">String</span> plainText);<p class="paragraph"/>	<span class="java&#45;object">String</span> decryptUrlSafe(<span class="java&#45;keyword">final</span> <span class="java&#45;object">String</span> encryptedText);<p class="paragraph"/>	&#8230;
&#125;</pre></div><p class="paragraph"/>The default implementation for this interface is class <code>org.apache.wicket.util.crypt.SunJceCrypt</code>. It provides password-based cryptography using <code>PBEWithMD5AndDES</code> algorithm coming with the standard security providers in the Java Runtime Environment.<p class="paragraph"/><blockquote class="note">
For better security it is recommended to install Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html" target="blank">Policy Files</a> for your version of JDK/JRE and use stronger algorithms. See this <a href="https://github.com/apache/wicket/blob/42ce1faa57d3617ccaa443045537306fabf4d71a/wicket-util/src/test/java/org/apache/wicket/util/crypt/UnlimitedStrengthJurisdictionPolicyTest.java#L67" target="blank">example</a> of a custom <code>ICrypt</code> implementation for inspiration.
</blockquote><p class="paragraph"/>By using <code>CryptoMapper(IRequestMapper wrappedMapper, Application application)</code> constructor the mapper will use the configured <code>org.apache.wicket.util.crypt.ICryptFactory</code> from <code>org.apache.wicket.settings.SecuritySettings#getCryptFactory()</code>. To use a stronger cryptography mechanism there are the following options:
<ul class="star">
<li>The first option is to use constructor <code>CryptoMapper(IRequestMapper wrappedMapper, IProvider&#60;ICrypt&#62; cryptProvider)</code> and give it an implementation of <code>org.apache.wicket.util.IProvider</code> that returns a custom <code>org.apache.wicket.util.crypt.ICrypt</code>.</li>
</ul><p class="paragraph"/><blockquote class="note">
<code>org.apache.wicket.util.IProvider</code> is a single-method interface that acts as object supplier:
</blockquote><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">interface</span> IProvider&#60;T&#62;
&#123;
	T get();
&#125;</pre></div>
<ul class="star">
<li>The second option is to register a cipher factory at application level with method <code>setCryptFactory(ICryptFactory cryptFactory)</code> of class <code>SecuritySettings</code>:</li>
</ul><p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init() &#123;
	<span class="java&#45;keyword">super</span>.init();
	getSecuritySettings().setCryptFactory(<span class="java&#45;keyword">new</span> SomeCryptFactory());
	setRootRequestMapper(<span class="java&#45;keyword">new</span> CryptoMapper(getRootRequestMapper(), <span class="java&#45;keyword">this</span>));
&#125;</pre></div><p class="paragraph"/>
Since version 6.19.0 Wicket uses <code>org.apache.wicket.core.util.crypt.KeyInSessionSunJceCryptFactory</code> as a default factory for <code>ICrypt</code> objects. This factory generates a unique key for each user that is stored in her HTTP 
session. This way it helps to protect the application against <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" target="blank">CSRF</a> attacks - the &#60;form&#62; action url will be encrypted in such way that it will be unique
for each user of the application. The url itself serves as <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Encrypted_Token_Pattern" target="blank">encrypted token</a>.<p class="paragraph"/><blockquote class="warning">
<code>org.apache.wicket.core.util.crypt.KeyInSessionSunJceCryptFactory</code> binds the http session if it is not already bound! If the application needs to run in stateless mode then the application will have to provide a custom 
implementation of <code>ICryptFactory</code> that stores the user specific keys by other means.
</blockquote>



<h2 id="security_5">22.5 Package Resource Guard</h2>
<p class="paragraph"/>Wicket internally uses an entity called package resource guard to protect package resources from external access. This entity is an implementation of interface <code>org.apache.wicket.markup.html.IPackageResourceGuard</code>.<p class="paragraph"/>By default Wicket applications use as package resource guard class <code>SecurePackageResourceGuard</code>, which allows to access only to the following file extensions (grouped by type):<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th>File</th><th>Extensions</th></tr><tr class="table-odd"><td><strong class="bold">JavaScript files</strong></td><td>.js</td></tr><tr class="table-even"><td><strong class="bold">CSS files</strong></td><td>.css</td></tr><tr class="table-odd"><td><strong class="bold">HTML pages</strong></td><td>.html</td></tr><tr class="table-even"><td><strong class="bold">Textual files</strong></td><td>.txt</td></tr><tr class="table-odd"><td><strong class="bold">Flash files</strong></td><td>.swf</td></tr><tr class="table-even"><td><strong class="bold">Picture files</strong></td><td>.png, .jpg, .jpeg, .gif, .ico, .cur, .bmp, .svg</td></tr><tr class="table-odd"><td><strong class="bold">Web font files</strong></td><td>.eot, .ttf, .woff</td></tr></table><p class="paragraph"/>To modify the set of allowed files formats we can add one or more patterns with method <code>addPattern(String)</code>. The rules to write a pattern are the following:
<ul class="star">
<li>patterns start with either a "+" or a "-". In the first case the pattern will add one or more file to the set while starting a pattern with a ‚Äú-‚Äù we exclude all the files matching the given pattern. For example pattern ‚Äú-web.xml‚Äù excludes all web.xml files in all directories.</li>
<li>wildcard character ‚Äú&#42;‚Äù is supported as placeholder for zero or more characters. For example  pattern ‚Äú+&#42;.mp4‚Äù adds all the mp4 files inside all directories.</li>
<li>subdirectories are supported as well. For example pattern ‚Äú+documents/&#42;.pdf‚Äù adds all pdf files under ‚Äúdocuments‚Äù directory. Character ‚Äú&#42;‚Äù can be used with directories to specify a nesting level. For example ‚Äú+documents/&#42;/&#42;.pdf‚Äù adds all pdf files placed one level below ‚Äúdocuments‚Äù directory.</li>
<li>a double wildcard character ‚Äú&#42;&#42;‚Äù indicates zero or more subdirectories. For example pattern ‚Äú+documents/&#42;&#42;/&#42;.pdf‚Äù adds all pdf files placed inside ‚Äúdocuments‚Äù directory or inside any of its subdirectories.</li>
</ul><p class="paragraph"/>Patterns that allow to access to every file with a given extensions (such as ‚Äú+&#42;.pdf‚Äù) should be always avoided in favour of more restrictive expressions that contain a directory structure:<p class="paragraph"/><div class="code"><pre>//Application class code&#8230;
@Override
<span class="java&#45;keyword">public</span> void init()   
&#123;
      IPackageResourceGuard packageResourceGuard = application.getResourceSettings() 
                                                   .getPackageResourceGuard();
      <span class="java&#45;keyword">if</span> (packageResourceGuard <span class="java&#45;keyword">instanceof</span> SecurePackageResourceGuard)
      &#123;
         SecurePackageResourceGuard guard = (SecurePackageResourceGuard) packageResourceGuard;
         //Allow to access only to pdf files placed in the ‚Äú<span class="java&#45;keyword">public</span>‚Äù directory.
         guard.addPattern(<span class="java&#45;quote">"+<span class="java&#45;keyword">public</span>/&#42;.pdf"</span>);
      &#125;
&#125;</pre></div>



<h2 id="security_6">22.6 Summary</h2>
<p class="paragraph"/> In this chapter we have seen the components and the mechanisms that allow us to implement security policies in our Wicket-based applications. Wicket comes with an out of the box support for both authorization and authentication.<p class="paragraph"/>The central element of authorization mechanism is the interface <code>IAuthorizationStrategy</code> which decouples our components from any detail about security strategy. The implementations of this interface must decide if a user is allowed to instantiate a given page or component and if she/he can perform a given action on it.<p class="paragraph"/>Wicket natively supports role-based authorizations with strategies <code>MetaDataRoleAuthorizationStrategy</code> and <code>AnnotationsRoleAuthorizationStrategy</code>. The difference between these two strategies is that the first offers a programmatic approach for role handling while the second promotes a declarative approach using built-in annotations.<p class="paragraph"/>After having explored how Wicket internally implements authentication and authorization, in the last part of the chapter we have learnt how to configure our applications to support HTTPS and how to specify which pages must be served over this protocol.<p class="paragraph"/>In the last paragraph we have seen how Wicket protects package resources with a guard entity that allows us to decide which package resources can be accessed from users.<p class="paragraph"/><p class="paragraph"/>


<h1 id="testing">23 Test Driven Development with Wicket</h1>
<a href="http://en.wikipedia.org/wiki/Test-driven_development" target="blank">Test Driven Development</a> has become a crucial activity for every modern development methodology. This chapter will cover the built-in support for testing provided by Wicket with its rich set of helper and mock classes that allows us to test our components and our applications in isolation (i.e without the need for a servlet container) using JUnit, the de facto standard for Java unit testing.<p class="paragraph"/>In this chapter we will see how to write unit tests for our applications and components and we will learn how to use helper classes to simulate user navigation and write acceptance tests without the need of any testing framework other than JUnit.<p class="paragraph"/>The JUnit version used in this chapter is 4.x.   


<h2 id="testing_1">23.1 Utility class WicketTester</h2>
<p class="paragraph"/>A good way to start getting confident with Wicket unit testing support is looking at the test case class <code>TestHomePage</code> that is automatically generated by Maven when we use Wicket archetype to create a new project:<p class="paragraph"/><img border="0" class="center" src="../img/mvn-wicket-archetype.png"></img><p class="paragraph"/>Here is the content of TestHomePage:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class TestHomePage&#123;
	<span class="java&#45;keyword">private</span> WicketTester tester;<p class="paragraph"/>	@Before
	<span class="java&#45;keyword">public</span> void setUp()&#123;
		tester = <span class="java&#45;keyword">new</span> WicketTester(<span class="java&#45;keyword">new</span> WicketApplication());
	&#125;
	@Test
	<span class="java&#45;keyword">public</span> void homepageRendersSuccessfully()&#123;
		//start and render the test page
		tester.startPage(HomePage.class);
		//assert rendered page class
		tester.assertRenderedPage(HomePage.class);
	&#125;
&#125;</pre></div><p class="paragraph"/>The central class in a Wicket testing is <code>org.apache.wicket.util.tester.WicketTester</code>. This utility class provides a set of methods to render a component, click links, check if page contains a given component or a feedback message, and so on.<p class="paragraph"/>The basic test case shipped with <code>TestHomePage</code> illustrates how <code>WicketTester</code> is typically instantiated (inside method <code>setUp()</code>). In order to test our components, WicketTester needs to use an instance of <code>WebApplication</code>. Usually, we will use our application class as <code>WebApplication</code>, but we can also decide to build WicketTester invoking its no-argument constructor and letting it automatically build a mock web application (an instance of class <code>org.apache.wicket.mock.MockApplication</code>).<p class="paragraph"/>The code from <code>TestHomePage</code> introduces two basic methods to test our pages. The first is method <code>startPage</code> that renders a new instance of the given page class and sets it as current rendered page for WicketTester. The second method is assertRenderedPage which checks if the current rendered page is an instance of the given class. In this way if TestHomePage succeeds we are sure that page HomePage has been rendered without any problem. The last rendered page can be retrieved with method <code>getLastRenderedPage</code>.<p class="paragraph"/>That's only a taste of what <code>WicketTester</code> can do. In the next paragraphs we will see how it can be used to test every element that composes a Wicket page (links, models, behaviors, etc...).<p class="paragraph"/><h3>Testing links</h3><p class="paragraph"/>A click on a Wicket link can be simulated with method <code>clickLink</code> which takes in input the link component or the page-relative path to it.<p class="paragraph"/>To see an example of usage of clickLink, let's consider again project <code>LifeCycleStagesRevisited</code>. As we know from chapter 5 the home page of the project alternately displays two different labels (‚ÄúFirst label‚Äù and ‚ÄúSecond label‚Äù), swapping between them each time button "reload" is clicked. The code from its test case checks that label has actually changed after button "reload" has been pressed:<p class="paragraph"/><div class="code"><pre>//&#8230;
@Test
<span class="java&#45;keyword">public</span> void switchLabelTest()&#123;
	//start and render the test page
	tester.startPage(HomePage.class);
	//assert rendered page class
	tester.assertRenderedPage(HomePage.class);
	//assert rendered label
	tester.assertLabel(<span class="java&#45;quote">"label"</span>, <span class="java&#45;quote">"First label"</span>);
	//simulate a click on <span class="java&#45;quote">"reload"</span> button
	tester.clickLink(<span class="java&#45;quote">"reload"</span>);
	//assert rendered label
	tester.assertLabel(<span class="java&#45;quote">"label"</span>, <span class="java&#45;quote">"Second label"</span>);	
&#125;
//...</pre></div><p class="paragraph"/>In the code above we have used <code>clickLink</code> to click on the "reload" button and force page to be rendered again. In addition, we have used also method <code>assertLabel</code> that checks if a given label contains the expected text.<p class="paragraph"/>By default <code>clickLink</code> assumes that AJAX is enabled on client side. To switch AJAX off we can use another version of this method that takes in input the path to the link component and a boolean flag that indicates if AJAX must be enabled (true) or not (false).<p class="paragraph"/><div class="code"><pre>//&#8230;
//simulate a click on a button without AJAX support
tester.clickLink(<span class="java&#45;quote">"reload"</span>, <span class="java&#45;keyword">false</span>);
//...</pre></div><p class="paragraph"/><h3>Testing component status</h3><p class="paragraph"/>WicketTester provides also a set of methods to test the states of a component. They are:
<ul class="star">
<li><strong class="bold">assertEnabled(String path)/assertDisabled(String path)</strong>: they test if a component is enabled or not.</li>
<li><strong class="bold">assertVisible(String path)/assertInvisible(String path)</strong>: they test component visibility.</li>
<li><strong class="bold">assertRequired(String path)</strong>: checks if a form component is required.</li>
</ul><p class="paragraph"/>In the test case from project <code>CustomDatepickerAjax</code> we used <code>assertEnabled</code>/<code>assertDisabled</code> to check if button "update" really disables our datepicker:<p class="paragraph"/><div class="code"><pre>//&#8230;
@Test
<span class="java&#45;keyword">public</span> void testDisableDatePickerWithButton()&#123;
	//start and render the test page
	tester.startPage(HomePage.class);
	//assert that datepicker is enabled
	tester.assertEnabled(<span class="java&#45;quote">"form:datepicker"</span>);
	//click on update button to disable datepicker
	tester.clickLink(<span class="java&#45;quote">"update"</span>);
	//assert that datepicker is disabled
	tester.assertDisabled(<span class="java&#45;quote">"form:datepicker"</span>);		
&#125;
//...</pre></div><p class="paragraph"/><h3>Testing components in isolation</h3><p class="paragraph"/>Method <code>startComponent(Component)</code> can be used to test a component in isolation without having to create a container page for this purpose. The target component is rendered and both its methods <code>onInitialize()</code> and <code>onBeforeRender()</code> are executed. In the test case from project <code>CustomFormComponentPanel</code> we used this method to check if our custom form component correctly renders its internal label:<p class="paragraph"/><div class="code"><pre>//&#8230;
@Test
<span class="java&#45;keyword">public</span> void testCustomPanelContainsLabel()&#123;
	TemperatureDegreeField field = <span class="java&#45;keyword">new</span> TemperatureDegreeField(<span class="java&#45;quote">"field"</span>, Model.of(0.00));
	//Use standard JUnit class Assert	
	Assert.assertNull(field.get(<span class="java&#45;quote">"mesuramentUnit"</span>));		
	tester.startComponent(field);		
	Assert.assertNotNull(field.get(<span class="java&#45;quote">"mesuramentUnit"</span>));
&#125;
//...</pre></div><p class="paragraph"/>If test requires a page we can use <code>startComponentInPage(Component)</code> which automatically generates a page for our component.<p class="paragraph"/><h3>Testing the response</h3><p class="paragraph"/><code>WicketTester</code> allows us to access to the last response generated during testing with method <code>getLastResponse</code>. The returned value is an instance of class MockHttpServletResponse that provides helper methods to extract informations from mocked request.<p class="paragraph"/>In the test case from project <code>CustomResourceMounting</code> we extract the text contained in the last response with method <code>getDocument</code> and we check if it is equal to the RSS feed used for the test:<p class="paragraph"/><div class="code"><pre>//&#8230;
@Test
<span class="java&#45;keyword">public</span> void testMountedResourceResponse() <span class="java&#45;keyword">throws</span> IOException, FeedException&#123;tester.startResource(<span class="java&#45;keyword">new</span> RSSProducerResource());
	<span class="java&#45;object">String</span> responseTxt = tester.getLastResponse().getDocument();
	//write the RSS feed used in the test into a ByteArrayOutputStream
	ByteArrayOutputStream outputStream = <span class="java&#45;keyword">new</span> ByteArrayOutputStream();
	Writer writer = <span class="java&#45;keyword">new</span> OutputStreamWriter(outputStream);
	SyndFeedOutput output = <span class="java&#45;keyword">new</span> SyndFeedOutput();<p class="paragraph"/>	output.output(RSSProducerResource.getFeed(), writer);
	//the response and the RSS must be equal 
	Assert.assertEquals(responseTxt, outputStream.toString());
&#125;
//...</pre></div><p class="paragraph"/>To simulate a request to the custom resource we used method <code>startResource</code> which can be used also with resource references.<p class="paragraph"/><h3>Testing URLs</h3><p class="paragraph"/><code>WicketTester</code> can be pointed to an arbitrary URL with method <code>executeUrl(String url)</code>. This can be useful to test mounted pages, resources or request mappers:<p class="paragraph"/><div class="code"><pre>//&#8230;
//the resource was mapped at '/foo/bar'
tester.executeUrl(<span class="java&#45;quote">"./foo/bar"</span>);	
//...</pre></div><p class="paragraph"/><h3>Testing AJAX components</h3><p class="paragraph"/>If our application uses AJAX to refresh components markup, we can test if <code>AjaxRequestTarget</code> contains a given component with <code>WicketTester</code>'s method <code>assertComponentOnAjaxResponse</code>:<p class="paragraph"/><div class="code"><pre>//&#8230;
//test <span class="java&#45;keyword">if</span> AjaxRequestTarget contains a component (using its instance)
tester.assertComponentOnAjaxResponse(amountLabel);	
//&#8230;
//test <span class="java&#45;keyword">if</span> AjaxRequestTarget contains a component (using its path)
tester.assertComponentOnAjaxResponse(<span class="java&#45;quote">"pathToLabel:labelId"</span>);</pre></div><p class="paragraph"/>It's also possible to use method <code>isComponentOnAjaxResponse(Component cmp)</code> to know if a component has been added to <code>AjaxRequestTarget</code>:<p class="paragraph"/><div class="code"><pre>//&#8230;
//test <span class="java&#45;keyword">if</span> AjaxRequestTarget does NOT contain amountLabel 
assertFalse(tester.isComponentOnAjaxResponse(amountLabel));	
//...</pre></div><p class="paragraph"/><h3>Testing AJAX events</h3><p class="paragraph"/>Behavior <code>AjaxEventBehavior</code> and its subclasses can be tested simulating AJAX events with <code>WicketTester</code>'s method <code>executeAjaxEvent(Component cmp, String event)</code>. Here is the sample code from project <code>TestAjaxEventsExample</code>:<p class="paragraph"/><strong class="bold">Home page code:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
 <span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> <span class="java&#45;object">String</span> INIT_VALUE = <span class="java&#45;quote">"Initial value"</span>;
 <span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> <span class="java&#45;object">String</span> OTHER_VALUE = <span class="java&#45;quote">"Other value"</span>;<p class="paragraph"/> <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
	<span class="java&#45;keyword">super</span>(parameters);
	Label label;
	add(label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"label"</span>, INIT_VALUE));				
	label.add(<span class="java&#45;keyword">new</span> AjaxEventBehavior(<span class="java&#45;quote">"click"</span>) &#123;<p class="paragraph"/>		@Override
		<span class="java&#45;keyword">protected</span> void onEvent(AjaxRequestTarget target) &#123;
			//change label's data object
			getComponent().setDefaultModelObject(
                                                  OTHER_VALUE);
			target.add(getComponent());
		&#125;
	&#125;).setOutputMarkupId(<span class="java&#45;keyword">true</span>);
	//&#8230;
 &#125;
&#125;</pre></div><p class="paragraph"/><strong class="bold">Test method:</strong><p class="paragraph"/><div class="code"><pre>@Test
<span class="java&#45;keyword">public</span> void testAjaxBehavior()&#123;
	//start and render the test page
	tester.startPage(HomePage.class);
	//test <span class="java&#45;keyword">if</span> label has the initial expected value
	tester.assertLabel(<span class="java&#45;quote">"label"</span>, HomePage.INIT_VALUE);		
	//simulate an AJAX <span class="java&#45;quote">"click"</span> event
	tester.executeAjaxEvent(<span class="java&#45;quote">"label"</span>, <span class="java&#45;quote">"click"</span>);
	//test <span class="java&#45;keyword">if</span> label has changed as expected
	tester.assertLabel(<span class="java&#45;quote">"label"</span>, HomePage.OTHER_VALUE);
&#125;</pre></div><p class="paragraph"/><h3>Testing AJAX behaviors</h3><p class="paragraph"/>To test a generic AJAX behavior we can simulate a request to it using <code>WicketTester</code>'s method <code>executeBehavior(AbstractAjaxBehavior behavior)</code>:<p class="paragraph"/><div class="code"><pre>//&#8230;
AjaxFormComponentUpdatingBehavior ajaxBehavior = 
		<span class="java&#45;keyword">new</span> AjaxFormComponentUpdatingBehavior(<span class="java&#45;quote">"change"</span>)&#123;
	@Override
	<span class="java&#45;keyword">protected</span> void onUpdate(AjaxRequestTarget target) &#123;
		//...				
	&#125;
&#125;;
component.add(ajaxBehavior);
//&#8230;
//execute AJAX behavior, i.e. onUpdate will be invoked 
tester.executeBehavior(ajaxBehavior));	
//...</pre></div><p class="paragraph"/><h3>Using a custom servlet context</h3><p class="paragraph"/>In <a href="../guide/single.html#resources_13" class="guide">paragraph 16.13</a> we have seen how to configure our application to store resource files into a custom folder placed inside webapp root folder (see project <code>CustomFolder4MarkupExample</code>).<p class="paragraph"/>In order to write testing code for applications that use this kind of customization, we must tell <code>WicketTester</code> which folder to use as webapp root. This is necessary as under test environment we don't have any web server, hence it's impossible for <code>WicketTester</code> to retrieve this parameter from servlet context.<p class="paragraph"/>Webapp root folder can be passed to <code>WicketTester</code>'s constructor as further parameter like we did in the test case of project <code>CustomFolder4MarkupExample</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class TestHomePage&#123;
   <span class="java&#45;keyword">private</span> WicketTester tester;<p class="paragraph"/>   @Before
   <span class="java&#45;keyword">public</span> void setUp()&#123;
      //build the path to webapp root folder   
      File curDirectory = <span class="java&#45;keyword">new</span> File(<span class="java&#45;object">System</span>.getProperty(<span class="java&#45;quote">"user.dir"</span>));
      File webContextDir = <span class="java&#45;keyword">new</span> File(curDirectory, <span class="java&#45;quote">"src/main/webapp"</span>);<p class="paragraph"/>      tester = <span class="java&#45;keyword">new</span> WicketTester(<span class="java&#45;keyword">new</span> WicketApplication(), webContextDir.getAbsolutePath());
   &#125;
   //test methods&#8230;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
After a test method has been executed, we may need to clear any possible side effect occurred to the <code>Application</code> and <code>Session</code> objects. This can be done invoking <code>WicketTester</code>'s method <code>destroy()</code>:<p class="paragraph"/><div class="code"><pre>@After
<span class="java&#45;keyword">public</span> void tearDown()&#123;
	//clear any side effect occurred during test.
	tester.destroy();
&#125;</pre></div>
</blockquote>



<h2 id="testing_2">23.2 Testing Wicket forms</h2>
<p class="paragraph"/>Wicket provides utility class FormTester that is expressly designed to test Wicket forms. A new FormTester is returned by <code>WicketTester</code>'s method <code>newFormTester(String, boolean)</code> which takes in input the page-relative path of the form we want to test and a boolean flag indicating if its form components must be filled with a blank string:<p class="paragraph"/><div class="code"><pre>//&#8230;
//create a <span class="java&#45;keyword">new</span> form tester without filling its form components with a blank string
FormTester formTester = tester.newFormTester(<span class="java&#45;quote">"form"</span>, <span class="java&#45;keyword">false</span>);
//...</pre></div><p class="paragraph"/><code>FormTester</code> can simulate form submission with method submit which takes in input as optional parameter the submitting component to use instead of the default one:<p class="paragraph"/><div class="code"><pre>//&#8230;
//create a <span class="java&#45;keyword">new</span> form tester without filling its form components with a blank string
FormTester formTester = tester.newFormTester(<span class="java&#45;quote">"form"</span>, <span class="java&#45;keyword">false</span>);
//submit form with <span class="java&#45;keyword">default</span> submitter
formTester.submit();
//&#8230;
//submit form using <span class="java&#45;keyword">inner</span> component 'button' as alternate button
formTester.submit(<span class="java&#45;quote">"button"</span>);</pre></div><p class="paragraph"/>If we want to submit a form with an external link component we can use method <code>submitLink(String path, boolean pageRelative)</code> specifying the path to the link.<p class="paragraph"/>In the next paragraphs we will see how to use <code>WicketTester</code> and <code>FormTester</code> to interact with a form and with its children components.<p class="paragraph"/><h3>Setting form components input</h3><p class="paragraph"/>The purpose of a HTML form is to collect user input. <code>FormTester</code> comes with the following set of methods that simulate input insertion into form's fields:
<ul class="star">
<li><strong class="bold">setValue(String path, String value)</strong>: inserts the given textual value into the specified component. It can be used with components <code>TextField</code> and <code>TextArea</code>. A version of this method that accepts a component instance instead of its path is also available.</li>
<li><strong class="bold">setValue(String checkboxId, boolean value)</strong>: sets the value of a given <code>CheckBox</code> component.</li>
<li><strong class="bold">setFile(String formComponentId, File file, String contentType)</strong>: sets a <code>File</code> object on a <code>FileUploadField</code> component.</li>
<li><strong class="bold">select(String formComponentId, int index)</strong>: selects an option among a list of possible options owned by a component. It supports components that are subclasses of <code>AbstractChoice</code> along with <code>RadioGroup</code> and <code>CheckGroup</code>.</li>
<li><strong class="bold">selectMultiple(String formComponentId, int indexes)</strong>: selects all the options corresponding to the given array of indexes. It can be used with multiple-choice components like <code>CheckGroup</code> or <code>ListMultipleChoice</code>.</li>
</ul><p class="paragraph"/><code>setValue</code> is used inside method <code>insertUsernamePassword</code> to set the username and password fields of the form used in project <code>StatelessLoginForm</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">protected</span> void insertUsernamePassword(<span class="java&#45;object">String</span> username, <span class="java&#45;object">String</span> password) &#123;
	//start and render the test page
	tester.startPage(HomePage.class);
	FormTester formTester = tester.newFormTester(<span class="java&#45;quote">"form"</span>);
	//set credentials
	formTester.setValue(<span class="java&#45;quote">"username"</span>, username);
	formTester.setValue(<span class="java&#45;quote">"password"</span>, password);		
	//submit form
	formTester.submit();
&#125;</pre></div><p class="paragraph"/><h3>Testing feedback messages</h3><p class="paragraph"/>To check if a page contains one or more expected feedback messages we can use the following methods provided by <code>WicketTester</code>:
<ul class="star">
<li><strong class="bold">assertFeedback(String path, String&#8230; messages)</strong>: asserts that a given panel contains the specified messages</li>
<li><strong class="bold">assertInfoMessages(String&#8230; expectedInfoMessages)</strong>: asserts that the expected info messages are rendered in the page.</li>
<li><strong class="bold">assertErrorMessages(String&#8230; expectedErrorMessages)</strong>: asserts that the expected error messages are rendered in the page.</li>
</ul><p class="paragraph"/><code>assertInfoMessages</code> and <code>assertErrorMessages</code> are used in the test case from project <code>StatelessLoginForm</code> to check that form generates a feedback message in accordance with the login result:<p class="paragraph"/>
<div class="code"><pre>@Test
<span class="java&#45;keyword">public</span> void testMessageForSuccessfulLogin()&#123;
	inserUsernamePassword(<span class="java&#45;quote">"user"</span>, <span class="java&#45;quote">"user"</span>);	
	tester.assertInfoMessages(<span class="java&#45;quote">"Username and password are correct!"</span>);
&#125;<p class="paragraph"/>@Test
<span class="java&#45;keyword">public</span> void testMessageForFailedLogin ()&#123;
	inserUsernamePassword(<span class="java&#45;quote">"wrongCredential"</span>, <span class="java&#45;quote">"wrongCredential"</span>);		
	tester.assertErrorMessages(<span class="java&#45;quote">"Wrong username or password"</span>);
&#125;</pre></div><p class="paragraph"/><h3>Testing models</h3><p class="paragraph"/>Component model can be tested as well. With method <code>assertModelValue</code> we can test if a specific component has the expected data object inside its model.<p class="paragraph"/>This method has been used in the test case of project <code>ModelChainingExample</code> to check if the form and the drop-down menu share the same data object:<p class="paragraph"/><div class="code"><pre>@Test
<span class="java&#45;keyword">public</span> void testFormSelectSameModelObject()&#123;
	PersonListDetails personListDetails = <span class="java&#45;keyword">new</span> PersonListDetails();
	DropDownChoice dropDownChoice = (DropDownChoice) personListDetails.get(<span class="java&#45;quote">"persons"</span>);
	List choices = dropDownChoice.getChoices();
	//select the second option of the drop&#45;down menu
	dropDownChoice.setModelObject(choices.get(1));<p class="paragraph"/>	//start and render the test page
	tester.startPage(personListDetails);		
	//assert that form has the same data object used by drop&#45;down menu
	tester.assertModelValue(<span class="java&#45;quote">"form"</span>, dropDownChoice.getModelObject());
&#125;</pre></div>


<h2 id="testing_3">23.3 Testing markup with TagTester</h2>
<p class="paragraph"/>If we need to test component markup at a more fine-grained level, we can use class <code>TagTester</code> from package <code>org.apache.wicket.util.tester</code>.<p class="paragraph"/>This test class allows to check if the generated markup contains one or more tags having a given attribute with a given value. TagTester can not be directly instantiated but it comes with three factory methods that return one or more TagTester matching the searching criteria. In the following test case (from project <code>TagTesterExample</code>) we retrieve the first tag of the home page (a &#60;span&#62; tag) having attribute class equal to myClass:<p class="paragraph"/><strong class="bold">HomePage markup:</strong><p class="paragraph"/><div class="code"><pre>&#60;html xmlns:wicket=<span class="java&#45;quote">"http://wicket.apache.org"</span>&#62;
	&#60;head&#62;
		&#60;meta charset=<span class="java&#45;quote">"utf&#45;8"</span> /&#62;
		&#60;title&#62;&#60;/title&#62;
	&#60;/head&#62;
	&#60;body&#62;
		&#60;span class=<span class="java&#45;quote">"myClass"</span>&#62;&#60;/span&#62;
		&#60;div class=<span class="java&#45;quote">"myClass"</span>&#62;&#60;/div&#62;
	&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><strong class="bold">Test method:</strong><p class="paragraph"/><div class="code"><pre>@Test
<span class="java&#45;keyword">public</span> void homePageMarkupTest()
&#123;
	//start and render the test page
	tester.startPage(HomePage.class);
	//retrieve response's markup
	<span class="java&#45;object">String</span> responseTxt = tester.getLastResponse().getDocument();<p class="paragraph"/>	TagTester tagTester = TagTester.createTagByAttribute(responseTxt, <span class="java&#45;quote">"class"</span>, <span class="java&#45;quote">"myClass"</span>);<p class="paragraph"/>	Assert.assertNotNull(tagTester);
	Assert.assertEquals(<span class="java&#45;quote">"span"</span>, tagTester.getName());<p class="paragraph"/>	List&#60;TagTester&#62; tagTesterList = TagTester.createTagsByAttribute(responseTxt, 
						<span class="java&#45;quote">"class"</span>, <span class="java&#45;quote">"myClass"</span>, <span class="java&#45;keyword">false</span>);<p class="paragraph"/>	Assert.assertEquals(2, tagTesterList.size());
&#125;</pre></div><p class="paragraph"/>The name of the tag found by TagTester can be retrieved with its method getName. Method <code>createTagsByAttribute</code> returns all the tags that have the given value on the class attribute. In the code above we have used this method to test that our markup contains two tags having attribute class equal to myClass.<p class="paragraph"/>Another utility class that comes in handy when we want to test components markup is <code>ComponentRenderer</code> in package <code>org.apache.wicket.core.util.string</code>. The purpose of this class is to render a page or a component in isolation with its static methods <code>renderComponent</code> and <code>renderPage</code>. Both methods return the generated markup as <code>CharSequence</code>:<p class="paragraph"/><div class="code"><pre>@Test
<span class="java&#45;keyword">public</span> void customComponentMarkupTest()
&#123;
	//instantiate MyComponent
	MyComponent myComponent = //...<p class="paragraph"/>	//render and save component markup
	<span class="java&#45;object">String</span> componentMarkup = ComponentRenderer.renderComponent(myComponent);<p class="paragraph"/>	//perform test operations
	//&#8230;
&#125;</pre></div> 


<h2 id="testing_4">23.4 Summary</h2>
<p class="paragraph"/>With a component-oriented framework we can test our pages and components as we use to do with any other Java entity. Wicket offers a complete support for writing testing code, offering built-in tools to test nearly all the elements that build up our applications (pages, containers, links, behaviors, etc...).<p class="paragraph"/>The main entity discussed in this chapter has been class <code>WicketTester</code> which can be used to write unit tests and acceptance tests for our application, but we have also seen how to test forms with <code>FormTester</code> and how to inspect markup with <code>TagTester</code>.<p class="paragraph"/>In addition to learning how to use the utility classes provided by Wicket for testing, we have also experienced the innovative approach of Wicket to web testing that allows to test components in isolation without the need of running our tests with a web server and depending only on JUnit as testing framework.<p class="paragraph"/><p class="paragraph"/>


<h1 id="testingspring">24 Test Driven Development with Wicket and Spring</h1>
Since the development of many web applications is mostly based on the Spring framework for dependency injection and application configuration in general, it's especially important to get these two frameworks running together smoothly¬†not only when deployed on a running server instance itself but rather during the execution of JUnit based integration tests as well. Thanks to the <code>WicketTester</code> API provided by the Wicket framework itself, one can easily build high-quality web applications while practicing test driven development and providing a decent set of unit and integration tests to be executed with each build. As already mentioned previously, integration and configuration of our web applications is based on a lightweight Spring container meaning that the integration of Spring's <code>ApplicationContext</code> and a WicketTester API is essential to get our integration tests running. In order to explain how to achieve that integration in an easy and elegant fashion in your integration test environment, we'll first take a look at a configuration of these 2 framework beauties in a runtime environment.



<h2 id="testingspring_1">24.1 Configuration of the runtime environment</h2>
<p class="paragraph"/>In order to get the Wicket framework up to speed when your server is up and running, you usually configure a <code>WicketFilter</code> instance in your web application deployment descriptor file (<code>web.xml</code>) while passing it a single init parameter called <code>applicationClassName</code> that points to your main implementation class extending¬†<code>org.apache.wicket.protocol.http.WebApplication</code> where all of your application-wide settings and initialization requirements are dealt with:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;filter&#62;</span>
    <span class="xml&#45;tag">&#60;filter&#45;name&#62;</span>wicketfilter<span class="xml&#45;tag">&#60;/filter&#45;name&#62;</span>
    <span class="xml&#45;tag">&#60;filter&#45;class&#62;</span>org.apache.wicket.protocol.http.WicketFilter<span class="xml&#45;tag">&#60;/filter&#45;class&#62;</span>
    <span class="xml&#45;tag">&#60;init&#45;param&#62;</span>
        <span class="xml&#45;tag">&#60;param&#45;name&#62;</span>applicationClassName<span class="xml&#45;tag">&#60;/param&#45;name&#62;</span>
        <span class="xml&#45;tag">&#60;param&#45;value&#62;</span>com.comsysto.webapp.MyWebApplication<span class="xml&#45;tag">&#60;/param&#45;value&#62;</span>
    <span class="xml&#45;tag">&#60;/init&#45;param&#62;</span>
<span class="xml&#45;tag">&#60;/filter&#62;</span></pre></div><p class="paragraph"/>In case you want to get Wicket application up and running while leaving the application configuration and dependency injection issues to the Spring container, the configuration to be provided within the deployment descriptor looks slightly different though:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;web&#45;app&#62;</span>
    <span class="xml&#45;tag">&#60;filter&#62;</span>
        <span class="xml&#45;tag">&#60;filter&#45;name&#62;</span>wicketfilter<span class="xml&#45;tag">&#60;/filter&#45;name&#62;</span>
        <span class="xml&#45;tag">&#60;filter&#45;class&#62;</span>org.apache.wicket.protocol.http.WicketFilter<span class="xml&#45;tag">&#60;/filter&#45;class&#62;</span>
        <span class="xml&#45;tag">&#60;init&#45;param&#62;</span>
            <span class="xml&#45;tag">&#60;param&#45;name&#62;</span>applicationFactoryClassName<span class="xml&#45;tag">&#60;/param&#45;name&#62;</span>
            <span class="xml&#45;tag">&#60;param&#45;value&#62;</span>org.apache.wicket.spring.SpringWebApplicationFactory<span class="xml&#45;tag">&#60;/param&#45;value&#62;</span>
        <span class="xml&#45;tag">&#60;/init&#45;param&#62;</span>
    <span class="xml&#45;tag">&#60;/filter&#62;</span>
    <span class="xml&#45;tag">&#60;listener&#62;</span>
        <span class="xml&#45;tag">&#60;listener&#45;class&#62;</span>org.springframework.web.context.ContextLoaderListener<span class="xml&#45;tag">&#60;/listener&#45;class&#62;</span>
    <span class="xml&#45;tag">&#60;/listener&#62;</span>
    <span class="xml&#45;tag">&#60;context&#45;param&#62;</span>
        <span class="xml&#45;tag">&#60;param&#45;name&#62;</span>contextConfigLocation<span class="xml&#45;tag">&#60;param&#45;name&#62;</span>
        <span class="xml&#45;tag">&#60;param&#45;value&#62;</span>/WEB&#45;INF/applicationContext.xml<span class="xml&#45;tag">&#60;param&#45;value&#62;</span>
    <span class="xml&#45;tag">&#60;/context&#45;param&#62;</span>
<span class="xml&#45;tag">&#60;/web&#45;app&#62;</span></pre></div><p class="paragraph"/>The additional configuration part containing listener and context parameter definition is a usual Spring container related configuration detail. ContextLoaderListener is an implementation¬†of standard Servlet API ServletContextListener interface provided by the Spring framework itself and is responsible for looking up an according bean definition file(s) specified by the context param above and creating an ApplicationContext instance during servlet context initialization accordingly. When integrating an ApplicationContext instance with Wicket, one of the beans defined in the above mentioned Spring bean definition file has to be your own specific extension of <code>org.apache.wicket.protocol.http.WebApplication</code>. You can either define a suitable bean in the bean definition file itself:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;beans&#62;</span>
    <span class="xml&#45;tag">&#60;bean id=<span class="xml&#45;quote">"myWebApp"</span> class=<span class="xml&#45;quote">"com.comsysto.webapp.MyWebApplication"</span>/&#62;</span>
<span class="xml&#45;tag">&#60;/beans&#62;</span></pre></div><p class="paragraph"/>or use powerful classpath scanning feature of the Spring framework and annotate the MyWebApplication implementation with the appropriate <code>&#64;Component</code> annotation accordingly while enabling the Spring container to scan the according package(s) of your application for relevant bean definitions:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;beans&#62;</span>
    <span class="xml&#45;tag">&#60;context:component&#45;scan base&#45;package=<span class="xml&#45;quote">"com.comsysto.webapp"</span> /&#62;</span>
    <span class="xml&#45;tag">&#60;context:component&#45;scan base&#45;package=<span class="xml&#45;quote">"com.comsysto.webapp.service"</span> /&#62;</span>
    <span class="xml&#45;tag">&#60;context:component&#45;scan base&#45;package=<span class="xml&#45;quote">"com.comsysto.webapp.repository"</span> /&#62;</span>
<span class="xml&#45;tag">&#60;/beans&#62;</span></pre></div><p class="paragraph"/>Either way, if everything goes well, you'll get a pre-configured ApplicationContext all set up during the startup of your web container. One of the beans in the ApplicationContext will be your own extension of Wicket's WebApplication type. SpringWebApplicationFactory implementation provided by the Wicket framework itself that you have defined as the <code>applicationFactoryClassName</code> in the configuration of your WicketFilter¬†will then be used in order to retrieve that very same WebApplication¬†bean out of your Spring ApplicationContext. The Factory expects one and only one extension of Wicket's very own WebApplication type to be found within the ApplicationContext instance at runtime. If no such bean or more than one bean extending WebApplication is found in the given ApplicationContext an according IllegalStateException will be raised and initialization of your web application will fail:<p class="paragraph"/><div class="code"><pre>Map&#60;?,?&#62; beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(ac,WebApplication.class, <span class="java&#45;keyword">false</span>, <span class="java&#45;keyword">false</span>);
<span class="java&#45;keyword">if</span> (beans.size() == 0)
&#123;
	<span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> IllegalStateException(<span class="java&#45;quote">"bean of type &#91;"</span> + WebApplication.class.getName() +
			<span class="java&#45;quote">"&#93; not found"</span>);
&#125;
<span class="java&#45;keyword">if</span> (beans.size() &#62; 1)
&#123;
	<span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> IllegalStateException(<span class="java&#45;quote">"more than one bean of type &#91;"</span> +
			WebApplication.class.getName() + <span class="java&#45;quote">"&#93; found, must have only one"</span>);
&#125;</pre></div><p class="paragraph"/>After the WebApplication bean has been successfully retrieved from the ApplicationContext via SpringWebApplicationFactory, WicketFilter will then, as part of its own initialization process, trigger both internalInit() and init() methods of the WebApplication bean. The latter one is the exact spot where the last piece of the runtime configuration puzzle between Wicket and Spring is to be placed :<p class="paragraph"/><div class="code"><pre>@Component
<span class="java&#45;keyword">public</span> class MyWebApplication <span class="java&#45;keyword">extends</span> WebApplication &#123;
    @Override
    <span class="java&#45;keyword">protected</span> void init() &#123;
        addComponentInstantiationListener(<span class="java&#45;keyword">new</span> SpringComponentInjector(<span class="java&#45;keyword">this</span>));
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>SpringComponentInjector provided by the Wicket framework enables you to get dependencies from the ApplicationContext directly injected into your Wicket components by simply annotating these with the according <code>&#64;SpringBean</code> annotation.


<h2 id="testingspring_2">24.2 Configuration of the JUnit based integration test environment</h2>
<p class="paragraph"/>One of the main features of Apache Wicket framework is the ability to easily write and run plain unit tests for your Pages and all other kinds of Components that even include the verification of the rendering process itself by using JUnit framework and the WicketTester API only. When using Spring framework for application configuration together with Wicket, as we do, you can even use the same tools to easily write and run full blown integration tests for your web application as well. All you have to do is use <a href="http://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/testing.html#testcontext-framework" target="blank">Spring's TestContext</a> framework additionally to configure and run your JUnit based integration tests. The Spring Framework provides a set of Spring specific annotations that you can use in your integration tests in conjunction with the TestContext framework itself in order to easily configure an according ApplicationContext instance for your tests as well as for appropriate transaction management before, during and after your test execution. Following code snippet represents a simple JUnit 4 based test case using Spring's specific annotations in order to initialize an ApplicationContext instance prior to executing the test itself:<p class="paragraph"/><div class="code"><pre>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;<span class="java&#45;quote">"classpath:WEB&#45;INF/applicationContext.xml"</span>&#125;)
@TransactionConfiguration(transactionManager = <span class="java&#45;quote">"txManager"</span>, defaultRollback = <span class="java&#45;keyword">false</span>)
<span class="java&#45;keyword">public</span> class LoginPageTest &#123;<p class="paragraph"/>    <span class="java&#45;keyword">private</span> WicketTester tester;<p class="paragraph"/>    @Autowired
    <span class="java&#45;keyword">private</span> ApplicationContext ctx;<p class="paragraph"/>    @Autowired
    <span class="java&#45;keyword">private</span> MyWebApplication myWebApplication;<p class="paragraph"/>    @Before
    <span class="java&#45;keyword">public</span> void setUp() &#123;
        tester = <span class="java&#45;keyword">new</span> WicketTester(myWebApplication);
    &#125;<p class="paragraph"/>    @Test
    @Transactional
    @Rollback(<span class="java&#45;keyword">true</span>)
    <span class="java&#45;keyword">public</span> void testRenderMyPage() &#123;
        tester.startPage(LoginPage.class);
        tester.assertRenderedPage(LoginPage.class);
        tester.assertComponent(<span class="java&#45;quote">"login"</span>, LoginComponent.class);
    &#125;
&#125;</pre></div><p class="paragraph"/>By defining three annotations on the class level (see code snippet above) in your test, Spring's TestContext framework takes care of preparing and initializing an ApplicationContext instance having all the beans defined in the according Spring context file as well as the transaction management in case your integration test includes some kind of database access. Fields marked with <code>&#64;Autowired</code> annotation will be automatically dependency injected as well so that you can easily access and use these for your testing purposes. Since MyWebApplication, which extends Wicket's WebApplication type and represents the main class of our web application, is also a bean within the ApplicationContext managed by Spring, it will also be provided to us by the test framework itself and can be easily used in order to initialize a WicketTester instance later on during the execution of the test's setUp() method. With this kind of simple, annotation based test configuration we are able to run an integration test that verifies whether a LoginPage gets started and initialized, whether the rendering of the page runs smoothly and whether the page itself contains a LoginComponent that we possibly need in order to process user's login successfully.<p class="paragraph"/>When you run this test though, you'll unfortunately get the following exception raised:<p class="paragraph"/><div class="code"><pre>java.lang.IllegalStateException: No WebApplicationContext found: no ContextLoaderListener registered?
    at org.springframework.web.context.support.WebApplicationContextUtils.
	getRequiredWebApplicationContext(WebApplicationContextUtils.java:84)
    at org.apache.wicket.spring.injection.annot.
	SpringComponentInjector.&#60;init&#62;(SpringComponentInjector.java:72)
    at com.comsysto.serviceplatform.uiwebapp.MyWebApplication.
	initializeSpringComponentInjector(MyWebApplication.java:59)
    at com.comsysto.serviceplatform.uiwebapp.MyWebApplication.
	init(MyWebApplication.java:49)
    at org.apache.wicket.protocol.http.WicketFilter.
	init(WicketFilter.java:719)
    at org.apache.wicket.protocol.http.MockWebApplication.
	&#60;init&#62;(MockWebApplication.java:168)
    at org.apache.wicket.util.tester.BaseWicketTester.
	&#60;init&#62;(BaseWicketTester.java:219)
    at org.apache.wicket.util.tester.WicketTester.
	&#60;init&#62;(WicketTester.java:325)
    at org.apache.wicket.util.tester.WicketTester.
	&#60;init&#62;(WicketTester.java:308)</pre></div><p class="paragraph"/>As you can see above, the Exception gets raised during the initialization of the <code>WicketTester</code> instance even before the actual test method gets executed. Even though we have applied rather cool and simple annotation based test configuration already described and passed in perfectly well prepared ApplicationContext instance to the WicketTester instance in the constructor, somewhere down the rabbit hole someone complained that no WebApplicationContext instance could have been found which seems to be required in order to initialize the WicketTester properly.<p class="paragraph"/><img border="0" class="center" src="../img/description-of-illegalstate.jpg"></img><p class="paragraph"/>The problem that we run against here is due to the fact that SpringComponentInjector during its own initialization is trying to get hold of an according Spring's ApplicationContext instance that would normally be there in a runtime environment but does not find any since we are running in a test environment currently. SpringComponentInjector delegates to Spring's own WebApplicationContextUtils class to retrieve the instance of ApplicationContext out of the ServletContext which is perfectly fine for a runtime environment but is unfortunately failing in a test environment:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> WebApplicationContext getRequiredWebApplicationContext(ServletContext sc)
		<span class="java&#45;keyword">throws</span> IllegalStateException &#123;<p class="paragraph"/>	WebApplicationContext wac = getWebApplicationContext(sc);
	<span class="java&#45;keyword">if</span> (wac == <span class="java&#45;keyword">null</span>) &#123;
		<span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> IllegalStateException(<span class="java&#45;quote">"No WebApplicationContext found: no ContextLoaderListener registered?"</span>);
	&#125;
	<span class="java&#45;keyword">return</span> wac;
&#125;</pre></div><p class="paragraph"/>If you still remember we defined a ContextLoaderListener in our web.xml file as part of the configuration of our runtime environment that makes sure an according WebApplicationContext instance gets initialized and registered against the ServletContext properly. Luckily, this problem can easily be solved if we slightly change the way we initialize SpringComponentInjector in our main MyWebApplication class. Apart from the constructor that we have used so far, there is another constructor in the SpringComponentInjector class that expects the caller to provide it with an according ApplicationContext instance rather than trying to resolve one on its own:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> SpringComponentInjector(WebApplication webapp, ApplicationContext ctx,
		<span class="java&#45;object">boolean</span> wrapInProxies)
&#123;
	<span class="java&#45;keyword">if</span> (webapp == <span class="java&#45;keyword">null</span>)
	&#123;
		<span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> IllegalArgumentException(<span class="java&#45;quote">"Argument &#91;&#91;webapp&#93;&#93; cannot be <span class="java&#45;keyword">null</span>"</span>);
	&#125;<p class="paragraph"/>	<span class="java&#45;keyword">if</span> (ctx == <span class="java&#45;keyword">null</span>)
	&#123;
		<span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> IllegalArgumentException(<span class="java&#45;quote">"Argument &#91;&#91;ctx&#93;&#93; cannot be <span class="java&#45;keyword">null</span>"</span>);
	&#125;<p class="paragraph"/>	// store context in application's metadata &#8230;
	webapp.setMetaData(CONTEXT_KEY, <span class="java&#45;keyword">new</span> ApplicationContextHolder(ctx));<p class="paragraph"/>	// &#8230; and create and register the annotation aware injector
	InjectorHolder.setInjector(<span class="java&#45;keyword">new</span> AnnotSpringInjector(<span class="java&#45;keyword">new</span> ContextLocator(), wrapInProxies));
&#125;</pre></div><p class="paragraph"/>In order to use this constructor instead of the one we used previously, we now obviously need to get hold of the <code>ApplicationContext</code> instance on our own in our <code>MyWebApplication</code> implementation. The easiest way to do this is to use Spring's own concept of <a href="http://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-aware" target="blank">lifecycle callbacks</a> provided to the beans managed by the Spring container. Since our <code>MyWebApplication</code> is also a bean managed by the Spring container at runtime (enabled by the classpath scanning and <code>&#64;Component</code> annotation on a type level), we can declare it to implement <code>ApplicationContextAware</code> interface which ensures that it gets provided with the <code>ApplicationContext</code> instance that it runs in by the Spring container itself during startup.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">interface</span> ApplicationContextAware &#123;<p class="paragraph"/>	void setApplicationContext(ApplicationContext applicationContext) <span class="java&#45;keyword">throws</span> BeansException;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>So the relevant parts of <code>MyWebApplication</code> type will now look something like the following code snippet:<p class="paragraph"/><div class="code"><pre>@Component
<span class="java&#45;keyword">public</span> class MyWebApplication <span class="java&#45;keyword">extends</span> WebApplication <span class="java&#45;keyword">implements</span> ApplicationContextAware &#123;
    @Override
    <span class="java&#45;keyword">protected</span> void init() &#123;
        addComponentInstantiationListener(<span class="java&#45;keyword">new</span> SpringComponentInjector(<span class="java&#45;keyword">this</span>, ctx, <span class="java&#45;keyword">true</span>));
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> void setApplicationContext(ApplicationContext applicationContext) <span class="java&#45;keyword">throws</span> BeansException &#123;
        <span class="java&#45;keyword">this</span>.ctx = applicationContext;
    &#125;
&#125;</pre></div><p class="paragraph"/>For additional clarification of how <code>MyWebApplication</code> now relates to both Wicket and Spring framework here is an according class diagram:<p class="paragraph"/><img border="0" class="center" src="../img/mywebapp-class-diagramm.jpg"></img>



<h2 id="testingspring_3">24.3 Summary</h2>
<p class="paragraph"/>With the configuration outlined above, no additional modifications are required to the test itself. It's going to turn green now. This way you can use exactly the same Spring context configuration that you'd use in your runtime environment for running your JUnit based integration tests as well.


<h1 id="bestpractices">25 Wicket Best Practices</h1>
This section is addressed to developers, who have already made their first experiences with Apache Wicket. Developers who get into Wicket often have difficulties with it because they apply the typical JSF and Struts patterns and approaches. These frameworks primarily use procedural programming methods. In contrast Wicket is strongly based on object oriented patterns. So forget all Struts and JSF patterns, otherwise you won't have fun with Wicket in the long run.


<h2 id="bestpractices_1">25.1 Encapsulate components correctly</h2>
<p class="paragraph"/>A component should be self-contained. The user of a component should neither have to know nor care about its internal structure. She should just be familiar with its external interfaces and its documentation in order to be able to use it. This means in detail: Every component that extends Wicket's own Panel type (thus is a Panel itself) must provide its own HTML template. In contrast, when a component extends the classes <code>WebMarkupContainer</code> or <code>Form</code>, there is no HTML template. This implies that you should add components through composition in <code>WebMarkupContainer</code> or <code>Form</code>.<p class="paragraph"/><strong class="bold">Listing 1:</strong><p class="paragraph"/><div class="code"><pre>// Poor component
<span class="java&#45;keyword">public</span> class RegistrationForm <span class="java&#45;keyword">extends</span> Form&#60;Registration&#62; &#123;
    <span class="java&#45;keyword">public</span> RegistrationForm(<span class="java&#45;object">String</span> id, IModel&#60;Registration&#62; regModel) &#123;
        <span class="java&#45;keyword">super</span>(id, <span class="java&#45;keyword">new</span> CompoundPropertyModel&#60;Registration&#62;(regModel))
        // Wrong: RegistrationForm provides its own components
        add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>));
        add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"firstname"</span>));
        add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"lastname"</span>));
    &#125;
&#125;</pre></div><p class="paragraph"/>This snippet is an example for a poor component. The user of the <code>RegistrationForm</code> must know the internal structure of the markup and component in order to use it.<p class="paragraph"/><strong class="bold">Listing 2:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class RegistrationPage <span class="java&#45;keyword">extends</span> Page &#123;
    <span class="java&#45;keyword">public</span> RegistrationPage(IModel&#60;Registration&#62; regModel) &#123;
        Form&#60;?&#62; form = <span class="java&#45;keyword">new</span> RegistrationForm(<span class="java&#45;quote">"form"</span>);
        form.add(<span class="java&#45;keyword">new</span> SubmitButton(<span class="java&#45;quote">"register"</span>) &#123;
            <span class="java&#45;keyword">public</span> void onSubmit() &#123;
                 // <span class="java&#45;keyword">do</span> something
            &#125;
        &#125;);
        add(form);
    &#125;
&#125;</pre></div><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;body&#62;
    &#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
        &#60;!&#45;&#45; These are internal structure information from RegistrationForm &#45;&#45;&#62;
        Username &#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"username"</span>/&#62;
        First name &#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"firstname"</span>/&#62;
        Last name &#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"lastname"</span>/&#62;
        &#60;!&#45;&#45; Above <span class="java&#45;keyword">new</span> components from page which the user knows  &#45;&#45;&#62;
        &#60;input type=<span class="java&#45;quote">"submit"</span> wicket:id=<span class="java&#45;quote">"register"</span> value=<span class="java&#45;quote">"Register"</span>/&#62;
    &#60;/form&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The code above shows the usage of the poor component in the <code>RegistrationPage</code>. You can see that the input fields <code>firstname</code>, <code>lastname</code> and <code>username</code> get used, even though these components are not added explicitly to the <code>RegistrationPage</code>. Avoid this, because other developers cannot directly see that the components were added in <code>RegistrationPage</code> class.<p class="paragraph"/><strong class="bold">Listing 3:</strong><p class="paragraph"/><div class="code"><pre>// Good component
<span class="java&#45;keyword">public</span> class RegistrationInputPanel <span class="java&#45;keyword">extends</span> Panel&#123;
    <span class="java&#45;keyword">public</span> RegistrationInputPanel(<span class="java&#45;object">String</span> id, IModel&#60;Registration&#62; regModel) &#123;
        <span class="java&#45;keyword">super</span>(id, regModel);
        IModel&#60;Registration&#62; compound = <span class="java&#45;keyword">new</span> CompoundPropertyModel&#60;Registration(regmodel)
        Form&#60;Registration&#62; form = <span class="java&#45;keyword">new</span> Form&#60;Registration&#62;(<span class="java&#45;quote">"form"</span>, compound);
        // Correct: Add components to Form over the instance variable
        form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>));
        form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"firstname"</span>));
        form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"lastname"</span>));
        add(form);
    &#125;
&#125;</pre></div><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;body&#62;
    &#60;wicket:panel&#62;
    &#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
        Username &#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"username"</span>/&#62;
        First name &#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"firstname"</span>/&#62;
        Last name &#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"lastname"</span>/&#62;
    &#60;/form&#62;
    &#60;/wicket:panel&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>Now we have a properly encapsulated input component which provides its own markup. Furthermore you can see the correct usage of a Wicket <code>Form</code>. The components get added by calling <code>form.add(Component)</code> on the instance variable. On the other hand, it is allowed to add behaviours and validators over inheritance, because those do not have markup ids which must be bound.<p class="paragraph"/>With that, the usage of <code>RegistrationInputPanel</code> is much more intuitive. There is no markup of other embedded components present anymore, just markup of components which get directly added. The <code>RegistrationPage</code> provides its own form that delegates the submit to all Wicket nested forms which are contained in the component tree.<p class="paragraph"/><strong class="bold">Listing 4:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class RegistrationPage <span class="java&#45;keyword">extends</span> Page &#123;
    <span class="java&#45;keyword">public</span> RegistrationPage(IModel&#60;Registration&#62; regModel) &#123;
        Form&#60;?&#62; form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>);
        form.add(<span class="java&#45;keyword">new</span> RegistrationInputPanel(<span class="java&#45;quote">"registration"</span>, regModel);
        form.add(<span class="java&#45;keyword">new</span> SubmitButton(<span class="java&#45;quote">"register"</span>) &#123;
            <span class="java&#45;keyword">public</span> void onSubmit() &#123;
              // <span class="java&#45;keyword">do</span> something
            &#125;
        &#125;);
        add(form);
    &#125;
&#125;</pre></div><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;body&#62;
    &#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
        &#60;div wicket:id=<span class="java&#45;quote">"registration"</span>&#62;
           Display the RegistrationInputPanel
        &#60;/div&#62;
        &#60;input type=&#38;rdquo;submit&#38;rdquo; wicket:id=<span class="java&#45;quote">"register"</span> value=<span class="java&#45;quote">"Register"</span>/&#62;
    &#60;/form&#62;
&#60;/body&#62;
&#60;/html&#62;</pre></div>


<h2 id="bestpractices_2">25.2 Put models and page data in fields</h2>
<p class="paragraph"/>In contrast to Struts, Wicket pages and components are no singletons, they are stateful and session-scoped. This enables us to store user-specific information within pages and components. The information should be stored in fields. This way you can access the information within a class while avoiding long method signatures only for passing the same information around. Instances of components can exist for several requests. For example, a page with a form which gets submitted and produces validation errors uses the same page instance. Furthermore the same page instance gets used when the user presses the back button of the browser and resubmits this formular again. Information which gets passed by the constructor should be assigned to fields (normally this must be models). When storing information in fields you should consider that the information is serializable, because the pages are stored in Wicket's page map. By default the page map stores the pages on the hard disk. A non-serializable object leads to <code>NullPointerExceptions</code> and <code>NonSerializableExceptions</code>. Additionally, big data (like binary stuff) should not be stored directly in fields because this can cause performance losses and memory leaks during serialization and deserialization. In this case, you should use the <code>LoadableDetachableModel</code> which can be assigned to a field because this provides an efficient mechanism to load and detach data.


<h2 id="bestpractices_3">25.3 Correct naming for Wicket IDs</h2>
<p class="paragraph"/>For many developers, naming is a dispensable thing, but I think it is one of the major topics in software development. With the help of correct naming, you can easily identify the business aspects of a software component. Additionally good naming avoids unneccessary and bad comments.<p class="paragraph"/>Bad namings for Wicket-IDs are <code>birthdateTextField</code>, <code>firstnameField</code> and <code>addressPanel</code>. Why? The naming contains two aspects: A technical aspect ( <em class="italic">"TextField"</em> ) and the business aspect ( <em class="italic">"birthdate"</em> ). Only the the business aspect is relevant because both the HTML template as well as the Java code already contain the technical details ("<code>new TextField("birthdate")</code>)". Additionally, such names add a lot of effort when you do technical refactorings, e.g. if you have to replace a <code>TextField</code> by a <code>DatePicker</code> and the Wicket ID <code>birthdateTextField</code> becomes <code>birthdateDatePicker</code>. Another reason for avoiding technical aspects in Wicket IDs is the <code>CompoundPropertyModel</code>. This model delegates the properties to its child components named by Wicket IDs (see listing 3). For example the <code>TextField username</code> automatically calls <code>setUsername()</code> and <code>getUsername()</code> on the <code>Registration</code> object. A setter like <code>setUsernameTextfield()</code> would be very inconvenient here.


<h2 id="bestpractices_4">25.4 Avoid changes at the component tree</h2>
<p class="paragraph"/>You should consider Wicket's component tree a constant and fixed skeleton which gets revived when its model is filled with data like a robot without brain. Without brain the robot is not able to do anything and is just a dead and fixed skeleton. However, when you fill it with data, it becomes alive and can act. There is no need for changing hardware when filling him with data. In Wicket, you should manipulate the component tree as little as possible. Consequently, you should avoid calling methods like <code>Component.replace(Component)</code> and <code>Component.remove(Component)</code>. Calling these methods indicates missing usage or misusage of Wicket's models. Furthermore the component trees should not be constructed using conditions (see listing 5). This reduces the possibility of reusing the same instance significantly.<p class="paragraph"/><strong class="bold">Listing 5:</strong><p class="paragraph"/><div class="code"><pre>// typical <span class="java&#45;keyword">for</span> struts
<span class="java&#45;keyword">if</span>(MySession.get().isNotLoggedIn()) &#123;
    add(<span class="java&#45;keyword">new</span> LoginBoxPanel(<span class="java&#45;quote">"login"</span>))
&#125;
<span class="java&#45;keyword">else</span> &#123;
    add(<span class="java&#45;keyword">new</span> EmptyPanel(<span class="java&#45;quote">"login"</span>))
&#125;</pre></div><p class="paragraph"/>Instead of constructing <code>LoginBoxPanel</code> conditionally, it is recommended to always add the panel  and control the visibility by overriding <code>isVisible()</code>. So the component <code>LoginBoxPanel</code> is responsible for displaying itself. We move the responsibility into the same component which executes the login. Brilliant! Cleanly encapsulated business logic. There is no decision from outside, the component handles all the logic. You can see another example in "Implement visibilities of components correctly".


<h2 id="bestpractices_5">25.5 Implement visibilities of components correctly</h2>
<p class="paragraph"/>Visibility of components is an important topic. In Wicket you control any component's visibility via the methods¬†<code>isVisible()</code> and <code>setVisible()</code>. These methods are within Wicket's base class <code>Component</code> and therefore it is applicable for every component and page. Let's have a look at a concrete example of <code>LoginBoxPanel</code>. The panel just gets displayed when the user is not logged in.<p class="paragraph"/><strong class="bold">Listing 6:</strong><p class="paragraph"/><div class="code"><pre>// Poor implementation
LoginBoxPanel loginBox = <span class="java&#45;keyword">new</span> LoginBoxPanel(<span class="java&#45;quote">"login"</span>);
loginBox.setVisible(MySession.get().isNotLoggedIn());
add(loginBox);</pre></div><p class="paragraph"/>Listing 6 shows a poor implementation, because a decision about the visibility is made while instanciating the component. Again, in Wicket instances of components exist for several requests. To reuse the same instance you have to call <code>loginBox.setVisible(false)</code>. This is very unhandy, because we always have to call <code>setVisible()</code> and manage the visibility. Furthermore you are going to duplicate the states, because visible is equal to "not logged in". So we have two saved states, one for the business aspect "not logged in" and one for the technical aspect "visible". Both is always equal. This approach is error-prone and fragile, because we always have to pay attention to setting the correct information every time. But this is often forgotten because the logic is widely spread over the code. The solution is the Hollywood principle: "Don't call us, we'll call you.". Take a look at the following diagram illustrating an application flow with some calls. We avoid three calls through the <a href="http://en.wikipedia.org/wiki/Hollywood_Principle" target="blank">Hollywood-Principle</a> and we just have to instanciate the <code>LoginBoxPanel</code>.<p class="paragraph"/><img border="0" class="center" src="../img/login_calls_hollywood.png"></img><p class="paragraph"/><strong class="bold">Listing 7:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class LoginBoxPanel &#123;
    // constructor etc.
    @Override
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">boolean</span> isVisible() &#123;
        <span class="java&#45;keyword">return</span> MySession.get().isNotLoggedIn();
    &#125;
&#125;;</pre></div><p class="paragraph"/>Now the control over visibility has been inverted, the <code>LoginBoxPanel</code> decides on its visibility autonomously. For each call of <code>isVisible()</code> there is a refreshed interpretion of the login state. Hence, there is no additional state that might be outdated. The logic is centralized in one line code and not spread throughout the application. Furthermore, you can easily identify that the technical aspect <code>isVisible()</code> correlates to the business aspect "logged in". The same rules can be applied to the method <code>isEnabled()</code>. If <code>isEnabled()</code> returns false the components get displayed in gray. Forms which are within an inactive or invisible component do not get executed.<p class="paragraph"/>Note that there are cases in which you cannot avoid¬†to call the methods <code>setVisible()</code> and <code>setEnabled()</code>. An example: The user presses a button to display an inlined registration form. In general, you can apply the following rules: data driven components override these methods and delegates to the data model. User triggered events call the method <code>setVisible(boolean)</code>. You can also override these methods with inline implementations:<p class="paragraph"/><strong class="bold">Listing 8:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"headline"</span>, headlineModel) &#123;
    @Override
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">boolean</span> isVisible() &#123;
        // Hidden headline <span class="java&#45;keyword">if</span> text starts with <span class="java&#45;quote">"Berlusconi"</span>
        <span class="java&#45;object">String</span> headline = getModelObject();
        <span class="java&#45;keyword">return</span> headline.startWith(<span class="java&#45;quote">"Berlusconi"</span>);
    &#125;
&#125;</pre></div><p class="paragraph"/><strong class="bold">Note:</strong> Some people insist on overriding <code>isVisible()</code> being <a href="http://www.mail-archive.com/dev@wicket.apache.org/msg07123.html" target="blank">a bad thing</a>. The method <code>isVisible()</code> gets called very often (more than once for each request!), so you have to ensure that the calls within <code>isVisible()</code> are cheap. The main point is that the visibility of a component should be controlled by its own and not be controlled by other components. This avoids a wide-spread logic over the whole application. Another way you can realize this is to override <code>onConfigure()</code> and set the visibility there. This method gets called once during each request.


<h2 id="bestpractices_6">25.6 Always use models</h2>
<p class="paragraph"/>Always use models - period! Do not pass raw objects directly to components. Instances of pages and components can exist for several requests. If you use raw objects, you cannot replace them later. An example is an entity which gets loaded at each request within a <code>LoadableDetachableModel</code>. The entity manager creates a new object reference, but the page would keep the obsolete instance. Always pass <code>IModel</code> in the constructor of your components:<p class="paragraph"/><strong class="bold">Listing 9:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class RegistrationInputPanel <span class="java&#45;keyword">extends</span> Panel&#123;
    // Correct: The class Registration gets wrapped by IModel
    <span class="java&#45;keyword">public</span> RegistrationInputPanel(<span class="java&#45;object">String</span> id, IModel&#60;Registration&#62; regModel) &#123;
        // add components
    &#125;
&#125;</pre></div><p class="paragraph"/>This code can use any implementation of <code>IModel</code>, e.g. the class <code>Model</code>, a <code>PropertyModel</code> or a custom implementation of <code>LoadableDetachableModel</code> which loads and persists the values automatically. The model implementations gets very easy to replace. You - as a developer - just need to know: if I call <code>IModel.getObject()</code>, I will get an object of type <code>Registration</code>. Where the object comes from is within the responsibility of the model implementation and the calling component. For example you can pass the model while instanciating the component. If you avoid using models, you will almost certainly have to modify the component tree sooner or later which forces you to duplicate states and thus produce unmaintainable code. Additionally, you should use models due to serialization issues. Objects which get stored in fields of pages and components get serialized and deserialized on each request. This can be inefficient in some cases.


<h2 id="bestpractices_7">25.7 Do not unwrap models within the constructor hierarchy</h2>
<p class="paragraph"/>Avoid unwrapping models within the constructor hierarchy, i.e. do not call <code>IModel.getObject()</code> within any constructor. As already mentioned, a page instance can exist for several page requests, so you might store obsolete and redundant infomation. It is reasonable to unpack Wicket Models at events (user actions), that are methods like <code>onUpdate()</code>, <code>onClick() or </code>onSubmit()@:<p class="paragraph"/><strong class="bold">Listing 10:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"register"</span>) &#123;
    <span class="java&#45;keyword">public</span> void onSubmit() &#123;
        // correct, unwrap model in an event call
        Registration reg = registrationModel.getObject()
        userService.register(reg);
    &#125;
&#125;</pre></div><p class="paragraph"/>An additional possibility to unwrap models is via overriding methods like <code>isVisible()</code>, <code>isEnabled()</code> or <code>onBeforeRender()</code>.


<h2 id="bestpractices_8">25.8 Pass models extended components</h2>
<p class="paragraph"/>Always try to pass models on to the parent component. By that, you ensure that at the end of every request the method <code>IModel.detach()</code> gets called. This method is responsible for a data cleanup. Another example: you have implemented your own model which persists the data in the <code>detach()</code> method. So the call of <code>detach()</code> is necessary for that your data gets persisted. You can see an exemplary passing to the super constructor here:<p class="paragraph"/><strong class="bold">Listing 11:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class RegistrationInputPanel <span class="java&#45;keyword">extends</span> Panel&#123;
    <span class="java&#45;keyword">public</span> RegistrationInputPanel(<span class="java&#45;object">String</span> id, IModel&#60;Registration&#62; regModel) &#123;
        <span class="java&#45;keyword">super</span>(id, regModel)
        // add components
    &#125;
&#125;</pre></div>


<h2 id="bestpractices_9">25.9 Validators must not change any data or models</h2>
<p class="paragraph"/>Validators should just validate. Consider a bank account form which has a <code>BankFormValidator</code>. This validator checks the bank data over a webservice and corrects the bank name. Nobody would expect that a validator modifies information. Such logic has to be located in <code>Form.onSubmit()</code> or in the event logic of a button.


<h2 id="bestpractices_10">25.10 Do not pass components to constructors</h2>
<p class="paragraph"/>Do not pass entire components or pages to constructors of other components.<p class="paragraph"/><strong class="bold">Listing 12:</strong><p class="paragraph"/><div class="code"><pre>// Bad solution
<span class="java&#45;keyword">public</span> class SettingsPage <span class="java&#45;keyword">extends</span> Page &#123;
    <span class="java&#45;keyword">public</span> SettingsPage (IModel&#60;Settings&#62; settingsModel, <span class="java&#45;keyword">final</span> Webpage backToPage) &#123;
        Form&#60;?&#62; form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>);
        // add components
        form.add(<span class="java&#45;keyword">new</span> SubmitButton(<span class="java&#45;quote">"changeSettings"</span>) &#123;
            <span class="java&#45;keyword">public</span> void onSubmit() &#123;
               // <span class="java&#45;keyword">do</span> something
               setResponsePage(backToPage);
            &#125;
        &#125;);
        add(form);
    &#125;
&#125;</pre></div><p class="paragraph"/>The <code>SettingsPage</code> expects the page which should be displayed after a successful submit to be passed to its constructor. This solution works, but is very bad practice. You need to know during the instanciation of <code>SettingsPage</code> where you want to redirect the user. This requires a predetermined order of instanciation. It is better to order the instanciation based on business logic (e.g. the order in the HTML template).¬†Furthermore, you need an unnecessary instance of the next success page which might never be displayed. The solution is once again the Hollywood principle. For this you create an abstract method or a hook:<p class="paragraph"/><strong class="bold">Listing 13:</strong><p class="paragraph"/><div class="code"><pre>// Good solution
<span class="java&#45;keyword">public</span> class SettingsPage <span class="java&#45;keyword">extends</span> Page &#123;
    <span class="java&#45;keyword">public</span> SettingsPage (IModel&#60;Settings&#62; settingsModel) &#123;
        Form&#60;?&#62; form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>);
        // add components
        form.add(<span class="java&#45;keyword">new</span> SubmitButton(<span class="java&#45;quote">"changeSettings"</span>) &#123;
            <span class="java&#45;keyword">public</span> void onSubmit() &#123;
               // <span class="java&#45;keyword">do</span> something
               onSettingsChanged();
            &#125;
         &#125;);
         add(form);
    &#125;<p class="paragraph"/>    // hook
    <span class="java&#45;keyword">protected</span> void onSettingsChanged() &#123;
    &#125;<p class="paragraph"/>// The usage of the <span class="java&#45;keyword">new</span> component
Link&#60;<span class="java&#45;object">Void</span>&#62; settings = <span class="java&#45;keyword">new</span> Link&#60;<span class="java&#45;object">Void</span>&#62;(<span class="java&#45;quote">"settings"</span>) &#123;
    <span class="java&#45;keyword">public</span> void onClick() &#123;
        setResponsePage(<span class="java&#45;keyword">new</span> SettingsPage(settingsModel) &#123;
            @Override
            <span class="java&#45;keyword">protected</span> void onSettingsChanged() &#123;
               // reference to the current page
               setResponsePage(<span class="java&#45;keyword">this</span>);
            &#125;
        &#125;);
    &#125;
&#125;
add(settings);</pre></div><p class="paragraph"/>This solution has more code, but it is more flexible and reuseable. We can see there is an event <code>onSettingsChanged()</code> and this event is called after a successful change. Furthermore, there is the possibility to execute additional code besides setting the next page. For example, you can display messages or persist information.


<h2 id="bestpractices_11">25.11 Use the Wicket session only for global data</h2>
<p class="paragraph"/>The Wicket session is your own extension of Wicket's base session. It is fully typed. There is no map structure to store information unlike the servlet session. You just should use Wicket's session for global data. Authentication is a good example for global data. The login and user information is required on nearly each page. For a blog application it would be good to know whether the user is an author who is allowed to compose blog entries. So you are able to hide or or show links to edit a blog entry. In general you should store the whole authorization logic in Wicket's session, because it is a global thing and you would expect it there. Data of forms and flows which only span certain pages should not stored in the session. This data can be passed from one page to the next via the constructor (see listing 14). As a consequence of this, the models and data have a clearly defined lifecycle that reflects the corresponding the page flow.<p class="paragraph"/><strong class="bold">Listing 14:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class MyPage <span class="java&#45;keyword">extends</span> WebPage &#123;
    IModel&#60;MyData&#62; myDataModel;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> MyPage(IModel&#60;MyData&#62; myDataModel) &#123;
        <span class="java&#45;keyword">this</span>.myDataModel = myDataModel;
        Link&#60;<span class="java&#45;object">Void</span>&#62; next = <span class="java&#45;keyword">new</span> Link&#60;<span class="java&#45;object">Void</span>&#62;(<span class="java&#45;quote">"next"</span>) &#123;
             <span class="java&#45;keyword">public</span> void onClick() &#123;
                  // <span class="java&#45;keyword">do</span> something
                  setResponsePage(<span class="java&#45;keyword">new</span> NextPage(myDataModel));
             &#125;
        &#125;
        add(next);
    &#125;
&#125;</pre></div><p class="paragraph"/>You should pass concrete information to the page. All models can simply be stored in fields because Wicket pages are user-specific instances and no singletons in contrast to Struts. The big advantage of this approach is that the data gets automatically cleaned up when a user completes or exits the page flow. No manual cleanup anymore! This is basically an automatic garbage collector for your session.


<h2 id="bestpractices_12">25.12 Do not use factories for components</h2>
<p class="paragraph"/>The factory pattern is useful, but nevertheless not suitable for Wicket components.<p class="paragraph"/><strong class="bold">Listing 15:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class CmsFactory &#123;
   <span class="java&#45;keyword">public</span> Label getCmsLabel(<span class="java&#45;object">String</span> markupId, <span class="java&#45;keyword">final</span> <span class="java&#45;object">String</span> url) &#123;
       IModel&#60;<span class="java&#45;object">String</span>&#62; fragment = <span class="java&#45;keyword">new</span> AbstractReadOnlyModel&#60;<span class="java&#45;object">String</span>&#62;() &#123;
          @Override
          <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getObject() &#123;
             <span class="java&#45;keyword">return</span> loadSomeContent(url);
          &#125;
       &#125;;
       Label result = <span class="java&#45;keyword">new</span> Label(markupId, fragment);
       result.setRenderBodyOnly(<span class="java&#45;keyword">true</span>);
       result.setEscapeModelStrings(<span class="java&#45;keyword">false</span>);
       <span class="java&#45;keyword">return</span> result;
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> loadContent(<span class="java&#45;object">String</span> url) &#123;
      // load some content
   &#125;
&#125;<p class="paragraph"/>// create the component within the page:
<span class="java&#45;keyword">public</span> class MyPage <span class="java&#45;keyword">extends</span> WebPage &#123;
   @SpringBean
   CmsFactory cmsFactory;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> MyPage() &#123;
      add(cmsFactory.getCmsLabel(<span class="java&#45;quote">"id"</span>, <span class="java&#45;quote">"http://url.to.load.from"</span>));
   &#125;
&#125;</pre></div><p class="paragraph"/>This approach for adding a label from the <code>CmsFactory</code> to a page seems to be okay at first glance, but it comes with some disadvantages. There is no possibility to use inheritance anymore. Furthermore, there is no possibility to override <code>isVisible()</code> and <code>isEnabled()</code>. The factory could also be a Spring service which instanciates the component. A better solution is to create a <code>CmsLabel</code>.<p class="paragraph"/><strong class="bold">Listing 16:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class CmsLabel <span class="java&#45;keyword">extends</span> Label &#123;
   @SpringBean
   CmsResource cmsResource;
   <span class="java&#45;keyword">public</span> CmsLabel(<span class="java&#45;object">String</span> id, IModel&#60;<span class="java&#45;object">String</span>&#62; urlModel) &#123;
      <span class="java&#45;keyword">super</span>(id, urlModel);
      IModel&#60;<span class="java&#45;object">String</span>&#62; fragment = <span class="java&#45;keyword">new</span> AbstractReadOnlyModel&#60;<span class="java&#45;object">String</span>&#62;()&#123;
         @Override
         <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getObject() &#123;
            <span class="java&#45;keyword">return</span> cmsResource.loadSomeContent(urlModel.getObject());
         &#125;
      &#125;;
      setRenderBodyOnly(<span class="java&#45;keyword">true</span>);
      setEscapeModelStrings(<span class="java&#45;keyword">false</span>);
   &#125;
&#125;<p class="paragraph"/>// create the component within a page
<span class="java&#45;keyword">public</span> class MyPage <span class="java&#45;keyword">extends</span> WebPage &#123;
   <span class="java&#45;keyword">public</span> MyPage() &#123;
      add(<span class="java&#45;keyword">new</span> CmsLabel(<span class="java&#45;quote">"id"</span>, Model.of(<span class="java&#45;quote">"http://url.to.load.from"</span>)));
   &#125;
&#125;</pre></div><p class="paragraph"/>The label in listing 16 is clearly encapsulated in a component without using a factory. Now you can easily create inline implementations and override <code>isVisible()</code> or other stuff. Naturally, you might claim "I need a factory to initialize some values in the component, e.g. a Spring service.". For this you can create a implementation of <code>IComponentInstantiationListener</code>. This listener gets called on the super-constructor of every component. The most popular implementation of this interface is the <code>SpringComponentInjector</code> which injects Spring beans in components when the fields are annotated with <code>&#64;SpringBean</code>. You can easliy write and add your own implementation of <code>IComponentInstantiationListener</code>. So there is no reason for using a factory anymore. More information about the instanciation listener is located in Wicket's JavaDoc.


<h2 id="bestpractices_13">25.13 Every page and component must be tested</h2>
<p class="paragraph"/>Every page and component should have a test. The simplest test just renders the component and validates its technical correctness. For example, a child component should have a matching wicket id in the markup. If the wicket id is not correctly bound - through a typo or if it was just forgotten - the test will fail. An advanced test could test a form, where a backend call gets executed and validated over a mock. So you can validate your component's behaviour. This is a simple way to detect and fix technical and business logic bugs during the build process. Wicket is very suitable for a test driven development approach. For instance, if you run a unit test which fails and shows a message that the wicket id not bound, you will avoid an unneccessary server startup (a server startup takes longer than running a unit test). This reduces the development turnaround. A disadvantage is the difficult testing possibility of AJAX components. However, the testing features of Wicket are much more sophisticated than in other web frameworks.


<h2 id="bestpractices_14">25.14 Avoid interactions with other servlet filters</h2>
<p class="paragraph"/>Try to get within the Wicket world whenever possible. Avoid the usage of other servlet filters. For this you can use the <code>RequestCycle</code> and override the methods <code>onBeginRequest()</code> and <code>onEndRequest()</code>. You can apply the same to the <code>HttpSession</code>. The equivalent in Wicket is the <code>WebSession</code>. Just extend the <code>WebSession</code> and override the <code>newSession()</code>-method from the Application class. There are very few reasons to access the servlet interfaces. An example could be to read an external cookie to authenticate a user. Those parts should be properly encapsulated and avoided when possible. For this example, you could do the handling within the Wicket session because this is an authentication.



<h2 id="bestpractices_15">25.15 Cut small classes and methods</h2>
<p class="paragraph"/>Avoid monolithic classes. Often I have seen that developers put the whole stuff into constructors. These classes are getting very unclear and chaotic because you use inline implementations over serveral levels. It is recommended to group logical units and extract methods with a correct business naming. This enhances the clarity and the understandability of the business aspect. When a developer navigates to a component, he is not interested in the technical aspect at first, however he just need the business aspect. To retrieve technical information of a component you can navigate to the method implementation. In case of doubt you should consider to extract seperate components. Smaller components increase the chances of reuse and make testing easier. Listing 17 shows an example of a possible structuring.<p class="paragraph"/><strong class="bold">Listing 17:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class BlogEditPage <span class="java&#45;keyword">extends</span> WebPage &#123;
    <span class="java&#45;keyword">private</span> IModel&#60;Blog&#62; blogModel;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> BlogEditPage(IModel&#60;Blog&#62; blogModel) &#123;
        <span class="java&#45;keyword">super</span>(<span class="java&#45;keyword">new</span> PageParameters());
        <span class="java&#45;keyword">this</span>.blogModel = blogModel;
        add(createBlogEditForm());
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">private</span> Form&#60;Blog&#62; createBlogEditForm() &#123;
        Form&#60;Blog&#62; form = newBlogEditForm();
        form.add(createHeadlineField());
        form.add(createContentField());
        form.add(createTagField());
        form.add(createViewRightPanel());
        form.add(createCommentRightPanel());
        form.setOutputMarkupId(<span class="java&#45;keyword">true</span>);
        <span class="java&#45;keyword">return</span> form;
    &#125;<p class="paragraph"/>    // more methods here
&#125;</pre></div>


<h2 id="bestpractices_16">25.16 The argument "Bad documentation"</h2>
<p class="paragraph"/>It is a widespread opinion that Wicket has a bad documentation. This argument is just partly correct. There are a lot of code samples and snippets which can be used as code templates. Furthermore, there is a big community that answers complex questions very quickly. In Wicket it is very hard to document everything, because nearly everything is extensible and replaceable. If a component is not completely suitable, you will extend or replace it. Working with Wicket means permanently navigating through code. For example, just consider validators. How can I find all navigators that exist? Open the interface <code>IValidator</code> (Eclipse: Ctrl + Shift + T) and then open the type hierachy (Crtl + T). Now we can see all the validators existing in Wicket and our project.<p class="paragraph"/><img border="0" class="center" src="../img/validator-type-hierachy.png"></img>


<h2 id="bestpractices_17">25.17 Summary</h2>
<p class="paragraph"/>The best practices presented in this chapter should help you to write better and more maintainable code in Wicket. All described methodologies were already proven in a few Wicket projects. If you follow these advices, your Wicket projects will get future-proof and hopefully successful.


<h1 id="internals">26 Wicket Internals</h1>



<h2 id="pagestoring">26.1 Page storing</h2>
During request handling, Wicket manages page instances through interface <code>org.apache.wicket.request.handler.IPageProvider</code>. This interface creates a new page instance or loads a previously serialized page instance if we provide the corrisponding page id. <code>IPageProvider</code> delegates page creation and retrieval to interface <code>org.apache.wicket.request.mapper.IPageSource</code>.
When page class is provided <code>IPageSource</code> delegates page creation to interface <code>org.apache.wicket.IPageFactory</code>, while when page id is provided it uses interface <code>org.apache.wicket.page.IPageManager</code> to load the previously serialized page.<p class="paragraph"/>The following workflow diagram summarizes the mechanism seen so far:<p class="paragraph"/><img border="0" class="center" src="../img/page-storage.png"></img><p class="paragraph"/><h3>IPageManager</h3><p class="paragraph"/><code>org.apache.wicket.page.IPageManager</code>'s task is to manage which pages have been used in a request and store their last state in the backing stores, namely <code>IPageStore</code>.
The default implementation <code>org.apache.wicket.page.PageStoreManager</code> collects all stateful pages which have been used in the request cycle (more than one page can be used in a single request if for example <code>setResponsePage()</code> or <code>RestartResponseException</code> is used).
At the end of the request all collected page instances are being stored in the first level cache - http session. They are stored in http session attribute named <code>"wicket:persistentPageManagerData-APPLICATION_NAME"</code> and passed to the underlying <code>IPageStore</code>.
When the next http request comes <code>IPageProvider</code> will ask for page with specific id and <code>PageStoreManager</code> will look first in the http session and if no match is found then it will delegate to the IPageStore. At the end of the second request the http session based cache is being overwritten completely with the newly used page instances.<p class="paragraph"/>To setup another <code>IPageManager</code> implementation use <code>org.apache.wicket.Application.setPageManagerProvider(IPageManagerProvider)</code>.
The custom <code>IPageManager</code> implementation may or may not use <code>IPageStore/IDataStore</code>.<p class="paragraph"/><h3>IPageStore</h3><p class="paragraph"/><code>org.apache.wicket.pageStore.IPageStore</code>'s role is to mediate the storing and loading of pages done by the underlying <code>IDataStore</code>. The default implementation <code>org.apache.wicket.pageStore.DefaultPageStore</code> pre-processes the pages before passing them to <code>IDataStore#storeData(String, int, byte)</code> and to post-processes them after <code>IDataStore#getData(String, int)</code>. The processing consists of transforming the page instance to <code>org.apache.wicket.pageStore.DefaultPageStore.SerializedPage</code>. This is a struct of:<p class="paragraph"/><div class="code"><pre>&#123;
   sessionId: <span class="java&#45;object">String</span>,
   pageId : <span class="java&#45;object">int</span>,
   data : <span class="java&#45;object">byte</span>&#91;&#93;
&#125;</pre></div><p class="paragraph"/>i.e. this is the serialized page instance (data) plus additional information needed to be able to easily find it later (sessionId, pageId).<p class="paragraph"/>When a <code>SerializedPage</code> has to be stored <code>DefaultPageStore</code> stores it in a application scoped cache ({sessionId, pageId} -&#62; SerializedPage) and additionally gives it to the underlying <code>IDataStore#storeData(sessionId, pageId, data)</code>. The application scoped cache is used as second level cache. Getting a page from it is slower than the http session based cache in <code>PageStoreManager</code> because the page has to be deserialized, but is faster than the underlying <code>IDataStore</code> which stores the page bytes in some persistent store.<p class="paragraph"/>The size of the application scoped cache is configurable via <code>org.apache.wicket.settings.StoreSettings.setInmemoryCacheSize(int)</code>.<p class="paragraph"/><h3>IDataStore</h3><p class="paragraph"/><code>org.apache.wicket.pageStore.IDataStore</code> is used to persist Wicket pages (as bytes) to a persistent store like e.g. files or databases. The default implementation is <code>org.apache.wicket.pageStore.DiskDataStore</code> which as its name says stores the pages in files. The location of the folder where the files are stored is configurable via <code>org.apache.wicket.settings.StoreSettings.setFileStoreFolder(File)</code>, by default the web container's work folder is used (ServletContext attribute 'javax.servlet.context.tempdir'). In this folder a sub-folder is created named <code>'applicationName-filestore'</code>. 
This folder contains a sub-folder for each active http session. This session folder contains a single file named 'data' which contains the bytes for the pages. The size of this 'data' file is configurable via <code>org.apache.wicket.settings.StoreSettings.setMaxSizePerSession(Bytes)</code>. When this size is exceeded the newly stored files overwrite the oldest ones.<p class="paragraph"/><h3>AsynchronousDataStore</h3><p class="paragraph"/>By default Wicket wraps <code>DiskDataStore</code> with <code>org.apache.wicket.pageStore.AsynchronousDataStore</code>. The role of <code>AsynchronousDataStore</code> is to detach the http worker thread from waiting for the write of the page bytes to the disk.
To disable it use: <code>org.apache.wicket.settings.StoreSettings.setAsynchronous(false)</code>. AsynchronousDataStore can delay the storage of pages' bytes for at most <code>org.apache.wicket.settings.StoreSettings.setAsynchronousQueueCapacity(int)</code> pages. If this capacity is exceeded then the page's bytes are written synchronously to the backing <code>IDataStore</code>.<p class="paragraph"/><h3>DebugDiskDataStore</h3><p class="paragraph"/>Wicket provides an extension of <code>DiskDataStore</code> that can be used to browse the content of the 'data' files created by <code>DiskDataStore</code>. This extension can be found in wicket-devutils.jar and needs to be enabled in the <code>init</code>-method of your application via 
<div class="code"><pre>DebugDiskDataStore.register(<span class="java&#45;keyword">this</span>);</pre></div>
The debug information can be seen at http://host:port/context/wicket/internal/debug/diskDataStore<p class="paragraph"/><h3>HttpSessionDataStore</h3><p class="paragraph"/>In some environments like Google AppEngine it is not allowed to write to the file system and thus <code>DiskDataStore</code> cannot be used. In this case <code>org.apache.wicket.pageStore.memory.HttpSessionDataStore</code> can be used as replacement. This implementation of <code>IDataStore</code> is not persistent and puts all the data in the http session.
Wicket comes with 2 default eviction strategies to keep the size of the http session reasonable:
<ul class="star">
<li><strong class="bold">org.apache.wicket.pageStore.memory.PageNumberEvictionStrategy</strong> - specifies how many pages can be hold</li>
<li><strong class="bold">org.apache.wicket.pageStore.memory.MemorySizeEvictionStrategy</strong> - specifies the maximum amount of memory for pages per http session.</li>
</ul><p class="paragraph"/>To configure it:
<div class="code"><pre>MyApp&#35;init()
&#123;
   <span class="java&#45;keyword">super</span>.init();<p class="paragraph"/>   setPageManagerProvider(<span class="java&#45;keyword">new</span> DefaultPageManagerProvider()
   &#123;
       <span class="java&#45;keyword">protected</span> IDataStore newDataStore()
       &#123;
           <span class="java&#45;keyword">return</span>  <span class="java&#45;keyword">new</span> HttpSessionDataStore(pageManagerContext, <span class="java&#45;keyword">new</span> PageNumberEvictionStrategy(20));
       &#125;
   &#125;
&#125;</pre></div><p class="paragraph"/><h3>DebugBar</h3><p class="paragraph"/>Further insights which can be valueable during debugging can be retrieved using the <code>org.apache.wicket.devutils.debugbar.DebugBar</code> from wicket-devutils.jar. It's a panel which you simply add:<p class="paragraph"/>Java: 
<div class="code"><pre>add(<span class="java&#45;keyword">new</span> DebugBar(<span class="java&#45;quote">"debug"</span>));</pre></div><p class="paragraph"/>HTML:
<div class="code"><pre>&#60;span wicket:id=<span class="java&#45;quote">"debug"</span>/&#62;</pre></div>



<h2 id="autocomponents">26.2 Markup parsing and Autocomponents</h2>
<h3>Markup loading and parsing</h3><p class="paragraph"/>Before rendering any component Wicket must retrieve its markup calling method <code>getMarkup()</code> of class <code>org.apache.wicket.Component</code>. This markup is an instance of interface <code>org.apache.wicket.markup.IMarkupFragment</code>. Markup is lazy loaded the first time we render the relative component and is cached at application level. The internal class that actually loads the markup is <code>org.apache.wicket.markup.MarkupFactory</code> and is part of application's markup settings:<p class="paragraph"/><div class="code"><pre>//get current markup factory
	Application.get().getMarkupSettings().getMarkupFactory()</pre></div><p class="paragraph"/>After the markup has been loaded by <code>MarkupFactory</code>, it's parsed with class <code>org.apache.wicket.markup.MarkupParser</code>. <code>MarkupFactory</code> creates a new <code>MarkupParser</code> with method <code>newMarkupParser(MarkupResourceStream resource)</code>. The effective markup parsing is performed with a chain of entities implementing interface <code>org.apache.wicket.markup.parser.IMarkupFilter</code>. The default set of <code>IMarkupFilters</code>S used by <code>MarkupParser</code> takes care of different tasks such as HTML validation, comments removing, Wicket tags handling, etc...<p class="paragraph"/>To customize the set of <code>IMarkupFilters</code>S used in our application we can create a subclass of <code>MarkupFactory</code> overriding method <code>newMarkupParser(MarkupResourceStream resource)</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> MyMarkupFactory 
&#123;
&#8230;
  <span class="java&#45;keyword">public</span> MarkupParser newMarkupParser(<span class="java&#45;keyword">final</span> MarkupResourceStream resource) 
  &#123;
       MarkupParser parser = <span class="java&#45;keyword">super</span>.newMarkupParser(resource);
       parser.add(<span class="java&#45;keyword">new</span> MyFilter());
       <span class="java&#45;keyword">return</span> parser;
  &#125;
&#125;</pre></div><p class="paragraph"/>This custom class must be registered in the markup settings during application's initialization:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getMarkupSettings().setMarkupFactory(myMarkupFactory)
&#125;</pre></div><p class="paragraph"/>Usually we won't need to change the default configuration of <code>IMarkupFilters</code>S, but it's important to be aware of this internal mechanism before we talk about another advanced feature, which is building auto components resolvers.<p class="paragraph"/><h3>Auto components resolvers</h3><p class="paragraph"/>Even if Wicket encourages developers to use just standard HTML in their markup code, in this guide we have seen a number of "special" tags (those starting with <code>wicket:</code>) that help us for specific tasks (e.g. <code>wicket:enclosure</code> tag). Wicket handles most of these tags creating a corresponding special component called  <em class="italic">auto</em>  component. This kind of components are resolved in two steps:
<ol>
<li>first their tag is identified by a <code>IMarkupFilters</code> which also takes care of assigning a unique tag id.</li>
<li>then during rendering phase when an auto-component is found a new component is created for it using one of the registered <code>org.apache.wicket.markup.resolver.IComponentResolver</code>:</li>
</ol><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">interface</span> IComponentResolver <span class="java&#45;keyword">extends</span> IClusterable
&#123;
	/&#42;&#42;
	 &#42; Try to resolve a component.
	 &#42; 
	 &#42; @param container
	 &#42;            The container parsing its markup
	 &#42; @param markupStream
	 &#42;            The current markupStream
	 &#42; @param tag
	 &#42;            The current component tag <span class="java&#45;keyword">while</span> parsing the markup
	 &#42; <code><span class="java&#45;keyword">return</span> component or &#123;</code>code <span class="java&#45;keyword">null</span>&#125; <span class="java&#45;keyword">if</span> not found
	 &#42;/
	<span class="java&#45;keyword">public</span> Component resolve(<span class="java&#45;keyword">final</span> MarkupContainer container, <span class="java&#45;keyword">final</span> MarkupStream markupStream,
		<span class="java&#45;keyword">final</span> ComponentTag tag);
&#125;</pre></div><p class="paragraph"/>Registered <code>IComponentResolver</code>s can be retrieved through Application's settings:<p class="paragraph"/><div class="code"><pre>Application.get()
	.getPageSettings()
	.getComponentResolvers()</pre></div><p class="paragraph"/><blockquote class="note">
An internal utility class named <code>org.apache.wicket.markup.resolver.ComponentResolvers</code> is also available to resolve autocomponents for the current markup tag.
</blockquote>



<h1 id="monitoring">27 Wicket Metrics Monitoring (Experimental)</h1>
The wicket-metrics module is available since Wicket 7.3.0 and contains a life measurement implementation to collect data of applications and visualize it.<p class="paragraph"/>You can see how many request your application served, how often components are created, initalized, configured or their detach method has been invoked and a lot of other additional information.<p class="paragraph"/>The module itself is using <a href="https://dropwizard.github.io/metrics/3.1.0/" target="blank">Metrics of dropwizard</a> and <a href="https://eclipse.org/aspectj/" target="blank">AspectJ</a> so that if you turn of the measurement it has no longer any effect<p class="paragraph"/>to your web application.<p class="paragraph"/>Keep in mind that AspectJ is licensed under the Eclipse Public License and you should provide the required license information.


<h2 id="monitoring_1">27.1 Example setup</h2>
This is a little example how to setup wicket-metrics within a Apache Tomcat.<p class="paragraph"/>(1)  Add the maven dependency to your project
<div class="code"><pre>&#60;dependency&#62;
	&#60;groupId&#62;org.apache.wicket.experimental.wicket7&#60;/groupId&#62;
	&#60;artifactId&#62;wicket&#45;metrics&#60;/artifactId&#62;
	&#60;version&#62;0.X&#45;SNAPSHOT&#60;/version&#62;
&#60;/dependency&#62;</pre></div><p class="paragraph"/>(2) Just drop the jars of aspectjrt and aspectjweaver into the tomcat lib folder - you can download it from here <a href="http://mvnrepository.com/artifact/org.aspectj/" target="blank">http://mvnrepository.com/artifact/org.aspectj/</a> (the metrics dependency is shipped with the project)<p class="paragraph"/>(3) Add the java agent to the jvm start options of your tomcat: -javaagent:/pathToServer/lib/aspectjweaver-x.x.x.jar<p class="paragraph"/>(4) Add an aop.xml to your project's META-INF folder at the root of your classpath with the metrics you want to use (aspect tags) - if you don't want to enable a metrics just remove the aspect tag:
<div class="code"><pre>&#60;!DOCTYPE aspectj PUBLIC <span class="java&#45;quote">"&#45;//AspectJ//DTD//EN"</span> <span class="java&#45;quote">"http://www.eclipse.org/aspectj/dtd/aspectj.dtd"</span>&#62;
&#60;aspectj&#62;
    &#60;weaver options=<span class="java&#45;quote">"&#45;nowarn"</span>&#62;
        &#60;include within=<span class="java&#45;quote">"org.apache.wicket..&#42;"</span>/&#62;
    &#60;/weaver&#62;
    &#60;aspects&#62;
		&#60;!&#45;&#45; required &#45;&#45;&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.WicketFilterInitAspect"</span> /&#62;<p class="paragraph"/>		&#60;!&#45;&#45; optional &#45;&#45;&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.model.LoadableDetachableModelLoadAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.requesthandler.IRequestHandlerDetachAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.requesthandler.IRequestHandlerRespondAspect"</span> /&#62;
 		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.resource.IResourceCreateAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.behavior.BehaviorCreateAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.component.ComponentCreateAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.component.ComponentOnConfigureAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.component.ComponentOnDetachAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.component.ComponentOnInitializeAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.component.ComponentOnRenderAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.component.ComponentSetResponsePageAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.ajax.IPartialPageRequestHandlerAddAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.ajax.IPartialPageRequestHandlerAppendJavaScriptAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.ajax.IPartialPageRequestHandlerPrependJavaScriptAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.resource.ResourceReferenceCreateAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.markup.WicketTagCreateAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.request.WicketFilterRequestCycleUrlAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.request.WicketFilterRequestCycleAspect"</span> /&#62;
		&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.session.SessionCountListenerAspect"</span> /&#62;
    &#60;/aspects&#62;
&#60;/aspectj&#62;</pre></div>
<ul class="star">
<li>If you use the SessionCountListenerAspect you have to ensure that metadata-complete="false" is set otherwise you have to add the listener yourself:</li>
</ul><p class="paragraph"/><div class="code"><pre>&#60;listener&#62;
	&#60;listener&#45;class&#62;
	   org.apache.wicket.metrics.aspects.session.SessionCountListener
	&#60;/listener&#45;class&#62;
&#60;/listener&#62;</pre></div><p class="paragraph"/>(5 - optional) To enable the JMX measurement write the following line into your init method of your Application (Now you are able to connect with jvisualvm to your server and have a look at the data):
<div class="code"><pre>WicketMetrics.getSettings().startJmxReporter();</pre></div><p class="paragraph"/>To deactivate:
<div class="code"><pre>WicketMetrics.getSettings().stopJmxReporter();</pre></div><p class="paragraph"/>To disable measurement:
<div class="code"><pre>WicketMetrics.getSettings().setEnabled(<span class="java&#45;keyword">false</span>);</pre></div><p class="paragraph"/><strong class="bold">IMPORTANT INFORMATION</strong>
<ul class="star">
<ul class="star">
<li>It is only possible to collect metrics for <strong class="bold">one wicket filter per webapp</strong> - don't declare more then one if you want to use wicket-metrics</li>
<li>The WicketFilterInitAspect is required so that the application can be resolved - otherwise runtime exceptions will be thrown</li>
<li>If you use the SessionCountListener you have to clear the session store if you restart the server - otherwise physically stored session will corrupt the data, because the count is initialized with 0.</li>
<li>If you have set wicket-metrics as dependency you can open "wicket-metrics.template.xml" to get a full template of the "aop.xml"</li>
<li>For the weaver options refer to the AspectJ LTW configuration documentation: https://eclipse.org/aspectj/doc/next/devguide/ltw-configuration.html</li>
</ul></ul><p class="paragraph"/>


<h2 id="monitoring_2">27.2 Visualization with Graphite</h2>
To visualize the metrics with Graphite a little additional configuration is required:<p class="paragraph"/>(1) Add the additional maven dependency to your project:
<div class="code"><pre>&#60;dependency&#62;
	&#60;groupId&#62;io.dropwizard.metrics&#60;/groupId&#62;
	&#60;artifactId&#62;metrics&#45;graphite&#60;/artifactId&#62;
	&#60;version&#62;$&#123;metrics.graphite.version&#125;&#60;/version&#62;
&#60;/dependency&#62;</pre></div>
<ul class="star">
<li>the metrics.graphite.version should be the same as the metrics version of the wicket-metrics dependency. Check the Maven dependencies to ensure</li>
</ul><p class="paragraph"/>this.<p class="paragraph"/>(2) Add the following code to your Application's init method:
<div class="code"><pre><span class="java&#45;keyword">private</span> GraphiteReporter reporter;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> void init()
	&#123;
		MetricRegistry metricRegistry = WicketMetrics.getMetricRegistry();
		<span class="java&#45;keyword">final</span> Graphite graphite = <span class="java&#45;keyword">new</span> Graphite(<span class="java&#45;keyword">new</span> InetSocketAddress(<span class="java&#45;quote">"127.0.0.1"</span>, 2003));
		reporter = GraphiteReporter.forRegistry(metricRegistry).prefixedWith(<span class="java&#45;quote">"WebApplications"</span>)
			.convertRatesTo(TimeUnit.SECONDS).convertDurationsTo(TimeUnit.MILLISECONDS)
			.filter(MetricFilter.ALL).build(graphite);<p class="paragraph"/>		// Collects data every 5 seconds
		reporter.start(5, TimeUnit.SECONDS);
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> void onDestroy()
	&#123;
		<span class="java&#45;keyword">super</span>.onDestroy();
		reporter.stop();
	&#125;</pre></div><p class="paragraph"/>(3) Install and setup graphite on your system. Example installation for Mac (beware that this is only a quickstart setup!):
<ul class="minus">
<li>(1) Install homebrew: <a href="http://brew.sh/" target="blank">brew</a></li>
<li>(2) Install <a href="https://git-scm.com/" target="blank">Git</a></li>
<li>(3) brew install python</li>
<li>(4) brew install cairo</li>
<li>(5) brew install py2cairo</li>
<li>(6) pip install Django==1.5</li>
<li>(7) pip install "django-tagging&#60;0.4"</li>
<li>(8) sudo pip install carbon</li>
<li>(9) pip install whisper</li>
<li>(10) sudo pip install graphite-web</li>
<li>(11) sudo pip install Twisted==11.1.0</li>
<li>(12) sudo chown -R &#60;your username&#62;:staff /opt/graphite</li>
<li>(13) cp /opt/graphite/conf/carbon.conf{.example,}</li>
<li>(14) cp /opt/graphite/conf/storage-schemas.conf{.example,}</li>
<li>(15) cd /opt/graphite/webapp/graphite</li>
<li>(16) cp local_settings.py{.example,}</li>
<li>(17) python manage.py syncdb</li>
<li>(18) python /opt/graphite/bin/carbon-cache.py start</li>
<li>(19) python /opt/graphite/bin/run-graphite-devel-server.py /opt/graphite</li>
<li>(20) Go to http://localhost:8080</li>
</ul>
<ul class="star">
<li>(18) and (19) have to be executed if the mac has been restarted</li>
</ul><p class="paragraph"/>(4) Now start your tomcat server configured like mentioned in the previous chapter.<p class="paragraph"/><img border="0" class="center" src="../img/wicket_metrics_graphite.png"></img>



<h2 id="monitoring_3">27.3 Measured data</h2>
The data which is going to be measured depends on the wicket-metrics implementation. So it doesn't make any sense to collect time data<p class="paragraph"/>about setResponsePage, but it does for the constructor of components, to see if a component needs a long time to be created. You can<p class="paragraph"/>get the information about which data has been collected from out of the mbeans.<p class="paragraph"/>Here are some information about them:
<ul class="star">
<li>max - the maximal time for a task (created, initialized, etc.)</li>
<li>min - the minimal time for a task (created, initialized, etc.)</li>
<li>count - how often something happened (request count)</li>
</ul><p class="paragraph"/>The structure is separated in the way that under core there are the kind of components measured and below that the type of operation<p class="paragraph"/>(created, initialized, detached). In this category every component is listed dynamically.<p class="paragraph"/>


<h2 id="monitoring_4">27.4 Write own measurements</h2>
There are only a two steps required to write own measurements for life data statistics in Wicket:<p class="paragraph"/>(1) Write a class which is named very close to what it measures. This class should extends WicketMetrics and should annotated with @Aspect and provide one method with a join point scanning for the target signature.
<div class="code"><pre>@Aspect
	<span class="java&#45;keyword">public</span> class MySpecialAspect <span class="java&#45;keyword">extends</span> WicketMetrics
	&#123;
		@Around(<span class="java&#45;quote">"execution(&#42; my.<span class="java&#45;keyword">package</span>.MyClass.myMethod(..))"</span>)
		<span class="java&#45;keyword">public</span> <span class="java&#45;object">Object</span> aroundRequestProcessed(ProceedingJoinPoint joinPoint) <span class="java&#45;keyword">throws</span> Throwable
		&#123;
			<span class="java&#45;keyword">return</span> measureTime(<span class="java&#45;quote">"mycategory/someinformation/"</span>, joinPoint);
		&#125;
	&#125;</pre></div>
<ul class="star">
<li>To measure time you need @Around because measureTime of WicketMetrics requires the joinPoint - the class name is appended with a slash at the end</li>
<li>To only mark that a method is called you can use mark of WicketMetrics and apply null as a second parameter - if you apply a join point to mark the class name is appended with a slash at the end</li>
</ul><p class="paragraph"/>(2) Add the class to your aop.xml and of course the package to scan for classes that are target for your measurements:
<div class="code"><pre>&#60;!DOCTYPE aspectj PUBLIC <span class="java&#45;quote">"&#45;//AspectJ//DTD//EN"</span> <span class="java&#45;quote">"http://www.eclipse.org/aspectj/dtd/aspectj.dtd"</span>&#62;
&#60;aspectj&#62;
    &#60;weaver options=<span class="java&#45;quote">"&#45;nowarn"</span>&#62;
    	&#60;include within=<span class="java&#45;quote">"org.apache.wicket..&#42;"</span>/&#62;
        &#60;include within=<span class="java&#45;quote">"my.components.<span class="java&#45;keyword">package</span>..&#42;"</span>/&#62;
    &#60;/weaver&#62;
    &#60;aspects&#62;
    	&#60;!&#45;&#45; required &#45;&#45;&#62;
    	&#60;aspect name=<span class="java&#45;quote">"org.apache.wicket.metrics.aspects.WicketFilterInitAspect"</span> /&#62;<p class="paragraph"/>    	&#60;!&#45;&#45; own aspects &#45;&#45;&#62;
    	&#60;aspect name=<span class="java&#45;quote">"my.aspect.<span class="java&#45;keyword">package</span>.MySpecialAspect"</span> /&#62;<p class="paragraph"/>    	&#60;!&#45;&#45; wickets own metrics &#45;&#45;&#62;
    	.....
    &#60;/aspects&#62;
&#60;/aspectj&#62;</pre></div>



<h1 id="maven">28 Working with Maven (Appendix)</h1>




<h2 id="maven_1">28.1 Switching Wicket to DEPLOYMENT mode</h2>
<p class="paragraph"/>As pointed out in the note in <a href="../guide/single.html#helloWorld_2" class="guide">paragraph 4.2</a>, Wicket can be started in two modes, DEVELOPMENT and DEPLOYMENT. When we are in DEVELOPMENT mode Wicket warns us at application startup with the following message:<p class="paragraph"/><div class="code"><pre>&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
&#42;&#42;&#42; WARNING: Wicket is running in DEVELOPMENT mode.              &#42;&#42;&#42;
&#42;&#42;&#42;                               ^^^^^^^^^^^                    &#42;&#42;&#42;
&#42;&#42;&#42; Do NOT deploy to your live server(s) without changing <span class="java&#45;keyword">this</span>.  &#42;&#42;&#42;
&#42;&#42;&#42; See Application&#35;getConfigurationType() <span class="java&#45;keyword">for</span> more information. &#42;&#42;&#42;
&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;</pre></div><p class="paragraph"/>As we can read Wicket itself discourages us from using DEVELOPMENT mode into production environment. The running mode of our application can be configured in four different ways. The first one is adding a filter parameter inside deployment descriptor web.xml:<p class="paragraph"/><div class="code"><pre>&#60;filter&#62;      
	&#60;filter&#45;name&#62;wicket.MyApp&#60;/filter&#45;name&#62;
	&#60;filter&#45;class&#62;org.apache.wicket.protocol.http.WicketFilter&#60;/filter&#45;class&#62;
	&#60;init&#45;param&#62;
		&#60;param&#45;name&#62;applicationClassName&#60;/param&#45;name&#62;
		&#60;param&#45;value&#62;org.wicketTutorial.WicketApplication&#60;/param&#45;value&#62;
	&#60;/init&#45;param&#62;
	&#60;init&#45;param&#62;
            &#60;param&#45;name&#62;configuration&#60;/param&#45;name&#62;
            &#60;param&#45;value&#62;deployment&#60;/param&#45;value&#62;
	&#60;/init&#45;param&#62;
&#60;/filter&#62;</pre></div><p class="paragraph"/>The additional parameter is written in bold. The same parameter can be also expressed as context parameter:<p class="paragraph"/><div class="code"><pre>&#60;context&#45;param&#62;
    &#60;param&#45;name&#62;configuration&#60;/param&#45;name&#62;
    &#60;param&#45;value&#62;deployment&#60;/param&#45;value&#62;
&#60;/context&#45;param&#62;</pre></div><p class="paragraph"/>The third way to set the running mode is using system property wicket.configuration. This parameter can be specified in the command line that starts up the server:<p class="paragraph"/><div class="code"><pre>java &#45;Dwicket.configuration=deployment ...</pre></div><p class="paragraph"/>The last option is to set it in your Java code (e.g. in the init-method of your WebApplication):<p class="paragraph"/><div class="code"><pre>setConfigurationType(RuntimeConfigurationType.DEPLOYMENT);</pre></div><p class="paragraph"/>Remember that system properties overwrite other settings, so they are ideal to ensure that on production machine the running mode will be always set to DEPLOYMENT. 



<h2 id="maven_2">28.2 Creating a Wicket project from scratch and importing it into our favourite IDE</h2>
<p class="paragraph"/><blockquote class="note">
In order to follow the instructions of this paragraph you must have Maven installed on your system. The installation of Maven is out of the scope of this guide but you can easily find an extensive documentation about it on Internet.
Another requirement is a good Internet connection (a flat ADSL is enough) because Maven needs to connect to its central repository to download the required dependencies. 
</blockquote><p class="paragraph"/>
<h3>From Maven to our IDE</h3><p class="paragraph"/>Wicket project and its dependencies are managed using Maven. This tool is very useful also when we want to create a new project based on Wicket from scratch. With a couple of shell commands we can generate a new project properly configured and ready to be imported into our favourite IDE.
The main step to create such a project is to run the command which generates project's structure and its artifacts. If we are not familiar with Maven or we simply don't want to type this command by hand, we can use the utility form on Wicket site at <a href="http://wicket.apache.org/start/quickstart.html" target="blank">http://wicket.apache.org/start/quickstart.html</a> :<p class="paragraph"/><img border="0" class="center" src="../img/quickstart-webpage.png"></img><p class="paragraph"/>Here we have to specify the root package of our project (GroupId), the project name (ArtifactId) and which version of Wicket we want to use (Version).
Once we have run the resulting command in the OS shell, we will have a new folder with the same name of the project (i.e the ArtifactId). Inside this folder we can find a file called pom.xml. This is the main file used by Maven to manage our project. For example, using ‚Äúorg.wicketTutorial‚Äù as GroupId and ‚ÄúMyProject‚Äù as ArtifactId, we would obtain the following artifacts:<p class="paragraph"/><div class="code"><pre>.&#77;yProject
        |   pom.xml
        |
        &#45;&#45;&#45;src
            +&#45;&#45;&#45;main
            |   +&#45;&#45;&#45;java
            |   |   &#45;&#45;&#45;org
            |   |       &#45;&#45;&#45;wicketTutorial
            |   |               HomePage.html
            |   |               HomePage.java
            |   |               WicketApplication.java
            |   |
            |   +&#45;&#45;&#45;resources
            |   |       log4j.properties
            |   |
            |   &#45;&#45;&#45;webapp
            |       &#45;&#45;&#45;WEB&#45;INF
            |               web.xml
            |
            &#45;&#45;&#45;test
                &#45;&#45;&#45;java
                    &#45;&#45;&#45;org
                        &#45;&#45;&#45;wicketTutorial
                                TestHomePage.java</pre></div><p class="paragraph"/>Amongst other things, file pom.xml contains a section delimited by tag &#60;dependencies&#62; which declares the dependencies of our project. By default the Maven archetype will add the following Wicket modules as dependencies:<p class="paragraph"/><div class="code"><pre>&#8230;
<span class="xml&#45;tag">&#60;dependencies&#62;</span>
	<span class="xml&#45;comment">&#60;!&#45;&#45;  WICKET DEPENDENCIES &#45;&#45;&#62;
	<span class="xml&#45;tag">&#60;dependency&#62;</span>
		<span class="xml&#45;tag">&#60;groupId&#62;</span>org.apache.wicket<span class="xml&#45;tag">&#60;/groupId&#62;</span>
		<span class="xml&#45;tag">&#60;artifactId&#62;</span>wicket&#45;core<span class="xml&#45;tag">&#60;/artifactId&#62;</span>
		<span class="xml&#45;tag">&#60;version&#62;</span>$&#123;wicket.version&#125;<span class="xml&#45;tag">&#60;/version&#62;</span>
	<span class="xml&#45;tag">&#60;/dependency&#62;</span>
	<span class="xml&#45;tag">&#60;dependency&#62;</span>
		<span class="xml&#45;tag">&#60;groupId&#62;</span>org.apache.wicket<span class="xml&#45;tag">&#60;/groupId&#62;</span>
		<span class="xml&#45;tag">&#60;artifactId&#62;</span>wicket&#45;ioc<span class="xml&#45;tag">&#60;/artifactId&#62;</span>
		<span class="xml&#45;tag">&#60;version&#62;</span>$&#123;wicket.version&#125;<span class="xml&#45;tag">&#60;/version&#62;</span>
	<span class="xml&#45;tag">&#60;/dependency&#62;</span>
	&#60;!&#45;&#45; OPTIONAL DEPENDENCY
	<span class="xml&#45;tag">&#60;dependency&#62;</span>
		<span class="xml&#45;tag">&#60;groupId&#62;</span>org.apache.wicket<span class="xml&#45;tag">&#60;/groupId&#62;</span>
		<span class="xml&#45;tag">&#60;artifactId&#62;</span>wicket&#45;extensions<span class="xml&#45;tag">&#60;/artifactId&#62;</span>
		<span class="xml&#45;tag">&#60;version&#62;</span>$&#123;wicket.version&#125;<span class="xml&#45;tag">&#60;/version&#62;</span>
	<span class="xml&#45;tag">&#60;/dependency&#62;</span>
	&#45;&#45;&#62;</span> 
	&#8230;
<span class="xml&#45;tag">&#60;/dependencies&#62;</span>
...</pre></div><p class="paragraph"/>If we need to use more Wicket modules or additional libraries, we can add the appropriate XML fragments here.<p class="paragraph"/><h3>Importing a Maven project into our IDE</h3><p class="paragraph"/>Maven projects can be easily imported into the most popular Java IDEs. However, the procedure needed to do this differs from IDE to IDE. In this paragraph we can find the instructions to import Maven projects into three of the most popular IDEs among Java developers : NetBeans, JetBrains IDEA and Eclipse.<p class="paragraph"/><strong class="bold">NetBeans</strong>
Starting from version 6.7, NetBeans includes Maven support, hence we can start it and directly open the folder containing our project:<p class="paragraph"/><img border="0" class="center" src="../img/netbeans-maven-import.png"></img><p class="paragraph"/><strong class="bold">Intellj IDEA</strong>
Intellj IDEA comes with a Maven importing functionality that can be started under ‚ÄúFile/New Project/Import from external model/Maven‚Äù. Then, we just have to select the pom.xml file of our project:<p class="paragraph"/><img border="0" class="center" src="../img/intellj-maven-import.png"></img><p class="paragraph"/><strong class="bold">Eclipse</strong>
If our IDE is Eclipse the import procedure is a little more complex. Before opening the new project we must generate the Eclipse project artifacts running the following command from project root:<p class="paragraph"/><div class="code"><pre>mvn eclipse:eclipse</pre></div><p class="paragraph"/>  Now to import our project into Eclipse we must create a classpath variable called M2_REPO that must point to your local Maven repository. This can be done selecting ‚ÄúWindow/Preferences‚Äù and searching for ‚ÄúClasspath Variables‚Äù. The folder containing our local Maven repository is usually under our user folder and is called .m2 (for example under Unix system is /home/&#60;myUserName&#62;/.m2/repository):<p class="paragraph"/><img border="0" class="center" src="../img/eclipse-classpath-variables.png"></img><p class="paragraph"/>Once we have created the classpath variable we can go to ‚ÄúFile/Import.../Existing Project into Workspace‚Äù, select the directory of the project and press ‚ÄúFinish‚Äù:<p class="paragraph"/><img border="0" class="center" src="../img/eclipse-maven-import.png"></img><p class="paragraph"/>Once the project has been imported into Eclipse, we are free to use our favourite plug-ins to run it or debug it (like for example "run-jetty-run": http://code.google.com/p/run-jetty-run/ ).<p class="paragraph"/><blockquote class="note">
Please note the option ‚ÄúCopy projects into workspace‚Äù in the previous illustration. If we select it, the original project generated with Maven won't be affected by the changes made inside Eclipse because we will work on a copy of it under the current workspace.
</blockquote><p class="paragraph"/><blockquote class="note">
If we modify the pom.xml file (for example adding further dependencies) we must regenerate project's artifacts and refresh the project (F5 key) to reflect changes into Eclipse.
</blockquote><p class="paragraph"/><h3>Speeding up development with plugins.</h3><p class="paragraph"/>Now that we have our project loaded into our IDE we could start coding our components directly by hand. However it would be a shame to not leverage the free and good Wicket plugins available for our IDE. The following is a brief overview of the most widely used plugins for each of the three main IDEs considered so far.<p class="paragraph"/><strong class="bold">NetBeans</strong>
NetBeans offers Wicket support through 'NetBeans Plugin for Wicket' hosted at <a href="http://plugins.netbeans.org/plugin/3586/wicket-1-4-support" target="blank">http://plugins.netbeans.org/plugin/3586/wicket-1-4-support</a> . This plugin is released under CDDL-1.0 license. 
You can  find a nice introduction guide to this plugin at <a href="http://netbeans.org/kb/docs/web/quickstart-webapps-wicket.html" target="blank">http://netbeans.org/kb/docs/web/quickstart-webapps-wicket.html</a> .<p class="paragraph"/><strong class="bold">Intellj IDEA</strong>
For JetBrain IDEA we can use WicketForge plugin, hosted at Google Code <a href="http://code.google.com/p/wicketforge/" target="blank">http://code.google.com/p/wicketforge/</a> . The plugin is released under ASF 2.0 license.<p class="paragraph"/><strong class="bold">Eclipse</strong>
With Eclipse we can install one of the plugins that supports Wicket. As of the writing of this document, the most popular is probably Qwickie, available in the Eclipse Marketplace and hosted on Google Code at <a href="http://code.google.com/p/qwickie/" target="blank">http://code.google.com/p/qwickie/</a> .
QWickie is released under ASF 2.0 license.



<h1 id="wicketstuff">29 Project WicketStuff (Appendix)</h1>



<h2 id="wicketstuff_1">29.1 What is project WicketStuff</h2>
<p class="paragraph"/>WicketStuff is an umbrella project that gathers different Wicket-related projects developed and maintained by the community. The project is hosted on GitHub at <a href="https://github.com/wicketstuff/core" target="blank">https://github.com/wicketstuff/core</a> . 
Every module is structured as a parent Maven project containing the actual project that implements the new functionality and an example project that illustrates how to use it in our code. The resulting directory structure of each module is the following:<p class="paragraph"/><div class="code"><pre>&#60;module name&#62;&#45;parent
        |
        +&#45;&#45;&#45;&#60;module name&#62;
        &#45;&#45;&#45;&#60;module name&#62;&#45;examples</pre></div><p class="paragraph"/>So far we have introduced only modules Kryo Serializer and JavaEE Inject, but WicketStuff comes with many other modules that can be used in our applications. Some of them come in handy to improve the user experience of our pages with complex components or integrating some popular web services (like <a href="http://maps.google.com/" target="blank">Google Maps</a> ) and JavaScript libraries (like <a href="http://www.tinymce.com/" target="blank">TinyMCE</a> ).<p class="paragraph"/>This appendix provides a quick overview of what WicketStuff offers to enhance the usability and the visually-appealing of our pages.<p class="paragraph"/><blockquote class="note">
Every WicketStuff module can be downloaded as JAR archive at <a href="http://mvnrepository.com" target="blank">http://mvnrepository.com</a> . This site provides also the XML fragment needed to include it as a dependency into our pom.xml file.
</blockquote>



<h2 id="wicketstuff_2">29.2 Module tinymce</h2>
<p class="paragraph"/>Module tinymce offers integration with the namesake JavaScript library that turns our ‚Äúhumble‚Äù text-areas into a full-featured HTML WYSIWYG editor:<p class="paragraph"/><img border="0" class="center" src="../img/tinymce.png"></img><p class="paragraph"/>To ‚Äútinyfy‚Äù a textarea component we must use behavior TinyMceBehavior:<p class="paragraph"/><div class="code"><pre>TextArea textArea = <span class="java&#45;keyword">new</span> TextArea(<span class="java&#45;quote">"textArea"</span>, <span class="java&#45;keyword">new</span> Model(<span class="java&#45;quote">""</span>));
textArea.add(<span class="java&#45;keyword">new</span> TinyMceBehavior());</pre></div><p class="paragraph"/>By default TinyMceBehavior adds only a basic set of functionalities to our textarea:<p class="paragraph"/><img border="0" class="center" src="../img/tinymce_basic.png"></img><p class="paragraph"/>To add more functionalities we must use class TinyMCESettings to register additional TinyMCE plugins and to customize the toolbars buttons. The following code is an excerpt from example page FullFeaturedTinyMCEPage:<p class="paragraph"/><div class="code"><pre>TinyMCESettings settings = <span class="java&#45;keyword">new</span> TinyMCESettings(
                       TinyMCESettings.Theme.advanced);
//&#8230;
// first toolbar
//&#8230;
settings.add(Button.newdocument, TinyMCESettings.Toolbar.first,
		      TinyMCESettings.Position.before);
settings.add(Button.separator, TinyMCESettings.Toolbar.first,
		      TinyMCESettings.Position.before);
settings.add(Button.fontselect, TinyMCESettings.Toolbar.first,
		      TinyMCESettings.Position.after);
//&#8230;
// other settings
settings.setToolbarAlign(
   		TinyMCESettings.Align.left);
settings.setToolbarLocation(
   		TinyMCESettings.Location.top);
settings.setStatusbarLocation(
   		TinyMCESettings.Location.bottom);
settings.setResizing(<span class="java&#45;keyword">true</span>);
//&#8230;
TextArea textArea = <span class="java&#45;keyword">new</span> TextArea(<span class="java&#45;quote">"ta"</span>, <span class="java&#45;keyword">new</span> Model(TEXT));
textArea.add(<span class="java&#45;keyword">new</span> TinyMceBehavior(settings));</pre></div><p class="paragraph"/>For more configuration examples see pages inside package wicket.contrib.examples.tinymce in the example project of the module.



<h2 id="wicketstuff_3">29.3 Module wicketstuff-gmap3</h2>
<p class="paragraph"/>Module wicketstuff-gmap3 integrates <a href="http://maps.google.com" target="blank">Google Maps</a> service with Wicket providing component org.wicketstuff.gmap.GMap. If we want to embed Google Maps into one of our pages we just need to add component GMap inside the page. The following snippet is taken from example page SimplePage:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#8230;
&#60;body&#62;
  &#60;div wicket:id=<span class="java&#45;quote">"map"</span>&#62;Map&#60;/div&#62;
&#60;/body&#62;
...</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class SimplePage <span class="java&#45;keyword">extends</span> WicketExamplePage
&#123;
    <span class="java&#45;keyword">public</span> SimplePage()
    &#123;
        GMap map = <span class="java&#45;keyword">new</span> GMap(<span class="java&#45;quote">"map"</span>);
        map.setStreetViewControlEnabled(<span class="java&#45;keyword">false</span>);
        map.setScaleControlEnabled(<span class="java&#45;keyword">true</span>);
        map.setScrollWheelZoomEnabled(<span class="java&#45;keyword">true</span>);
        map.setCenter(<span class="java&#45;keyword">new</span> GLatLng(52.47649, 13.228573));        
        add(map);
    &#125;
&#125;</pre></div><p class="paragraph"/>The component defines a number of setters to customize its behavior and appearance. More info can be found on wiki page <a href="https://github.com/wicketstuff/core/wiki/Gmap3" target="blank">https://github.com/wicketstuff/core/wiki/Gmap3</a> .


<h2 id="wicketstuff_4">29.4 Module wicketstuff-googlecharts</h2>
<p class="paragraph"/>To integrate the <a href="https://developers.google.com/chart/" target="blank">Google Chart</a> tool into our pages we can use module wicketstuff-googlecharts. To display a chart we must combine the following entities: component Chart, interface IChartData and class ChartProvider, all inside package org.wicketstuff.googlecharts. The following snippet is taken from example page Home:<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#8230;
  &#60;h2&#62;Hello World&#60;/h2&#62;
  &#60;img wicket:id=<span class="java&#45;quote">"helloWorld"</span>/&#62;
...</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre>IChartData data = <span class="java&#45;keyword">new</span> AbstractChartData()&#123;
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">double</span>&#91;&#93;&#91;&#93; getData()&#123;
       <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> <span class="java&#45;object">double</span>&#91;&#93;&#91;&#93; &#123; &#123; 34, 22 &#125; &#125;;
    &#125;
&#125;;<p class="paragraph"/>ChartProvider provider = <span class="java&#45;keyword">new</span> ChartProvider(<span class="java&#45;keyword">new</span> Dimension(250, 100), ChartType.PIE_3D, data);
provider.setPieLabels(<span class="java&#45;keyword">new</span> <span class="java&#45;object">String</span>&#91;&#93; &#123; <span class="java&#45;quote">"Hello"</span>, <span class="java&#45;quote">"World"</span> &#125;);
add(<span class="java&#45;keyword">new</span> Chart(<span class="java&#45;quote">"helloWorld"</span>, provider));</pre></div><p class="paragraph"/><strong class="bold">Displayed chart:</strong><p class="paragraph"/><img border="0" class="center" src="../img/googlechart.png"></img><p class="paragraph"/>As we can see in the snippet above, component Chart must be used with &#60;img&#62; tag while the input data returned by IChartData must be a two-dimensional array of double values. 


<h2 id="wicketstuff_5">29.5 Module wicketstuff-inmethod-grid</h2>
<p class="paragraph"/>Module wicketstuff-inmethod-grid implements a sophisticated grid-component with class com. inmethod.grid.datagrid.DataGrid.<p class="paragraph"/>Just like pageable repeaters (seen in <a href="../guide/single.html#repeaters_4" class="guide">paragraph 13.4</a>) DataGrid provides data pagination and uses interface IDataProvider as data source. In addition the component is completely ajaxified:<p class="paragraph"/><img border="0" class="center" src="../img/inmethod-grid1.png"></img><p class="paragraph"/>DataGrid supports also editable cells and row selection:<p class="paragraph"/><img border="0" class="center" src="../img/inmethod-grid2.png"></img><p class="paragraph"/>The following snippet illustrate how to use DataGrid and is taken from wiki page <a href="https://github.com/wicketstuff/core/wiki/InMethodGrid" target="blank">https://github.com/wicketstuff/core/wiki/InMethodGrid</a> :<p class="paragraph"/><strong class="bold">HTML:</strong><p class="paragraph"/><div class="code"><pre>&#8230;
  &#60;div wicket:id=<span class="java&#45;quote">"grid"</span>&#62;Grid&#60;/div&#62;
...</pre></div><p class="paragraph"/><strong class="bold">Java code:</strong><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">final</span> List&#60;Person&#62; personList = //load a list of Persons
<span class="java&#45;keyword">final</span> ListDataProvider listDataProvider = <span class="java&#45;keyword">new</span> ListDataProvider(personList);
//define grid's columns
List&#60;IGridColumn&#62; cols = (List) Arrays.asList(
	     <span class="java&#45;keyword">new</span> PropertyColumn(<span class="java&#45;keyword">new</span> Model(<span class="java&#45;quote">"First Name"</span>), <span class="java&#45;quote">"firstName"</span>),
	     <span class="java&#45;keyword">new</span> PropertyColumn(<span class="java&#45;keyword">new</span> Model(<span class="java&#45;quote">"Last Name"</span>), <span class="java&#45;quote">"lastName"</span>));<p class="paragraph"/>DataGrid grid = <span class="java&#45;keyword">new</span> DefaultDataGrid(<span class="java&#45;quote">"grid"</span>, <span class="java&#45;keyword">new</span> DataProviderAdapter(listDataProvider), cols);
add(grid);</pre></div><p class="paragraph"/>In the code above we have used convenience class DefaultDataGrid that is a subclass of DataGrid and it already comes with a navigation toolbar.<p class="paragraph"/>The example pages are under package com.inmethod.grid.examples.pages in the example project which is hosted at <a href="http://www.wicket-library.com/inmethod-grid/data-grid/simple" target="blank">http://www.wicket-library.com/inmethod-grid/data-grid/simple</a> .<p class="paragraph"/>


<h2 id="wicketstuff_6">29.6 Module wicketstuff-rest-annotations</h2>
REST-based API are becoming more and more popular around the web and the number of services based on this architecture is constantly increasing.<p class="paragraph"/>Wicket is well-known for its capability of transparently handling the state of web applications on server side, but it can be also easily adopted to create RESTful services.
WicketStuff module for REST provides a special resource class and a set of annotations to implement REST APIs/services in much the same way as we do it with Spring MVC or with the standard JAX-RS.<p class="paragraph"/>The module provides class <code>AbstractRestResource</code> as generic abstract class to implement a Wicket resource that handles the request and the response using a particular data format (XML, JSON, etc...).
Subclassing <code>AbstractRestResource</code> we can create custom resources and map their pubblic methods to a given subpath with annotation <code>MethodMapping</code>. The following snippet is taken from resource <code>PersonsRestResource</code> inside module <code>'restannotations-examples'</code>:<p class="paragraph"/><div class="code"><pre>@MethodMapping(<span class="java&#45;quote">"/persons"</span>)
    <span class="java&#45;keyword">public</span> List&#60;PersonPojo&#62; getAllPersons() &#123;
        //method mapped at subpath <span class="java&#45;quote">"/persons"</span> and HTTP method GET
    &#125;<p class="paragraph"/>    @MethodMapping(value = <span class="java&#45;quote">"/persons/&#123;personIndex&#125;"</span>, httpMethod = HttpMethod.DELETE)
    <span class="java&#45;keyword">public</span> void deletePerson(<span class="java&#45;object">int</span> personIndex) &#123;
        //method mapped at subpath <span class="java&#45;quote">"/persons/&#123;personIndex&#125;"</span> and HTTP method DELETE. 
        //Segment &#123;personIndex&#125; will contain an integer value as index.
    &#125;<p class="paragraph"/>    @MethodMapping(value = <span class="java&#45;quote">"/persons"</span>, httpMethod = HttpMethod.POST)
    <span class="java&#45;keyword">public</span> void createPerson(@RequestBody PersonPojo personPojo) &#123;
        //creates a <span class="java&#45;keyword">new</span> instance of PersonPojo reading it from request body
    &#125;</pre></div><p class="paragraph"/><code>MethodMapping</code> requires to specify the subpath we want to map the method to. In addition we can specify also the HTTP method that must be used to invoke the method via REST (GET, POST, DELETE, PATCH, etc...). This value can be specified with enum class <code>HttpMethod</code> and is GET by default. 
In the code above we can see annotation <code>RequestBody</code> which is used to extract the value of a method parameter from the request body (method createPerson).
To write/read objects to response/from request, <code>AbstractRestResource</code> uses an implementation of interface <code>IWebSerialDeserial</code> which defines the following methods:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">interface</span> IWebSerialDeserial &#123;<p class="paragraph"/>       <span class="java&#45;keyword">public</span> void objectToResponse(<span class="java&#45;object">Object</span> targetObject, WebResponse response, <span class="java&#45;object">String</span> mimeType) <span class="java&#45;keyword">throws</span> Exception;<p class="paragraph"/>       <span class="java&#45;keyword">public</span> &#60;T&#62; T requestToObject(WebRequest request, <span class="java&#45;object">Class</span>&#60;T&#62; argClass, <span class="java&#45;object">String</span> mimeType) <span class="java&#45;keyword">throws</span> Exception;<p class="paragraph"/>       <span class="java&#45;keyword">public</span> <span class="java&#45;object">boolean</span> isMimeTypeSupported(<span class="java&#45;object">String</span> mimeType);
    &#125;</pre></div><p class="paragraph"/>To convert segments value (which are strings) to parameters type, <code>AbstractRestResource</code> uses the standard Wicket mechanism based on the application converter locator:<p class="paragraph"/><div class="code"><pre>//<span class="java&#45;keyword">return</span> the converter <span class="java&#45;keyword">for</span> type clazz
    IConverter converter = Application.get().getConverterLocator().getConverter(clazz);
    //convert string to object
    <span class="java&#45;keyword">return</span> converter.convertToObject(value, Session.get().getLocale());</pre></div><p class="paragraph"/>In order to promote the principle of convention over configuration, we don't need to use any annotation to map method parameters to path parameters if they are declared in the same order. If we need to manually bind method parameters to path parameters we can use annotation <code>PathParam</code>.<p class="paragraph"/><div class="code"><pre>@MethodMapping(value = <span class="java&#45;quote">"/variable/&#123;p1&#125;/order/&#123;p2&#125;"</span>, produces = RestMimeTypes.PLAIN_TEXT)
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> testParamOutOfOrder(<code>PathParam(<span class="java&#45;quote">"p2"</span>) <span class="java&#45;object">String</span> textParam, </code>PathParam(<span class="java&#45;quote">"p1"</span>) <span class="java&#45;object">int</span> intParam) &#123;
        //method parameter textParam is taken from path param 'p2', <span class="java&#45;keyword">while</span> intParam uses 'p1'
    &#125;</pre></div><p class="paragraph"/>As JSON is de-facto standard format for REST API, the project comes also with a ready-to-use resource (<code>GsonRestResource</code>) and a serial/deserial (<code>GsonSerialDeserial</code>) that work with JSON format (both inside module <code>'restannotations-json'</code>). These classes use Gson as JSON library.<p class="paragraph"/><code>AbstractRestResource</code> supports role-based authorizations for mapped method with annotation <code>AuthorizeInvocation</code>:<p class="paragraph"/><div class="code"><pre>@MethodMapping(value = <span class="java&#45;quote">"/admin"</span>, httpMethod = HttpMethod.GET)
    @AuthorizeInvocation(<span class="java&#45;quote">"ROLE_ADMIN"</span>)
    <span class="java&#45;keyword">public</span> void testMethodAdminAuth() &#123;<p class="paragraph"/>    &#125;</pre></div><p class="paragraph"/>To use annotation <code>AuthorizeInvocation</code> we must specify in the resource construcor an instance of Wicket interface <code>IRoleCheckingStrategy</code>.<p class="paragraph"/>To read the complete documentation of the module and to discover more advanced feature please refer to the <a href="https://github.com/wicketstuff/core/tree/master/wicketstuff-restannotations-parent" target="blank">project homepage</a>



<h2 id="wicketstuff_7">29.7 Module stateless</h2>
Wicket makes working with AJAX easy and pleasant with its component-oriented abstraction. However as side effect, AJAX components and behaviors make their hosting page stateful. This can be quite annoying if we are working on a page that must be stateless (for example a login page). 
In this case an obvious solution would be to roll out our own stateless components/behaviors, but Wicketstuff alredy offers such kind of artifacts with <code>stateless</code> module. Here you can find the stateless version of the basic AJAX componets and behaviors shiped with Wicket, like <code>StatelessAjaxSubmitLink</code>, <code>StatelessAjaxFallbackLink</code>, <code>StatelessAjaxEventBehavior</code>, <code>StatelessAjaxFormSubmitBehavior</code> etc&#8230;
A short introduction to this module can be found on its <a href="https://github.com/wicketstuff/core/tree/master/stateless-parent" target="blank">home page</a> .<p class="paragraph"/>


<h1 id="redirects">30 Lost In Redirection With Apache Wicket (Appendix)</h1>
Quite a few teams have already got stuck into the following problem when working with wicket forms in a clustered environment while having 2 (or more) tomcat server with enabled session replication running.<p class="paragraph"/>In case of invalid data being submitted with a form instance for example, it seemed like according error messages wouldn‚Äôt be presented when the same form page gets displayed again. Sometimes! And sometimes they would! One of those nightmares of rather deterministic programmer‚Äôs life. This so called Lost In Redirection problem, even if it looks like a wicket bug at first, is rather a result of a default setting in wicket regarding the processing of form submissions in general. In order to prevent another wide known problem of double form submissions, Wicket uses a so called REDIRECT_TO_BUFFER strategy for dealing with rendering a page after web form‚Äôs processing (@see RequestCycleSettings#RenderStrategy).<p class="paragraph"/>What does the default RenderStrategy actually do?<p class="paragraph"/>Both logical parts of a single HTTP request, an action and a render part get processed within the same request, but instead of streaming the render result to the browser directly, the result is cached on the server first.<p class="paragraph"/><img border="0" class="center" src="../img/lost-in-redirection-mockup.png"></img><p class="paragraph"/>Wicket will create an according BufferedHttpServletResponse instance that will be used to cache the resulting HttpServletResponse within the WebApplication.<p class="paragraph"/><img border="0" class="center" src="../img/lost-in-redirection-mockup2.png"></img><p class="paragraph"/>After the buffered response is cached the HTTP status code of 302 get‚Äôs provided back to the browser resulting in an additional GET request to the redirect URL (which Wicket sets to the URL of the Form itself). There is a special handling code for this case in the WicketFilter instance that then looks up a Map of buffered responses within the WebApplication accordingly. If an appropriate already cached response for the current request is found, it get‚Äôs streamed back to the browser immediately. No additional form processing happens now. The following is a code snippet taken from WicketFilter:<p class="paragraph"/><div class="code"><pre>// Are we using REDIRECT_TO_BUFFER?
<span class="java&#45;keyword">if</span> (webApplication.getRequestCycleSettings().getRenderStrategy() == RequestCycleSettings.REDIRECT_TO_BUFFER)
&#123;
    // Try to see <span class="java&#45;keyword">if</span> there is a redirect stored
    // <span class="java&#45;keyword">try</span> get an existing session
    ISessionStore sessionStore = webApplication.getSessionStore();
    <span class="java&#45;object">String</span> sessionId = sessionStore.getSessionId(request, <span class="java&#45;keyword">false</span>);
    <span class="java&#45;keyword">if</span> (sessionId != <span class="java&#45;keyword">null</span>)
    &#123;
        BufferedHttpServletResponse bufferedResponse = <span class="java&#45;keyword">null</span>;
        <span class="java&#45;object">String</span> queryString = servletRequest.getQueryString();
        // look <span class="java&#45;keyword">for</span> buffered response
        <span class="java&#45;keyword">if</span> (!Strings.isEmpty(queryString))
        &#123;
            bufferedResponse = webApplication.popBufferedResponse(sessionId,
                queryString);
        &#125;
        <span class="java&#45;keyword">else</span>
        &#123;
            bufferedResponse = webApplication.popBufferedResponse(sessionId,
                relativePath);
        &#125;
        // <span class="java&#45;keyword">if</span> a buffered response was found
        <span class="java&#45;keyword">if</span> (bufferedResponse != <span class="java&#45;keyword">null</span>)
        &#123;
            bufferedResponse.writeTo(servletResponse);
            // redirect responses are ignored <span class="java&#45;keyword">for</span> the request
            // logger&#8230;
            <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">true</span>;
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>So what happens in case you have 2 server running your application with session replication and load balancing turned on while using the default RenderStrategy described above?<p class="paragraph"/>Since a Map of buffered responses is cached within a WebApplication instance that does not get replicated between the nodes obviously, a redirect request that is suppose to pick up the previously cached response (having possibly form violation messages inside) potentially get‚Äôs directed to the second node in your cluster by the load balancer. The second node does not have any responses already prepared and cached for your user. The node therefore handles the request as a completely new request for the same form page and displays a fresh new form page instance to the user accordingly.<p class="paragraph"/><img border="0" class="center" src="../img/lost-in-redirection-mockup3.png"></img><p class="paragraph"/>Unfortunately, there is currently no ideal solution to the problem described above. The default RenderStrategy used by Apache Wicket simply does not work well in a fully clustered environment with load balancing and session replication turned on. One possibility is to change the default render strategy for your application to a so called ONE_PASS_RENDER RenderStrategy which is the more suitable option to use when you want to do sophisticated (non-sticky session) clustering. This is easily done in the init method of your own subclass of Wicket‚Äôs WebApplication :<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> void init() &#123;
    getRequestCycleSettings().setRenderStrategy(
        RequestCycleSettings.ONE_PASS_RENDER);
&#125;</pre></div><p class="paragraph"/>ONE_PASS_RENDER RenderStrategy does not solve the double submit problem though! So this way you‚Äôd only be trading one problem for another one actually.<p class="paragraph"/>You could of course turn on the session stickiness between your load balancer (apache server) and your tomcat server additionally to the session replication which would be the preferred solution in my opinion.<p class="paragraph"/><img border="0" class="center" src="../img/lost-in-redirection-mockup4.png"></img><p class="paragraph"/>Session replication would still provide you with failover in case one of the tomcat server dies for whatever reason and sticky sessions would ensure that the Lost In Redirection problem does not occur any more.<p class="paragraph"/>


<h1 id="contributing">31 Contributing to this guide (Appendix)</h1>
You can contribute to this guide by following these steps:
<ul class="star">
<li>The guide uses Grails GDoc to generate the final HTML/PDF so you should consult with its <a href="http://grails.org/WikiSyntax" target="blank">syntax</a>.</li>
<li>Clone Apache Wicket's GIT repository <a href="https://github.com/apache/wicket.git" target="blank">site</a></li>
</ul><p class="paragraph"/><div class="code"><pre>git clone https://github.com/apache/wicket.git</pre></div>
<ul class="star">
<li>Edit the  <em class="italic">.gdoc</em>  files in  <em class="italic">wicket/wicket-user-guide/src/docs/guide</em>  folder</li>
<li>To preview your changes run "mvn clean package -P guide" in the  <em class="italic">wicket/wicket-user-guide</em>  folder (in eclipse use a run configuration)</li>
<li>Navigate to  <em class="italic">wicket/wicket-user-guide/target/guide/7.x</em>  and open one of the following files a browser / pdf viewer:</li>
<ul class="star">
<li> <em class="italic">index.html</em>  (multi page version)</li>
<li> <em class="italic">guide/single.html</em>  (single page version)</li>
<li> <em class="italic">guide/single.pdf</em>  (single page pdf version)</li>
</ul>
<li>Create a ticket in Apache Wicket's <a href="https://issues.apache.org/jira/browse/WICKET" target="blank">JIRA</a></li>
<li><strong class="bold">Commit and push the changes</strong> to your forked Apacke Wicket's GIT repository and <strong class="bold">create a pull request</strong> on github</li>
</ul><p class="paragraph"/><strong class="bold">Thank you!</strong>


                    </div>
                </td>
                <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                </div>
            </div>
        </td>
            </tr>
        </table>

        <div id="footer">
            
Copyright &copy; 2013-2016 ‚Äî <a href="http://www.apache.org/" target="_blank">The Apache Software Foundation</a> 
                      ‚Äî <b style="color:#E8590A !important;">(Generated on: 2016-04-07 - 07:44:45 +0000)</b>

            
        </div>



<script type="text/javascript" src="../js/docs.js"></script>

    </body>
</html>
